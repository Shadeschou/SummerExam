(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),exports, require('@angular/core')) :
	typeof define === 'function' && define.amd ? define(['@angular/core','exports', '@angular/core'], factory) :
	(factory(global.ng.core,(global.angularFontAwesome = global.angularFontAwesome || {}),global.ng.core));
}(this, (function (ɵngcc0,exports,_angular_core) { 'use strict';

var AngularFontAwesomeComponent = (function () {
    function AngularFontAwesomeComponent() {
        this._optionalClasses = [];
    }
    /**
     * @return {?}
     */
    AngularFontAwesomeComponent.prototype.ngOnInit = function () {
        if (!this.name) {
            throw new Error('Missing "name" property for Angular2 Font Awesome component');
        }
        if (this.size) {
            this.addToOptionalClasses("fa-" + this.size);
        }
        if (this.fixed) {
            this.addToOptionalClasses("fa-fw");
        }
        if (this.animation) {
            this.addToOptionalClasses("fa-" + this.animation);
        }
        if (this.rotate) {
            var /** @type {?} */ rotateClass = (typeof this.rotate === 'number') ? "fa-rotate-" + this.rotate
                : "fa-flip-" + this.rotate;
            this.addToOptionalClasses(rotateClass);
        }
        if (this.inverse) {
            this.addToOptionalClasses("fa-inverse");
        }
    };
    Object.defineProperty(AngularFontAwesomeComponent.prototype, "optionalClasses", {
        /**
         * @return {?}
         */
        get: function () {
            return this._optionalClasses;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} addClass
     * @return {?}
     */
    AngularFontAwesomeComponent.prototype.addToOptionalClasses = function (addClass) {
        this._optionalClasses.push(addClass);
    };
AngularFontAwesomeComponent.ɵfac = function AngularFontAwesomeComponent_Factory(t) { return new (t || AngularFontAwesomeComponent)(); };
AngularFontAwesomeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AngularFontAwesomeComponent, selectors: [["fa"]], inputs: { name: "name", title: "title", size: "size", fixed: "fixed", animation: "animation", rotate: "rotate", inverse: "inverse" }, decls: 1, vars: 4, consts: [["aria-hidden", "true", 3, "ngClass"]], template: function AngularFontAwesomeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "i", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMapInterpolate1("fa fa-", ctx.name, "");
        ɵngcc0.ɵɵproperty("ngClass", ctx.optionalClasses);
    } }, directives: function () { return [NgClass]; }, styles: [""] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularFontAwesomeComponent, [{
        type: _angular_core.Component,
        args: [{
                selector: 'fa',
                template: "<i class=\"fa fa-{{ name }}\" aria-hidden=\"true\" [ngClass]=\"optionalClasses\" ></i> ",
                styles: [""]
            }]
    }], function () { return []; }, { name: [{
            type: _angular_core.Input
        }], title: [{
            type: _angular_core.Input
        }], size: [{
            type: _angular_core.Input
        }], fixed: [{
            type: _angular_core.Input
        }], animation: [{
            type: _angular_core.Input
        }], rotate: [{
            type: _angular_core.Input
        }], inverse: [{
            type: _angular_core.Input
        }] }); })();
    return AngularFontAwesomeComponent;
}());
/**
 * @nocollapse
 */
AngularFontAwesomeComponent.ctorParameters = function () { return []; };
AngularFontAwesomeComponent.propDecorators = {
    'name': [{ type: _angular_core.Input },],
    'title': [{ type: _angular_core.Input },],
    'size': [{ type: _angular_core.Input },],
    'fixed': [{ type: _angular_core.Input },],
    'animation': [{ type: _angular_core.Input },],
    'rotate': [{ type: _angular_core.Input },],
    'inverse': [{ type: _angular_core.Input },],
};

var AngularFontAwesomeService = (function () {
    function AngularFontAwesomeService() {
    }
AngularFontAwesomeService.ɵfac = function AngularFontAwesomeService_Factory(t) { return new (t || AngularFontAwesomeService)(); };
AngularFontAwesomeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AngularFontAwesomeService, factory: function (t) { return AngularFontAwesomeService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularFontAwesomeService, [{
        type: _angular_core.Injectable
    }], function () { return []; }, null); })();
    return AngularFontAwesomeService;
}());
/**
 * @nocollapse
 */
AngularFontAwesomeService.ctorParameters = function () { return []; };

var __extends = (undefined && undefined.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * @license Angular v4.1.3
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * This class should not be used directly by an application developer. Instead, use
 * {\@link Location}.
 *
 * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform
 * agnostic.
 * This means that we can have different implementation of `PlatformLocation` for the different
 * platforms that angular supports. For example, `\@angular/platform-browser` provides an
 * implementation specific to the browser environment, while `\@angular/platform-webworker` provides
 * one suitable for use with web workers.
 *
 * The `PlatformLocation` class is used directly by all implementations of {\@link LocationStrategy}
 * when they need to interact with the DOM apis like pushState, popState, etc...
 *
 * {\@link LocationStrategy} in turn is used by the {\@link Location} service which is used directly
 * by the {\@link Router} in order to navigate between routes. Since all interactions between {\@link
 * Router} /
 * {\@link Location} / {\@link LocationStrategy} and DOM apis flow through the `PlatformLocation`
 * class they are all platform independent.
 *
 * \@stable
 * @abstract
 */
var PlatformLocation = (function () {
    function PlatformLocation() {
    }
    /**
     * @abstract
     * @return {?}
     */
    PlatformLocation.prototype.getBaseHrefFromDOM = function () { };
    /**
     * @abstract
     * @param {?} fn
     * @return {?}
     */
    PlatformLocation.prototype.onPopState = function (fn) { };
    /**
     * @abstract
     * @param {?} fn
     * @return {?}
     */
    PlatformLocation.prototype.onHashChange = function (fn) { };
    /**
     * @abstract
     * @return {?}
     */
    PlatformLocation.prototype.pathname = function () { };
    /**
     * @abstract
     * @return {?}
     */
    PlatformLocation.prototype.search = function () { };
    /**
     * @abstract
     * @return {?}
     */
    PlatformLocation.prototype.hash = function () { };
    /**
     * @abstract
     * @param {?} state
     * @param {?} title
     * @param {?} url
     * @return {?}
     */
    PlatformLocation.prototype.replaceState = function (state, title, url) { };
    /**
     * @abstract
     * @param {?} state
     * @param {?} title
     * @param {?} url
     * @return {?}
     */
    PlatformLocation.prototype.pushState = function (state, title, url) { };
    /**
     * @abstract
     * @return {?}
     */
    PlatformLocation.prototype.forward = function () { };
    /**
     * @abstract
     * @return {?}
     */
    PlatformLocation.prototype.back = function () { };
    return PlatformLocation;
}());
/**
 * \@whatItDoes indicates when a location is initialized
 * \@experimental
 */
var LOCATION_INITIALIZED = new _angular_core.InjectionToken('Location Initialized');
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * `LocationStrategy` is responsible for representing and reading route state
 * from the browser's URL. Angular provides two strategies:
 * {\@link HashLocationStrategy} and {\@link PathLocationStrategy}.
 *
 * This is used under the hood of the {\@link Location} service.
 *
 * Applications should use the {\@link Router} or {\@link Location} services to
 * interact with application route state.
 *
 * For instance, {\@link HashLocationStrategy} produces URLs like
 * `http://example.com#/foo`, and {\@link PathLocationStrategy} produces
 * `http://example.com/foo` as an equivalent URL.
 *
 * See these two classes for more.
 *
 * \@stable
 * @abstract
 */
var LocationStrategy = (function () {
    function LocationStrategy() {
    }
    /**
     * @abstract
     * @param {?=} includeHash
     * @return {?}
     */
    LocationStrategy.prototype.path = function (includeHash) { };
    /**
     * @abstract
     * @param {?} internal
     * @return {?}
     */
    LocationStrategy.prototype.prepareExternalUrl = function (internal) { };
    /**
     * @abstract
     * @param {?} state
     * @param {?} title
     * @param {?} url
     * @param {?} queryParams
     * @return {?}
     */
    LocationStrategy.prototype.pushState = function (state, title, url, queryParams) { };
    /**
     * @abstract
     * @param {?} state
     * @param {?} title
     * @param {?} url
     * @param {?} queryParams
     * @return {?}
     */
    LocationStrategy.prototype.replaceState = function (state, title, url, queryParams) { };
    /**
     * @abstract
     * @return {?}
     */
    LocationStrategy.prototype.forward = function () { };
    /**
     * @abstract
     * @return {?}
     */
    LocationStrategy.prototype.back = function () { };
    /**
     * @abstract
     * @param {?} fn
     * @return {?}
     */
    LocationStrategy.prototype.onPopState = function (fn) { };
    /**
     * @abstract
     * @return {?}
     */
    LocationStrategy.prototype.getBaseHref = function () { };
    return LocationStrategy;
}());
/**
 * The `APP_BASE_HREF` token represents the base href to be used with the
 * {\@link PathLocationStrategy}.
 *
 * If you're using {\@link PathLocationStrategy}, you must provide a provider to a string
 * representing the URL prefix that should be preserved when generating and recognizing
 * URLs.
 *
 * ### Example
 *
 * ```typescript
 * import {Component, NgModule} from '\@angular/core';
 * import {APP_BASE_HREF} from '\@angular/common';
 *
 * \@NgModule({
 *   providers: [{provide: APP_BASE_HREF, useValue: '/my/app'}]
 * })
 * class AppModule {}
 * ```
 *
 * \@stable
 */
var APP_BASE_HREF = new _angular_core.InjectionToken('appBaseHref');
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes `Location` is a service that applications can use to interact with a browser's URL.
 * \@description
 * Depending on which {\@link LocationStrategy} is used, `Location` will either persist
 * to the URL's path or the URL's hash segment.
 *
 * Note: it's better to use {\@link Router#navigate} service to trigger route changes. Use
 * `Location` only if you need to interact with or create normalized URLs outside of
 * routing.
 *
 * `Location` is responsible for normalizing the URL against the application's base href.
 * A normalized URL is absolute from the URL host, includes the application's base href, and has no
 * trailing slash:
 * - `/my/app/user/123` is normalized
 * - `my/app/user/123` **is not** normalized
 * - `/my/app/user/123/` **is not** normalized
 *
 * ### Example
 * {\@example common/location/ts/path_location_component.ts region='LocationComponent'}
 * \@stable
 */
var Location = (function () {
    /**
     * @param {?} platformStrategy
     */
    function Location(platformStrategy) {
        var _this = this;
        /**
         * \@internal
         */
        this._subject = new _angular_core.EventEmitter();
        this._platformStrategy = platformStrategy;
        var browserBaseHref = this._platformStrategy.getBaseHref();
        this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
        this._platformStrategy.onPopState(function (ev) {
            _this._subject.emit({
                'url': _this.path(true),
                'pop': true,
                'type': ev.type,
            });
        });
    }
    /**
     * @param {?=} includeHash
     * @return {?}
     */
    Location.prototype.path = function (includeHash) {
        if (includeHash === void 0) { includeHash = false; }
        return this.normalize(this._platformStrategy.path(includeHash));
    };
    /**
     * Normalizes the given path and compares to the current normalized path.
     * @param {?} path
     * @param {?=} query
     * @return {?}
     */
    Location.prototype.isCurrentPathEqualTo = function (path, query) {
        if (query === void 0) { query = ''; }
        return this.path() == this.normalize(path + Location.normalizeQueryParams(query));
    };
    /**
     * Given a string representing a URL, returns the normalized URL path without leading or
     * trailing slashes.
     * @param {?} url
     * @return {?}
     */
    Location.prototype.normalize = function (url) {
        return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
    };
    /**
     * Given a string representing a URL, returns the platform-specific external URL path.
     * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
     * before normalizing. This method will also add a hash if `HashLocationStrategy` is
     * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
     * @param {?} url
     * @return {?}
     */
    Location.prototype.prepareExternalUrl = function (url) {
        if (url && url[0] !== '/') {
            url = '/' + url;
        }
        return this._platformStrategy.prepareExternalUrl(url);
    };
    /**
     * Changes the browsers URL to the normalized version of the given URL, and pushes a
     * new item onto the platform's history.
     * @param {?} path
     * @param {?=} query
     * @return {?}
     */
    Location.prototype.go = function (path, query) {
        if (query === void 0) { query = ''; }
        this._platformStrategy.pushState(null, '', path, query);
    };
    /**
     * Changes the browsers URL to the normalized version of the given URL, and replaces
     * the top item on the platform's history stack.
     * @param {?} path
     * @param {?=} query
     * @return {?}
     */
    Location.prototype.replaceState = function (path, query) {
        if (query === void 0) { query = ''; }
        this._platformStrategy.replaceState(null, '', path, query);
    };
    /**
     * Navigates forward in the platform's history.
     * @return {?}
     */
    Location.prototype.forward = function () { this._platformStrategy.forward(); };
    /**
     * Navigates back in the platform's history.
     * @return {?}
     */
    Location.prototype.back = function () { this._platformStrategy.back(); };
    /**
     * Subscribe to the platform's `popState` events.
     * @param {?} onNext
     * @param {?=} onThrow
     * @param {?=} onReturn
     * @return {?}
     */
    Location.prototype.subscribe = function (onNext, onThrow, onReturn) {
        return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });
    };
    /**
     * Given a string of url parameters, prepend with '?' if needed, otherwise return parameters as
     * is.
     * @param {?} params
     * @return {?}
     */
    Location.normalizeQueryParams = function (params) {
        return params && params[0] !== '?' ? '?' + params : params;
    };
    /**
     * Given 2 parts of a url, join them with a slash if needed.
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    Location.joinWithSlash = function (start, end) {
        if (start.length == 0) {
            return end;
        }
        if (end.length == 0) {
            return start;
        }
        var /** @type {?} */ slashes = 0;
        if (start.endsWith('/')) {
            slashes++;
        }
        if (end.startsWith('/')) {
            slashes++;
        }
        if (slashes == 2) {
            return start + end.substring(1);
        }
        if (slashes == 1) {
            return start + end;
        }
        return start + '/' + end;
    };
    /**
     * If url has a trailing slash, remove it, otherwise return url as is.
     * @param {?} url
     * @return {?}
     */
    Location.stripTrailingSlash = function (url) { return url.replace(/\/$/, ''); };
Location.ɵfac = function Location_Factory(t) { return new (t || Location)(ɵngcc0.ɵɵinject(LocationStrategy)); };
Location.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: Location, factory: function (t) { return Location.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Location, [{
        type: _angular_core.Injectable
    }], function () { return [{ type: LocationStrategy }]; }, null); })();
    return Location;
}());
/**
 * @nocollapse
 */
Location.ctorParameters = function () { return [
    { type: LocationStrategy, },
]; };
/**
 * @param {?} baseHref
 * @param {?} url
 * @return {?}
 */
function _stripBaseHref(baseHref, url) {
    return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url;
}
/**
 * @param {?} url
 * @return {?}
 */
function _stripIndexHtml(url) {
    return url.replace(/\/index.html$/, '');
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Use URL hash for storing application location data.
 * \@description
 * `HashLocationStrategy` is a {\@link LocationStrategy} used to configure the
 * {\@link Location} service to represent its state in the
 * [hash fragment](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax)
 * of the browser's URL.
 *
 * For instance, if you call `location.go('/foo')`, the browser's URL will become
 * `example.com#/foo`.
 *
 * ### Example
 *
 * {\@example common/location/ts/hash_location_component.ts region='LocationComponent'}
 *
 * \@stable
 */
var HashLocationStrategy = (function (_super) {
    __extends(HashLocationStrategy, _super);
    /**
     * @param {?} _platformLocation
     * @param {?=} _baseHref
     */
    function HashLocationStrategy(_platformLocation, _baseHref) {
        var _this = _super.call(this) || this;
        _this._platformLocation = _platformLocation;
        _this._baseHref = '';
        if (_baseHref != null) {
            _this._baseHref = _baseHref;
        }
        return _this;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    HashLocationStrategy.prototype.onPopState = function (fn) {
        this._platformLocation.onPopState(fn);
        this._platformLocation.onHashChange(fn);
    };
    /**
     * @return {?}
     */
    HashLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
    /**
     * @param {?=} includeHash
     * @return {?}
     */
    HashLocationStrategy.prototype.path = function (includeHash) {
        if (includeHash === void 0) { includeHash = false; }
        // the hash value is always prefixed with a `#`
        // and if it is empty then it will stay empty
        var /** @type {?} */ path = this._platformLocation.hash;
        if (path == null)
            path = '#';
        return path.length > 0 ? path.substring(1) : path;
    };
    /**
     * @param {?} internal
     * @return {?}
     */
    HashLocationStrategy.prototype.prepareExternalUrl = function (internal) {
        var /** @type {?} */ url = Location.joinWithSlash(this._baseHref, internal);
        return url.length > 0 ? ('#' + url) : url;
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} path
     * @param {?} queryParams
     * @return {?}
     */
    HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {
        var /** @type {?} */ url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
        if (url.length == 0) {
            url = this._platformLocation.pathname;
        }
        this._platformLocation.pushState(state, title, url);
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} path
     * @param {?} queryParams
     * @return {?}
     */
    HashLocationStrategy.prototype.replaceState = function (state, title, path, queryParams) {
        var /** @type {?} */ url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
        if (url.length == 0) {
            url = this._platformLocation.pathname;
        }
        this._platformLocation.replaceState(state, title, url);
    };
    /**
     * @return {?}
     */
    HashLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
    /**
     * @return {?}
     */
    HashLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
HashLocationStrategy.ɵfac = function HashLocationStrategy_Factory(t) { return new (t || HashLocationStrategy)(ɵngcc0.ɵɵinject(PlatformLocation), ɵngcc0.ɵɵinject(APP_BASE_HREF, 8)); };
HashLocationStrategy.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: HashLocationStrategy, factory: function (t) { return HashLocationStrategy.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HashLocationStrategy, [{
        type: _angular_core.Injectable
    }], function () { return [{ type: PlatformLocation }, { type: undefined, decorators: [{
                type: _angular_core.Optional
            }, {
                type: _angular_core.Inject,
                args: [APP_BASE_HREF]
            }] }]; }, null); })();
    return HashLocationStrategy;
}(LocationStrategy));
/**
 * @nocollapse
 */
HashLocationStrategy.ctorParameters = function () { return [
    { type: PlatformLocation, },
    { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@whatItDoes Use URL for storing application location data.
 * \@description
 * `PathLocationStrategy` is a {\@link LocationStrategy} used to configure the
 * {\@link Location} service to represent its state in the
 * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the
 * browser's URL.
 *
 * If you're using `PathLocationStrategy`, you must provide a {\@link APP_BASE_HREF}
 * or add a base element to the document. This URL prefix that will be preserved
 * when generating and recognizing URLs.
 *
 * For instance, if you provide an `APP_BASE_HREF` of `'/my/app'` and call
 * `location.go('/foo')`, the browser's URL will become
 * `example.com/my/app/foo`.
 *
 * Similarly, if you add `<base href='/my/app'/>` to the document and call
 * `location.go('/foo')`, the browser's URL will become
 * `example.com/my/app/foo`.
 *
 * ### Example
 *
 * {\@example common/location/ts/path_location_component.ts region='LocationComponent'}
 *
 * \@stable
 */
var PathLocationStrategy = (function (_super) {
    __extends(PathLocationStrategy, _super);
    /**
     * @param {?} _platformLocation
     * @param {?=} href
     */
    function PathLocationStrategy(_platformLocation, href) {
        var _this = _super.call(this) || this;
        _this._platformLocation = _platformLocation;
        if (href == null) {
            href = _this._platformLocation.getBaseHrefFromDOM();
        }
        if (href == null) {
            throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
        }
        _this._baseHref = href;
        return _this;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    PathLocationStrategy.prototype.onPopState = function (fn) {
        this._platformLocation.onPopState(fn);
        this._platformLocation.onHashChange(fn);
    };
    /**
     * @return {?}
     */
    PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
    /**
     * @param {?} internal
     * @return {?}
     */
    PathLocationStrategy.prototype.prepareExternalUrl = function (internal) {
        return Location.joinWithSlash(this._baseHref, internal);
    };
    /**
     * @param {?=} includeHash
     * @return {?}
     */
    PathLocationStrategy.prototype.path = function (includeHash) {
        if (includeHash === void 0) { includeHash = false; }
        var /** @type {?} */ pathname = this._platformLocation.pathname +
            Location.normalizeQueryParams(this._platformLocation.search);
        var /** @type {?} */ hash = this._platformLocation.hash;
        return hash && includeHash ? "" + pathname + hash : pathname;
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} url
     * @param {?} queryParams
     * @return {?}
     */
    PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
        var /** @type {?} */ externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
        this._platformLocation.pushState(state, title, externalUrl);
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} url
     * @param {?} queryParams
     * @return {?}
     */
    PathLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {
        var /** @type {?} */ externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
        this._platformLocation.replaceState(state, title, externalUrl);
    };
    /**
     * @return {?}
     */
    PathLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
    /**
     * @return {?}
     */
    PathLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
PathLocationStrategy.ɵfac = function PathLocationStrategy_Factory(t) { return new (t || PathLocationStrategy)(ɵngcc0.ɵɵinject(PlatformLocation), ɵngcc0.ɵɵinject(APP_BASE_HREF, 8)); };
PathLocationStrategy.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PathLocationStrategy, factory: function (t) { return PathLocationStrategy.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PathLocationStrategy, [{
        type: _angular_core.Injectable
    }], function () { return [{ type: PlatformLocation }, { type: undefined, decorators: [{
                type: _angular_core.Optional
            }, {
                type: _angular_core.Inject,
                args: [APP_BASE_HREF]
            }] }]; }, null); })();
    return PathLocationStrategy;
}(LocationStrategy));
/**
 * @nocollapse
 */
PathLocationStrategy.ctorParameters = function () { return [
    { type: PlatformLocation, },
    { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@experimental
 * @abstract
 */
var NgLocalization = (function () {
    function NgLocalization() {
    }
    /**
     * @abstract
     * @param {?} value
     * @return {?}
     */
    NgLocalization.prototype.getPluralCategory = function (value) { };
    return NgLocalization;
}());
/**
 * Returns the plural category for a given value.
 * - "=value" when the case exists,
 * - the plural category otherwise
 *
 * \@internal
 * @param {?} value
 * @param {?} cases
 * @param {?} ngLocalization
 * @return {?}
 */
function getPluralCategory(value, cases, ngLocalization) {
    var /** @type {?} */ key = "=" + value;
    if (cases.indexOf(key) > -1) {
        return key;
    }
    key = ngLocalization.getPluralCategory(value);
    if (cases.indexOf(key) > -1) {
        return key;
    }
    if (cases.indexOf('other') > -1) {
        return 'other';
    }
    throw new Error("No plural message found for value \"" + value + "\"");
}
/**
 * Returns the plural case based on the locale
 *
 * \@experimental
 */
var NgLocaleLocalization = (function (_super) {
    __extends(NgLocaleLocalization, _super);
    /**
     * @param {?} locale
     */
    function NgLocaleLocalization(locale) {
        var _this = _super.call(this) || this;
        _this.locale = locale;
        return _this;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    NgLocaleLocalization.prototype.getPluralCategory = function (value) {
        var /** @type {?} */ plural = getPluralCase(this.locale, value);
        switch (plural) {
            case Plural.Zero:
                return 'zero';
            case Plural.One:
                return 'one';
            case Plural.Two:
                return 'two';
            case Plural.Few:
                return 'few';
            case Plural.Many:
                return 'many';
            default:
                return 'other';
        }
    };
NgLocaleLocalization.ɵfac = function NgLocaleLocalization_Factory(t) { return new (t || NgLocaleLocalization)(ɵngcc0.ɵɵinject(_angular_core.LOCALE_ID)); };
NgLocaleLocalization.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgLocaleLocalization, factory: function (t) { return NgLocaleLocalization.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgLocaleLocalization, [{
        type: _angular_core.Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: _angular_core.Inject,
                args: [_angular_core.LOCALE_ID]
            }] }]; }, null); })();
    return NgLocaleLocalization;
}(NgLocalization));
/**
 * @nocollapse
 */
NgLocaleLocalization.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
]; };
var Plural = {};
Plural.Zero = 0;
Plural.One = 1;
Plural.Two = 2;
Plural.Few = 3;
Plural.Many = 4;
Plural.Other = 5;
Plural[Plural.Zero] = "Zero";
Plural[Plural.One] = "One";
Plural[Plural.Two] = "Two";
Plural[Plural.Few] = "Few";
Plural[Plural.Many] = "Many";
Plural[Plural.Other] = "Other";
/**
 * Returns the plural case based on the locale
 *
 * \@experimental
 * @param {?} locale
 * @param {?} nLike
 * @return {?}
 */
function getPluralCase(locale, nLike) {
    // TODO(vicb): lazy compute
    if (typeof nLike === 'string') {
        nLike = parseInt(/** @type {?} */ (nLike), 10);
    }
    var /** @type {?} */ n = (nLike);
    var /** @type {?} */ nDecimal = n.toString().replace(/^[^.]*\.?/, '');
    var /** @type {?} */ i = Math.floor(Math.abs(n));
    var /** @type {?} */ v = nDecimal.length;
    var /** @type {?} */ f = parseInt(nDecimal, 10);
    var /** @type {?} */ t = parseInt(n.toString().replace(/^[^.]*\.?|0+$/g, ''), 10) || 0;
    var /** @type {?} */ lang = locale.split('-')[0].toLowerCase();
    switch (lang) {
        case 'af':
        case 'asa':
        case 'az':
        case 'bem':
        case 'bez':
        case 'bg':
        case 'brx':
        case 'ce':
        case 'cgg':
        case 'chr':
        case 'ckb':
        case 'ee':
        case 'el':
        case 'eo':
        case 'es':
        case 'eu':
        case 'fo':
        case 'fur':
        case 'gsw':
        case 'ha':
        case 'haw':
        case 'hu':
        case 'jgo':
        case 'jmc':
        case 'ka':
        case 'kk':
        case 'kkj':
        case 'kl':
        case 'ks':
        case 'ksb':
        case 'ky':
        case 'lb':
        case 'lg':
        case 'mas':
        case 'mgo':
        case 'ml':
        case 'mn':
        case 'nb':
        case 'nd':
        case 'ne':
        case 'nn':
        case 'nnh':
        case 'nyn':
        case 'om':
        case 'or':
        case 'os':
        case 'ps':
        case 'rm':
        case 'rof':
        case 'rwk':
        case 'saq':
        case 'seh':
        case 'sn':
        case 'so':
        case 'sq':
        case 'ta':
        case 'te':
        case 'teo':
        case 'tk':
        case 'tr':
        case 'ug':
        case 'uz':
        case 'vo':
        case 'vun':
        case 'wae':
        case 'xog':
            if (n === 1)
                return Plural.One;
            return Plural.Other;
        case 'agq':
        case 'bas':
        case 'cu':
        case 'dav':
        case 'dje':
        case 'dua':
        case 'dyo':
        case 'ebu':
        case 'ewo':
        case 'guz':
        case 'kam':
        case 'khq':
        case 'ki':
        case 'kln':
        case 'kok':
        case 'ksf':
        case 'lrc':
        case 'lu':
        case 'luo':
        case 'luy':
        case 'mer':
        case 'mfe':
        case 'mgh':
        case 'mua':
        case 'mzn':
        case 'nmg':
        case 'nus':
        case 'qu':
        case 'rn':
        case 'rw':
        case 'sbp':
        case 'twq':
        case 'vai':
        case 'yav':
        case 'yue':
        case 'zgh':
        case 'ak':
        case 'ln':
        case 'mg':
        case 'pa':
        case 'ti':
            if (n === Math.floor(n) && n >= 0 && n <= 1)
                return Plural.One;
            return Plural.Other;
        case 'am':
        case 'as':
        case 'bn':
        case 'fa':
        case 'gu':
        case 'hi':
        case 'kn':
        case 'mr':
        case 'zu':
            if (i === 0 || n === 1)
                return Plural.One;
            return Plural.Other;
        case 'ar':
            if (n === 0)
                return Plural.Zero;
            if (n === 1)
                return Plural.One;
            if (n === 2)
                return Plural.Two;
            if (n % 100 === Math.floor(n % 100) && n % 100 >= 3 && n % 100 <= 10)
                return Plural.Few;
            if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 99)
                return Plural.Many;
            return Plural.Other;
        case 'ast':
        case 'ca':
        case 'de':
        case 'en':
        case 'et':
        case 'fi':
        case 'fy':
        case 'gl':
        case 'it':
        case 'nl':
        case 'sv':
        case 'sw':
        case 'ur':
        case 'yi':
            if (i === 1 && v === 0)
                return Plural.One;
            return Plural.Other;
        case 'be':
            if (n % 10 === 1 && !(n % 100 === 11))
                return Plural.One;
            if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 4 &&
                !(n % 100 >= 12 && n % 100 <= 14))
                return Plural.Few;
            if (n % 10 === 0 || n % 10 === Math.floor(n % 10) && n % 10 >= 5 && n % 10 <= 9 ||
                n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 14)
                return Plural.Many;
            return Plural.Other;
        case 'br':
            if (n % 10 === 1 && !(n % 100 === 11 || n % 100 === 71 || n % 100 === 91))
                return Plural.One;
            if (n % 10 === 2 && !(n % 100 === 12 || n % 100 === 72 || n % 100 === 92))
                return Plural.Two;
            if (n % 10 === Math.floor(n % 10) && (n % 10 >= 3 && n % 10 <= 4 || n % 10 === 9) &&
                !(n % 100 >= 10 && n % 100 <= 19 || n % 100 >= 70 && n % 100 <= 79 ||
                    n % 100 >= 90 && n % 100 <= 99))
                return Plural.Few;
            if (!(n === 0) && n % 1e6 === 0)
                return Plural.Many;
            return Plural.Other;
        case 'bs':
        case 'hr':
        case 'sr':
            if (v === 0 && i % 10 === 1 && !(i % 100 === 11) || f % 10 === 1 && !(f % 100 === 11))
                return Plural.One;
            if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
                !(i % 100 >= 12 && i % 100 <= 14) ||
                f % 10 === Math.floor(f % 10) && f % 10 >= 2 && f % 10 <= 4 &&
                    !(f % 100 >= 12 && f % 100 <= 14))
                return Plural.Few;
            return Plural.Other;
        case 'cs':
        case 'sk':
            if (i === 1 && v === 0)
                return Plural.One;
            if (i === Math.floor(i) && i >= 2 && i <= 4 && v === 0)
                return Plural.Few;
            if (!(v === 0))
                return Plural.Many;
            return Plural.Other;
        case 'cy':
            if (n === 0)
                return Plural.Zero;
            if (n === 1)
                return Plural.One;
            if (n === 2)
                return Plural.Two;
            if (n === 3)
                return Plural.Few;
            if (n === 6)
                return Plural.Many;
            return Plural.Other;
        case 'da':
            if (n === 1 || !(t === 0) && (i === 0 || i === 1))
                return Plural.One;
            return Plural.Other;
        case 'dsb':
        case 'hsb':
            if (v === 0 && i % 100 === 1 || f % 100 === 1)
                return Plural.One;
            if (v === 0 && i % 100 === 2 || f % 100 === 2)
                return Plural.Two;
            if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 ||
                f % 100 === Math.floor(f % 100) && f % 100 >= 3 && f % 100 <= 4)
                return Plural.Few;
            return Plural.Other;
        case 'ff':
        case 'fr':
        case 'hy':
        case 'kab':
            if (i === 0 || i === 1)
                return Plural.One;
            return Plural.Other;
        case 'fil':
            if (v === 0 && (i === 1 || i === 2 || i === 3) ||
                v === 0 && !(i % 10 === 4 || i % 10 === 6 || i % 10 === 9) ||
                !(v === 0) && !(f % 10 === 4 || f % 10 === 6 || f % 10 === 9))
                return Plural.One;
            return Plural.Other;
        case 'ga':
            if (n === 1)
                return Plural.One;
            if (n === 2)
                return Plural.Two;
            if (n === Math.floor(n) && n >= 3 && n <= 6)
                return Plural.Few;
            if (n === Math.floor(n) && n >= 7 && n <= 10)
                return Plural.Many;
            return Plural.Other;
        case 'gd':
            if (n === 1 || n === 11)
                return Plural.One;
            if (n === 2 || n === 12)
                return Plural.Two;
            if (n === Math.floor(n) && (n >= 3 && n <= 10 || n >= 13 && n <= 19))
                return Plural.Few;
            return Plural.Other;
        case 'gv':
            if (v === 0 && i % 10 === 1)
                return Plural.One;
            if (v === 0 && i % 10 === 2)
                return Plural.Two;
            if (v === 0 &&
                (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80))
                return Plural.Few;
            if (!(v === 0))
                return Plural.Many;
            return Plural.Other;
        case 'he':
            if (i === 1 && v === 0)
                return Plural.One;
            if (i === 2 && v === 0)
                return Plural.Two;
            if (v === 0 && !(n >= 0 && n <= 10) && n % 10 === 0)
                return Plural.Many;
            return Plural.Other;
        case 'is':
            if (t === 0 && i % 10 === 1 && !(i % 100 === 11) || !(t === 0))
                return Plural.One;
            return Plural.Other;
        case 'ksh':
            if (n === 0)
                return Plural.Zero;
            if (n === 1)
                return Plural.One;
            return Plural.Other;
        case 'kw':
        case 'naq':
        case 'se':
        case 'smn':
            if (n === 1)
                return Plural.One;
            if (n === 2)
                return Plural.Two;
            return Plural.Other;
        case 'lag':
            if (n === 0)
                return Plural.Zero;
            if ((i === 0 || i === 1) && !(n === 0))
                return Plural.One;
            return Plural.Other;
        case 'lt':
            if (n % 10 === 1 && !(n % 100 >= 11 && n % 100 <= 19))
                return Plural.One;
            if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 9 &&
                !(n % 100 >= 11 && n % 100 <= 19))
                return Plural.Few;
            if (!(f === 0))
                return Plural.Many;
            return Plural.Other;
        case 'lv':
        case 'prg':
            if (n % 10 === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19 ||
                v === 2 && f % 100 === Math.floor(f % 100) && f % 100 >= 11 && f % 100 <= 19)
                return Plural.Zero;
            if (n % 10 === 1 && !(n % 100 === 11) || v === 2 && f % 10 === 1 && !(f % 100 === 11) ||
                !(v === 2) && f % 10 === 1)
                return Plural.One;
            return Plural.Other;
        case 'mk':
            if (v === 0 && i % 10 === 1 || f % 10 === 1)
                return Plural.One;
            return Plural.Other;
        case 'mt':
            if (n === 1)
                return Plural.One;
            if (n === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 2 && n % 100 <= 10)
                return Plural.Few;
            if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19)
                return Plural.Many;
            return Plural.Other;
        case 'pl':
            if (i === 1 && v === 0)
                return Plural.One;
            if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
                !(i % 100 >= 12 && i % 100 <= 14))
                return Plural.Few;
            if (v === 0 && !(i === 1) && i % 10 === Math.floor(i % 10) && i % 10 >= 0 && i % 10 <= 1 ||
                v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
                v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 12 && i % 100 <= 14)
                return Plural.Many;
            return Plural.Other;
        case 'pt':
            if (n === Math.floor(n) && n >= 0 && n <= 2 && !(n === 2))
                return Plural.One;
            return Plural.Other;
        case 'ro':
            if (i === 1 && v === 0)
                return Plural.One;
            if (!(v === 0) || n === 0 ||
                !(n === 1) && n % 100 === Math.floor(n % 100) && n % 100 >= 1 && n % 100 <= 19)
                return Plural.Few;
            return Plural.Other;
        case 'ru':
        case 'uk':
            if (v === 0 && i % 10 === 1 && !(i % 100 === 11))
                return Plural.One;
            if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
                !(i % 100 >= 12 && i % 100 <= 14))
                return Plural.Few;
            if (v === 0 && i % 10 === 0 ||
                v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
                v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 11 && i % 100 <= 14)
                return Plural.Many;
            return Plural.Other;
        case 'shi':
            if (i === 0 || n === 1)
                return Plural.One;
            if (n === Math.floor(n) && n >= 2 && n <= 10)
                return Plural.Few;
            return Plural.Other;
        case 'si':
            if (n === 0 || n === 1 || i === 0 && f === 1)
                return Plural.One;
            return Plural.Other;
        case 'sl':
            if (v === 0 && i % 100 === 1)
                return Plural.One;
            if (v === 0 && i % 100 === 2)
                return Plural.Two;
            if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 || !(v === 0))
                return Plural.Few;
            return Plural.Other;
        case 'tzm':
            if (n === Math.floor(n) && n >= 0 && n <= 1 || n === Math.floor(n) && n >= 11 && n <= 99)
                return Plural.One;
            return Plural.Other;
        default:
            return Plural.Other;
    }
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@ngModule CommonModule
 *
 * \@whatItDoes Adds and removes CSS classes on an HTML element.
 *
 * \@howToUse
 * ```
 *     <some-element [ngClass]="'first second'">...</some-element>
 *
 *     <some-element [ngClass]="['first', 'second']">...</some-element>
 *
 *     <some-element [ngClass]="{'first': true, 'second': true, 'third': false}">...</some-element>
 *
 *     <some-element [ngClass]="stringExp|arrayExp|objExp">...</some-element>
 *
 *     <some-element [ngClass]="{'class1 class2 class3' : true}">...</some-element>
 * ```
 *
 * \@description
 *
 * The CSS classes are updated as follows, depending on the type of the expression evaluation:
 * - `string` - the CSS classes listed in the string (space delimited) are added,
 * - `Array` - the CSS classes declared as Array elements are added,
 * - `Object` - keys are CSS classes that get added when the expression given in the value
 *              evaluates to a truthy value, otherwise they are removed.
 *
 * \@stable
 */
var NgClass = (function () {
    /**
     * @param {?} _iterableDiffers
     * @param {?} _keyValueDiffers
     * @param {?} _ngEl
     * @param {?} _renderer
     */
    function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
        this._iterableDiffers = _iterableDiffers;
        this._keyValueDiffers = _keyValueDiffers;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
        this._initialClasses = [];
    }
    Object.defineProperty(NgClass.prototype, "klass", {
        /**
         * @param {?} v
         * @return {?}
         */
        set: function (v) {
            this._applyInitialClasses(true);
            this._initialClasses = typeof v === 'string' ? v.split(/\s+/) : [];
            this._applyInitialClasses(false);
            this._applyClasses(this._rawClass, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgClass.prototype, "ngClass", {
        /**
         * @param {?} v
         * @return {?}
         */
        set: function (v) {
            this._cleanupClasses(this._rawClass);
            this._iterableDiffer = null;
            this._keyValueDiffer = null;
            this._rawClass = typeof v === 'string' ? v.split(/\s+/) : v;
            if (this._rawClass) {
                if (_angular_core.ɵisListLikeIterable(this._rawClass)) {
                    this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create();
                }
                else {
                    this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgClass.prototype.ngDoCheck = function () {
        if (this._iterableDiffer) {
            var /** @type {?} */ iterableChanges = this._iterableDiffer.diff(/** @type {?} */ (this._rawClass));
            if (iterableChanges) {
                this._applyIterableChanges(iterableChanges);
            }
        }
        else if (this._keyValueDiffer) {
            var /** @type {?} */ keyValueChanges = this._keyValueDiffer.diff(/** @type {?} */ (this._rawClass));
            if (keyValueChanges) {
                this._applyKeyValueChanges(keyValueChanges);
            }
        }
    };
    /**
     * @param {?} rawClassVal
     * @return {?}
     */
    NgClass.prototype._cleanupClasses = function (rawClassVal) {
        this._applyClasses(rawClassVal, true);
        this._applyInitialClasses(false);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    NgClass.prototype._applyKeyValueChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
        changes.forEachChangedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
        changes.forEachRemovedItem(function (record) {
            if (record.previousValue) {
                _this._toggleClass(record.key, false);
            }
        });
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    NgClass.prototype._applyIterableChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) {
            if (typeof record.item === 'string') {
                _this._toggleClass(record.item, true);
            }
            else {
                throw new Error("NgClass can only toggle CSS classes expressed as strings, got " + _angular_core.ɵstringify(record.item));
            }
        });
        changes.forEachRemovedItem(function (record) { return _this._toggleClass(record.item, false); });
    };
    /**
     * @param {?} isCleanup
     * @return {?}
     */
    NgClass.prototype._applyInitialClasses = function (isCleanup) {
        var _this = this;
        this._initialClasses.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
    };
    /**
     * @param {?} rawClassVal
     * @param {?} isCleanup
     * @return {?}
     */
    NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {
        var _this = this;
        if (rawClassVal) {
            if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
                ((rawClassVal)).forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
            }
            else {
                Object.keys(rawClassVal).forEach(function (klass) {
                    if (rawClassVal[klass] != null)
                        _this._toggleClass(klass, !isCleanup);
                });
            }
        }
    };
    /**
     * @param {?} klass
     * @param {?} enabled
     * @return {?}
     */
    NgClass.prototype._toggleClass = function (klass, enabled) {
        var _this = this;
        klass = klass.trim();
        if (klass) {
            klass.split(/\s+/g).forEach(function (klass) { _this._renderer.setElementClass(_this._ngEl.nativeElement, klass, !!enabled); });
        }
    };
NgClass.ɵfac = function NgClass_Factory(t) { return new (t || NgClass)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.KeyValueDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(_angular_core.Renderer)); };
NgClass.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgClass, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgClass, [{
        type: _angular_core.Directive,
        args: [{ selector: '[ngClass]' }]
    }], function () { return [{ type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.KeyValueDiffers }, { type: ɵngcc0.ElementRef }, { type: _angular_core.Renderer }]; }, { klass: [{
            type: _angular_core.Input,
            args: ['class']
        }], ngClass: [{
            type: _angular_core.Input
        }] }); })();
    return NgClass;
}());
/**
 * @nocollapse
 */
NgClass.ctorParameters = function () { return [
    { type: _angular_core.IterableDiffers, },
    { type: _angular_core.KeyValueDiffers, },
    { type: _angular_core.ElementRef, },
    { type: _angular_core.Renderer, },
]; };
NgClass.propDecorators = {
    'klass': [{ type: _angular_core.Input, args: ['class',] },],
    'ngClass': [{ type: _angular_core.Input },],
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Instantiates a single {\@link Component} type and inserts its Host View into current View.
 * `NgComponentOutlet` provides a declarative approach for dynamic component creation.
 *
 * `NgComponentOutlet` requires a component type, if a falsy value is set the view will clear and
 * any existing component will get destroyed.
 *
 * ### Fine tune control
 *
 * You can control the component creation process by using the following optional attributes:
 *
 * * `ngComponentOutletInjector`: Optional custom {\@link Injector} that will be used as parent for
 * the Component. Defaults to the injector of the current view container.
 *
 * * `ngComponentOutletContent`: Optional list of projectable nodes to insert into the content
 * section of the component, if exists.
 *
 * * `ngComponentOutletNgModuleFactory`: Optional module factory to allow dynamically loading other
 * module, then load a component from that module.
 *
 * ### Syntax
 *
 * Simple
 * ```
 * <ng-container *ngComponentOutlet="componentTypeExpression"></ng-container>
 * ```
 *
 * Customized injector/content
 * ```
 * <ng-container *ngComponentOutlet="componentTypeExpression;
 *                                   injector: injectorExpression;
 *                                   content: contentNodesExpression;">
 * </ng-container>
 * ```
 *
 * Customized ngModuleFactory
 * ```
 * <ng-container *ngComponentOutlet="componentTypeExpression;
 *                                   ngModuleFactory: moduleFactory;">
 * </ng-container>
 * ```
 * ## Example
 *
 * {\@example common/ngComponentOutlet/ts/module.ts region='SimpleExample'}
 *
 * A more complete example with additional options:
 *
 * {\@example common/ngComponentOutlet/ts/module.ts region='CompleteExample'}
 * A more complete example with ngModuleFactory:
 *
 * {\@example common/ngComponentOutlet/ts/module.ts region='NgModuleFactoryExample'}
 *
 * \@experimental
 */
var NgComponentOutlet = (function () {
    /**
     * @param {?} _viewContainerRef
     */
    function NgComponentOutlet(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
        this._componentRef = null;
        this._moduleRef = null;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NgComponentOutlet.prototype.ngOnChanges = function (changes) {
        this._viewContainerRef.clear();
        this._componentRef = null;
        if (this.ngComponentOutlet) {
            var /** @type {?} */ elInjector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
            if (changes['ngComponentOutletNgModuleFactory']) {
                if (this._moduleRef)
                    this._moduleRef.destroy();
                if (this.ngComponentOutletNgModuleFactory) {
                    var /** @type {?} */ parentModule = elInjector.get(_angular_core.NgModuleRef);
                    this._moduleRef = this.ngComponentOutletNgModuleFactory.create(parentModule.injector);
                }
                else {
                    this._moduleRef = null;
                }
            }
            var /** @type {?} */ componentFactoryResolver = this._moduleRef ? this._moduleRef.componentFactoryResolver :
                elInjector.get(_angular_core.ComponentFactoryResolver);
            var /** @type {?} */ componentFactory = componentFactoryResolver.resolveComponentFactory(this.ngComponentOutlet);
            this._componentRef = this._viewContainerRef.createComponent(componentFactory, this._viewContainerRef.length, elInjector, this.ngComponentOutletContent);
        }
    };
    /**
     * @return {?}
     */
    NgComponentOutlet.prototype.ngOnDestroy = function () {
        if (this._moduleRef)
            this._moduleRef.destroy();
    };
NgComponentOutlet.ɵfac = function NgComponentOutlet_Factory(t) { return new (t || NgComponentOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
NgComponentOutlet.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgComponentOutlet, selectors: [["", "ngComponentOutlet", ""]], inputs: { ngComponentOutlet: "ngComponentOutlet", ngComponentOutletInjector: "ngComponentOutletInjector", ngComponentOutletContent: "ngComponentOutletContent", ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgComponentOutlet, [{
        type: _angular_core.Directive,
        args: [{ selector: '[ngComponentOutlet]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { ngComponentOutlet: [{
            type: _angular_core.Input
        }], ngComponentOutletInjector: [{
            type: _angular_core.Input
        }], ngComponentOutletContent: [{
            type: _angular_core.Input
        }], ngComponentOutletNgModuleFactory: [{
            type: _angular_core.Input
        }] }); })();
    return NgComponentOutlet;
}());
/**
 * @nocollapse
 */
NgComponentOutlet.ctorParameters = function () { return [
    { type: _angular_core.ViewContainerRef, },
]; };
NgComponentOutlet.propDecorators = {
    'ngComponentOutlet': [{ type: _angular_core.Input },],
    'ngComponentOutletInjector': [{ type: _angular_core.Input },],
    'ngComponentOutletContent': [{ type: _angular_core.Input },],
    'ngComponentOutletNgModuleFactory': [{ type: _angular_core.Input },],
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@stable
 */
var NgForOfContext = (function () {
    /**
     * @param {?} $implicit
     * @param {?} ngForOf
     * @param {?} index
     * @param {?} count
     */
    function NgForOfContext($implicit, ngForOf, index, count) {
        this.$implicit = $implicit;
        this.ngForOf = ngForOf;
        this.index = index;
        this.count = count;
    }
    Object.defineProperty(NgForOfContext.prototype, "first", {
        /**
         * @return {?}
         */
        get: function () { return this.index === 0; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForOfContext.prototype, "last", {
        /**
         * @return {?}
         */
        get: function () { return this.index === this.count - 1; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForOfContext.prototype, "even", {
        /**
         * @return {?}
         */
        get: function () { return this.index % 2 === 0; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForOfContext.prototype, "odd", {
        /**
         * @return {?}
         */
        get: function () { return !this.even; },
        enumerable: true,
        configurable: true
    });
    return NgForOfContext;
}());
/**
 * The `NgForOf` directive instantiates a template once per item from an iterable. The context
 * for each instantiated template inherits from the outer context with the given loop variable
 * set to the current item from the iterable.
 *
 * ### Local Variables
 *
 * `NgForOf` provides several exported values that can be aliased to local variables:
 *
 * - `$implicit: T`: The value of the individual items in the iterable (`ngForOf`).
 * - `ngForOf: NgIterable<T>`: The value of the iterable expression. Useful when the expression is
 * more complex then a property access, for example when using the async pipe (`userStreams |
 * async`).
 * - `index: number`: The index of the current item in the iterable.
 * - `first: boolean`: True when the item is the first item in the iterable.
 * - `last: boolean`: True when the item is the last item in the iterable.
 * - `even: boolean`: True when the item has an even index in the iterable.
 * - `odd: boolean`: True when the item has an odd index in the iterable.
 *
 * ```
 * <li *ngFor="let user of userObservable | async as users; index as i; first as isFirst">
 *    {{i}}/{{users.length}}. {{user}} <span *ngIf="isFirst">default</span>
 * </li>
 * ```
 *
 * ### Change Propagation
 *
 * When the contents of the iterator changes, `NgForOf` makes the corresponding changes to the DOM:
 *
 * * When an item is added, a new instance of the template is added to the DOM.
 * * When an item is removed, its template instance is removed from the DOM.
 * * When items are reordered, their respective templates are reordered in the DOM.
 * * Otherwise, the DOM element for that item will remain the same.
 *
 * Angular uses object identity to track insertions and deletions within the iterator and reproduce
 * those changes in the DOM. This has important implications for animations and any stateful
 * controls (such as `<input>` elements which accept user input) that are present. Inserted rows can
 * be animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state
 * such as user input.
 *
 * It is possible for the identities of elements in the iterator to change while the data does not.
 * This can happen, for example, if the iterator produced from an RPC to the server, and that
 * RPC is re-run. Even if the data hasn't changed, the second response will produce objects with
 * different identities, and Angular will tear down the entire DOM and rebuild it (as if all old
 * elements were deleted and all new elements inserted). This is an expensive operation and should
 * be avoided if possible.
 *
 * To customize the default tracking algorithm, `NgForOf` supports `trackBy` option.
 * `trackBy` takes a function which has two arguments: `index` and `item`.
 * If `trackBy` is given, Angular tracks changes by the return value of the function.
 *
 * ### Syntax
 *
 * - `<li *ngFor="let item of items; index as i; trackBy: trackByFn">...</li>`
 * - `<li template="ngFor let item of items; index as i; trackBy: trackByFn">...</li>`
 *
 * With `<ng-template>` element:
 *
 * ```
 * <ng-template ngFor let-item [ngForOf]="items" let-i="index" [ngForTrackBy]="trackByFn">
 *   <li>...</li>
 * </ng-template>
 * ```
 *
 * ### Example
 *
 * See a [live demo](http://plnkr.co/edit/KVuXxDp0qinGDyo307QW?p=preview) for a more detailed
 * example.
 *
 * \@stable
 */
var NgForOf = (function () {
    /**
     * @param {?} _viewContainer
     * @param {?} _template
     * @param {?} _differs
     */
    function NgForOf(_viewContainer, _template, _differs) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this._differ = null;
    }
    Object.defineProperty(NgForOf.prototype, "ngForTrackBy", {
        /**
         * @return {?}
         */
        get: function () { return this._trackByFn; },
        /**
         * @param {?} fn
         * @return {?}
         */
        set: function (fn) {
            if (_angular_core.isDevMode() && fn != null && typeof fn !== 'function') {
                // TODO(vicb): use a log service once there is a public one available
                if ((console) && (console.warn)) {
                    console.warn("trackBy must be a function, but received " + JSON.stringify(fn) + ". " +
                        "See https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html#!#change-propagation for more information.");
                }
            }
            this._trackByFn = fn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForOf.prototype, "ngForTemplate", {
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            // TODO(TS2.1): make TemplateRef<Partial<NgForRowOf<T>>> once we move to TS v2.1
            // The current type is too restrictive; a template that just uses index, for example,
            // should be acceptable.
            if (value) {
                this._template = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    NgForOf.prototype.ngOnChanges = function (changes) {
        if ('ngForOf' in changes) {
            // React on ngForOf changes only once all inputs have been initialized
            var /** @type {?} */ value = changes['ngForOf'].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.ngForTrackBy);
                }
                catch (e) {
                    throw new Error("Cannot find a differ supporting object '" + value + "' of type '" + getTypeNameForDebugging(value) + "'. NgFor only supports binding to Iterables such as Arrays.");
                }
            }
        }
    };
    /**
     * @return {?}
     */
    NgForOf.prototype.ngDoCheck = function () {
        if (this._differ) {
            var /** @type {?} */ changes = this._differ.diff(this.ngForOf);
            if (changes)
                this._applyChanges(changes);
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    NgForOf.prototype._applyChanges = function (changes) {
        var _this = this;
        var /** @type {?} */ insertTuples = [];
        changes.forEachOperation(function (item, adjustedPreviousIndex, currentIndex) {
            if (item.previousIndex == null) {
                var /** @type {?} */ view = _this._viewContainer.createEmbeddedView(_this._template, new NgForOfContext(/** @type {?} */ ((null)), _this.ngForOf, -1, -1), currentIndex);
                var /** @type {?} */ tuple = new RecordViewTuple(item, view);
                insertTuples.push(tuple);
            }
            else if (currentIndex == null) {
                _this._viewContainer.remove(adjustedPreviousIndex);
            }
            else {
                var /** @type {?} */ view = ((_this._viewContainer.get(adjustedPreviousIndex)));
                _this._viewContainer.move(view, currentIndex);
                var /** @type {?} */ tuple = new RecordViewTuple(item, /** @type {?} */ (view));
                insertTuples.push(tuple);
            }
        });
        for (var /** @type {?} */ i = 0; i < insertTuples.length; i++) {
            this._perViewChange(insertTuples[i].view, insertTuples[i].record);
        }
        for (var /** @type {?} */ i = 0, /** @type {?} */ ilen = this._viewContainer.length; i < ilen; i++) {
            var /** @type {?} */ viewRef = (this._viewContainer.get(i));
            viewRef.context.index = i;
            viewRef.context.count = ilen;
        }
        changes.forEachIdentityChange(function (record) {
            var /** @type {?} */ viewRef = (_this._viewContainer.get(record.currentIndex));
            viewRef.context.$implicit = record.item;
        });
    };
    /**
     * @param {?} view
     * @param {?} record
     * @return {?}
     */
    NgForOf.prototype._perViewChange = function (view, record) {
        view.context.$implicit = record.item;
    };
NgForOf.ɵfac = function NgForOf_Factory(t) { return new (t || NgForOf)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers)); };
NgForOf.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgForOf, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate", ngForOf: "ngForOf" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgForOf, [{
        type: _angular_core.Directive,
        args: [{ selector: '[ngFor][ngForOf]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }]; }, { ngForTrackBy: [{
            type: _angular_core.Input
        }], ngForTemplate: [{
            type: _angular_core.Input
        }], ngForOf: [{
            type: _angular_core.Input
        }] }); })();
    return NgForOf;
}());
/**
 * @nocollapse
 */
NgForOf.ctorParameters = function () { return [
    { type: _angular_core.ViewContainerRef, },
    { type: _angular_core.TemplateRef, },
    { type: _angular_core.IterableDiffers, },
]; };
NgForOf.propDecorators = {
    'ngForOf': [{ type: _angular_core.Input },],
    'ngForTrackBy': [{ type: _angular_core.Input },],
    'ngForTemplate': [{ type: _angular_core.Input },],
};
var RecordViewTuple = (function () {
    /**
     * @param {?} record
     * @param {?} view
     */
    function RecordViewTuple(record, view) {
        this.record = record;
        this.view = view;
    }
    return RecordViewTuple;
}());
/**
 * @param {?} type
 * @return {?}
 */
function getTypeNameForDebugging(type) {
    return type['name'] || typeof type;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Conditionally includes a template based on the value of an `expression`.
 *
 * `ngIf` evaluates the `expression` and then renders the `then` or `else` template in its place
 * when expression is truthy or falsy respectively. Typically the:
 *  - `then` template is the inline template of `ngIf` unless bound to a different value.
 *  - `else` template is blank unless it is bound.
 *
 * ## Most common usage
 *
 * The most common usage of the `ngIf` directive is to conditionally show the inline template as
 * seen in this example:
 * {\@example common/ngIf/ts/module.ts region='NgIfSimple'}
 *
 * ## Showing an alternative template using `else`
 *
 * If it is necessary to display a template when the `expression` is falsy use the `else` template
 * binding as shown. Note that the `else` binding points to a `<ng-template>` labeled `#elseBlock`.
 * The template can be defined anywhere in the component view but is typically placed right after
 * `ngIf` for readability.
 *
 * {\@example common/ngIf/ts/module.ts region='NgIfElse'}
 *
 * ## Using non-inlined `then` template
 *
 * Usually the `then` template is the inlined template of the `ngIf`, but it can be changed using
 * a binding (just like `else`). Because `then` and `else` are bindings, the template references can
 * change at runtime as shown in this example.
 *
 * {\@example common/ngIf/ts/module.ts region='NgIfThenElse'}
 *
 * ## Storing conditional result in a variable
 *
 * A common pattern is that we need to show a set of properties from the same object. If the
 * object is undefined, then we have to use the safe-traversal-operator `?.` to guard against
 * dereferencing a `null` value. This is especially the case when waiting on async data such as
 * when using the `async` pipe as shown in folowing example:
 *
 * ```
 * Hello {{ (userStream|async)?.last }}, {{ (userStream|async)?.first }}!
 * ```
 *
 * There are several inefficiencies in the above example:
 *  - We create multiple subscriptions on `userStream`. One for each `async` pipe, or two in the
 *    example above.
 *  - We cannot display an alternative screen while waiting for the data to arrive asynchronously.
 *  - We have to use the safe-traversal-operator `?.` to access properties, which is cumbersome.
 *  - We have to place the `async` pipe in parenthesis.
 *
 * A better way to do this is to use `ngIf` and store the result of the condition in a local
 * variable as shown in the the example below:
 *
 * {\@example common/ngIf/ts/module.ts region='NgIfAs'}
 *
 * Notice that:
 *  - We use only one `async` pipe and hence only one subscription gets created.
 *  - `ngIf` stores the result of the `userStream|async` in the local variable `user`.
 *  - The local `user` can then be bound repeatedly in a more efficient way.
 *  - No need to use the safe-traversal-operator `?.` to access properties as `ngIf` will only
 *    display the data if `userStream` returns a value.
 *  - We can display an alternative template while waiting for the data.
 *
 * ### Syntax
 *
 * Simple form:
 * - `<div *ngIf="condition">...</div>`
 * - `<div template="ngIf condition">...</div>`
 * - `<ng-template [ngIf]="condition"><div>...</div></ng-template>`
 *
 * Form with an else block:
 * ```
 * <div *ngIf="condition; else elseBlock">...</div>
 * <ng-template #elseBlock>...</ng-template>
 * ```
 *
 * Form with a `then` and `else` block:
 * ```
 * <div *ngIf="condition; then thenBlock else elseBlock"></div>
 * <ng-template #thenBlock>...</ng-template>
 * <ng-template #elseBlock>...</ng-template>
 * ```
 *
 * Form with storing the value locally:
 * ```
 * <div *ngIf="condition as value; else elseBlock">{{value}}</div>
 * <ng-template #elseBlock>...</ng-template>
 * ```
 *
 * \@stable
 */
var NgIf = (function () {
    /**
     * @param {?} _viewContainer
     * @param {?} templateRef
     */
    function NgIf(_viewContainer, templateRef) {
        this._viewContainer = _viewContainer;
        this._context = new NgIfContext();
        this._thenTemplateRef = null;
        this._elseTemplateRef = null;
        this._thenViewRef = null;
        this._elseViewRef = null;
        this._thenTemplateRef = templateRef;
    }
    Object.defineProperty(NgIf.prototype, "ngIf", {
        /**
         * @param {?} condition
         * @return {?}
         */
        set: function (condition) {
            this._context.$implicit = this._context.ngIf = condition;
            this._updateView();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgIf.prototype, "ngIfThen", {
        /**
         * @param {?} templateRef
         * @return {?}
         */
        set: function (templateRef) {
            this._thenTemplateRef = templateRef;
            this._thenViewRef = null; // clear previous view if any.
            this._updateView();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgIf.prototype, "ngIfElse", {
        /**
         * @param {?} templateRef
         * @return {?}
         */
        set: function (templateRef) {
            this._elseTemplateRef = templateRef;
            this._elseViewRef = null; // clear previous view if any.
            this._updateView();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgIf.prototype._updateView = function () {
        if (this._context.$implicit) {
            if (!this._thenViewRef) {
                this._viewContainer.clear();
                this._elseViewRef = null;
                if (this._thenTemplateRef) {
                    this._thenViewRef =
                        this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
                }
            }
        }
        else {
            if (!this._elseViewRef) {
                this._viewContainer.clear();
                this._thenViewRef = null;
                if (this._elseTemplateRef) {
                    this._elseViewRef =
                        this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
                }
            }
        }
    };
NgIf.ɵfac = function NgIf_Factory(t) { return new (t || NgIf)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NgIf.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgIf, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgIf, [{
        type: _angular_core.Directive,
        args: [{ selector: '[ngIf]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }]; }, { ngIf: [{
            type: _angular_core.Input
        }], ngIfThen: [{
            type: _angular_core.Input
        }], ngIfElse: [{
            type: _angular_core.Input
        }] }); })();
    return NgIf;
}());
/**
 * @nocollapse
 */
NgIf.ctorParameters = function () { return [
    { type: _angular_core.ViewContainerRef, },
    { type: _angular_core.TemplateRef, },
]; };
NgIf.propDecorators = {
    'ngIf': [{ type: _angular_core.Input },],
    'ngIfThen': [{ type: _angular_core.Input },],
    'ngIfElse': [{ type: _angular_core.Input },],
};
/**
 * \@stable
 */
var NgIfContext = (function () {
    function NgIfContext() {
        this.$implicit = null;
        this.ngIf = null;
    }
    return NgIfContext;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var SwitchView = (function () {
    /**
     * @param {?} _viewContainerRef
     * @param {?} _templateRef
     */
    function SwitchView(_viewContainerRef, _templateRef) {
        this._viewContainerRef = _viewContainerRef;
        this._templateRef = _templateRef;
        this._created = false;
    }
    /**
     * @return {?}
     */
    SwitchView.prototype.create = function () {
        this._created = true;
        this._viewContainerRef.createEmbeddedView(this._templateRef);
    };
    /**
     * @return {?}
     */
    SwitchView.prototype.destroy = function () {
        this._created = false;
        this._viewContainerRef.clear();
    };
    /**
     * @param {?} created
     * @return {?}
     */
    SwitchView.prototype.enforceState = function (created) {
        if (created && !this._created) {
            this.create();
        }
        else if (!created && this._created) {
            this.destroy();
        }
    };
    return SwitchView;
}());
/**
 * \@ngModule CommonModule
 *
 * \@whatItDoes Adds / removes DOM sub-trees when the nest match expressions matches the switch
 *             expression.
 *
 * \@howToUse
 * ```
 *     <container-element [ngSwitch]="switch_expression">
 *       <some-element *ngSwitchCase="match_expression_1">...</some-element>
 *       <some-element *ngSwitchCase="match_expression_2">...</some-element>
 *       <some-other-element *ngSwitchCase="match_expression_3">...</some-other-element>
 *       <ng-container *ngSwitchCase="match_expression_3">
 *         <!-- use a ng-container to group multiple root nodes -->
 *         <inner-element></inner-element>
 *         <inner-other-element></inner-other-element>
 *       </ng-container>
 *       <some-element *ngSwitchDefault>...</some-element>
 *     </container-element>
 * ```
 * \@description
 *
 * `NgSwitch` stamps out nested views when their match expression value matches the value of the
 * switch expression.
 *
 * In other words:
 * - you define a container element (where you place the directive with a switch expression on the
 * `[ngSwitch]="..."` attribute)
 * - you define inner views inside the `NgSwitch` and place a `*ngSwitchCase` attribute on the view
 * root elements.
 *
 * Elements within `NgSwitch` but outside of a `NgSwitchCase` or `NgSwitchDefault` directives will
 * be preserved at the location.
 *
 * The `ngSwitchCase` directive informs the parent `NgSwitch` of which view to display when the
 * expression is evaluated.
 * When no matching expression is found on a `ngSwitchCase` view, the `ngSwitchDefault` view is
 * stamped out.
 *
 * \@stable
 */
var NgSwitch = (function () {
    function NgSwitch() {
        this._defaultUsed = false;
        this._caseCount = 0;
        this._lastCaseCheckIndex = 0;
        this._lastCasesMatched = false;
    }
    Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
        /**
         * @param {?} newValue
         * @return {?}
         */
        set: function (newValue) {
            this._ngSwitch = newValue;
            if (this._caseCount === 0) {
                this._updateDefaultCases(true);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * \@internal
     * @return {?}
     */
    NgSwitch.prototype._addCase = function () { return this._caseCount++; };
    /**
     * \@internal
     * @param {?} view
     * @return {?}
     */
    NgSwitch.prototype._addDefault = function (view) {
        if (!this._defaultViews) {
            this._defaultViews = [];
        }
        this._defaultViews.push(view);
    };
    /**
     * \@internal
     * @param {?} value
     * @return {?}
     */
    NgSwitch.prototype._matchCase = function (value) {
        var /** @type {?} */ matched = value == this._ngSwitch;
        this._lastCasesMatched = this._lastCasesMatched || matched;
        this._lastCaseCheckIndex++;
        if (this._lastCaseCheckIndex === this._caseCount) {
            this._updateDefaultCases(!this._lastCasesMatched);
            this._lastCaseCheckIndex = 0;
            this._lastCasesMatched = false;
        }
        return matched;
    };
    /**
     * @param {?} useDefault
     * @return {?}
     */
    NgSwitch.prototype._updateDefaultCases = function (useDefault) {
        if (this._defaultViews && useDefault !== this._defaultUsed) {
            this._defaultUsed = useDefault;
            for (var /** @type {?} */ i = 0; i < this._defaultViews.length; i++) {
                var /** @type {?} */ defaultView = this._defaultViews[i];
                defaultView.enforceState(useDefault);
            }
        }
    };
NgSwitch.ɵfac = function NgSwitch_Factory(t) { return new (t || NgSwitch)(); };
NgSwitch.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgSwitch, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgSwitch, [{
        type: _angular_core.Directive,
        args: [{ selector: '[ngSwitch]' }]
    }], function () { return []; }, { ngSwitch: [{
            type: _angular_core.Input
        }] }); })();
    return NgSwitch;
}());
/**
 * @nocollapse
 */
NgSwitch.ctorParameters = function () { return []; };
NgSwitch.propDecorators = {
    'ngSwitch': [{ type: _angular_core.Input },],
};
/**
 * \@ngModule CommonModule
 *
 * \@whatItDoes Creates a view that will be added/removed from the parent {\@link NgSwitch} when the
 *             given expression evaluate to respectively the same/different value as the switch
 *             expression.
 *
 * \@howToUse
 * ```
 * <container-element [ngSwitch]="switch_expression">
 *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
 * </container-element>
 * ```
 * \@description
 *
 * Insert the sub-tree when the expression evaluates to the same value as the enclosing switch
 * expression.
 *
 * If multiple match expressions match the switch expression value, all of them are displayed.
 *
 * See {\@link NgSwitch} for more details and example.
 *
 * \@stable
 */
var NgSwitchCase = (function () {
    /**
     * @param {?} viewContainer
     * @param {?} templateRef
     * @param {?} ngSwitch
     */
    function NgSwitchCase(viewContainer, templateRef, ngSwitch) {
        this.ngSwitch = ngSwitch;
        ngSwitch._addCase();
        this._view = new SwitchView(viewContainer, templateRef);
    }
    /**
     * @return {?}
     */
    NgSwitchCase.prototype.ngDoCheck = function () { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)); };
NgSwitchCase.ɵfac = function NgSwitchCase_Factory(t) { return new (t || NgSwitchCase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(NgSwitch, 1)); };
NgSwitchCase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgSwitchCase, selectors: [["", "ngSwitchCase", ""]], inputs: { ngSwitchCase: "ngSwitchCase" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgSwitchCase, [{
        type: _angular_core.Directive,
        args: [{ selector: '[ngSwitchCase]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }, { type: NgSwitch, decorators: [{
                type: _angular_core.Host
            }] }]; }, { ngSwitchCase: [{
            type: _angular_core.Input
        }] }); })();
    return NgSwitchCase;
}());
/**
 * @nocollapse
 */
NgSwitchCase.ctorParameters = function () { return [
    { type: _angular_core.ViewContainerRef, },
    { type: _angular_core.TemplateRef, },
    { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
]; };
NgSwitchCase.propDecorators = {
    'ngSwitchCase': [{ type: _angular_core.Input },],
};
/**
 * \@ngModule CommonModule
 * \@whatItDoes Creates a view that is added to the parent {\@link NgSwitch} when no case expressions
 * match the
 *             switch expression.
 *
 * \@howToUse
 * ```
 * <container-element [ngSwitch]="switch_expression">
 *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
 *   <some-other-element *ngSwitchDefault>...</some-other-element>
 * </container-element>
 * ```
 *
 * \@description
 *
 * Insert the sub-tree when no case expressions evaluate to the same value as the enclosing switch
 * expression.
 *
 * See {\@link NgSwitch} for more details and example.
 *
 * \@stable
 */
var NgSwitchDefault = (function () {
    /**
     * @param {?} viewContainer
     * @param {?} templateRef
     * @param {?} ngSwitch
     */
    function NgSwitchDefault(viewContainer, templateRef, ngSwitch) {
        ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
    }
NgSwitchDefault.ɵfac = function NgSwitchDefault_Factory(t) { return new (t || NgSwitchDefault)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(NgSwitch, 1)); };
NgSwitchDefault.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgSwitchDefault, selectors: [["", "ngSwitchDefault", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgSwitchDefault, [{
        type: _angular_core.Directive,
        args: [{ selector: '[ngSwitchDefault]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }, { type: NgSwitch, decorators: [{
                type: _angular_core.Host
            }] }]; }, null); })();
    return NgSwitchDefault;
}());
/**
 * @nocollapse
 */
NgSwitchDefault.ctorParameters = function () { return [
    { type: _angular_core.ViewContainerRef, },
    { type: _angular_core.TemplateRef, },
    { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@ngModule CommonModule
 *
 * \@whatItDoes Adds / removes DOM sub-trees based on a numeric value. Tailored for pluralization.
 *
 * \@howToUse
 * ```
 * <some-element [ngPlural]="value">
 *   <ng-template ngPluralCase="=0">there is nothing</ng-template>
 *   <ng-template ngPluralCase="=1">there is one</ng-template>
 *   <ng-template ngPluralCase="few">there are a few</ng-template>
 * </some-element>
 * ```
 *
 * \@description
 *
 * Displays DOM sub-trees that match the switch expression value, or failing that, DOM sub-trees
 * that match the switch expression's pluralization category.
 *
 * To use this directive you must provide a container element that sets the `[ngPlural]` attribute
 * to a switch expression. Inner elements with a `[ngPluralCase]` will display based on their
 * expression:
 * - if `[ngPluralCase]` is set to a value starting with `=`, it will only display if the value
 *   matches the switch expression exactly,
 * - otherwise, the view will be treated as a "category match", and will only display if exact
 *   value matches aren't found and the value maps to its category for the defined locale.
 *
 * See http://cldr.unicode.org/index/cldr-spec/plural-rules
 *
 * \@experimental
 */
var NgPlural = (function () {
    /**
     * @param {?} _localization
     */
    function NgPlural(_localization) {
        this._localization = _localization;
        this._caseViews = {};
    }
    Object.defineProperty(NgPlural.prototype, "ngPlural", {
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._switchValue = value;
            this._updateView();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?} switchView
     * @return {?}
     */
    NgPlural.prototype.addCase = function (value, switchView) { this._caseViews[value] = switchView; };
    /**
     * @return {?}
     */
    NgPlural.prototype._updateView = function () {
        this._clearViews();
        var /** @type {?} */ cases = Object.keys(this._caseViews);
        var /** @type {?} */ key = getPluralCategory(this._switchValue, cases, this._localization);
        this._activateView(this._caseViews[key]);
    };
    /**
     * @return {?}
     */
    NgPlural.prototype._clearViews = function () {
        if (this._activeView)
            this._activeView.destroy();
    };
    /**
     * @param {?} view
     * @return {?}
     */
    NgPlural.prototype._activateView = function (view) {
        if (view) {
            this._activeView = view;
            this._activeView.create();
        }
    };
NgPlural.ɵfac = function NgPlural_Factory(t) { return new (t || NgPlural)(ɵngcc0.ɵɵdirectiveInject(NgLocalization)); };
NgPlural.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgPlural, selectors: [["", "ngPlural", ""]], inputs: { ngPlural: "ngPlural" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgPlural, [{
        type: _angular_core.Directive,
        args: [{ selector: '[ngPlural]' }]
    }], function () { return [{ type: NgLocalization }]; }, { ngPlural: [{
            type: _angular_core.Input
        }] }); })();
    return NgPlural;
}());
/**
 * @nocollapse
 */
NgPlural.ctorParameters = function () { return [
    { type: NgLocalization, },
]; };
NgPlural.propDecorators = {
    'ngPlural': [{ type: _angular_core.Input },],
};
/**
 * \@ngModule CommonModule
 *
 * \@whatItDoes Creates a view that will be added/removed from the parent {\@link NgPlural} when the
 *             given expression matches the plural expression according to CLDR rules.
 *
 * \@howToUse
 * ```
 * <some-element [ngPlural]="value">
 *   <ng-template ngPluralCase="=0">...</ng-template>
 *   <ng-template ngPluralCase="other">...</ng-template>
 * </some-element>
 * ```
 *
 * See {\@link NgPlural} for more details and example.
 *
 * \@experimental
 */
var NgPluralCase = (function () {
    /**
     * @param {?} value
     * @param {?} template
     * @param {?} viewContainer
     * @param {?} ngPlural
     */
    function NgPluralCase(value, template, viewContainer, ngPlural) {
        this.value = value;
        var isANumber = !isNaN(Number(value));
        ngPlural.addCase(isANumber ? "=" + value : value, new SwitchView(viewContainer, template));
    }
NgPluralCase.ɵfac = function NgPluralCase_Factory(t) { return new (t || NgPluralCase)(ɵngcc0.ɵɵinjectAttribute('ngPluralCase'), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(NgPlural, 1)); };
NgPluralCase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgPluralCase, selectors: [["", "ngPluralCase", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgPluralCase, [{
        type: _angular_core.Directive,
        args: [{ selector: '[ngPluralCase]' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: _angular_core.Attribute,
                args: ['ngPluralCase']
            }] }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }, { type: NgPlural, decorators: [{
                type: _angular_core.Host
            }] }]; }, null); })();
    return NgPluralCase;
}());
/**
 * @nocollapse
 */
NgPluralCase.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['ngPluralCase',] },] },
    { type: _angular_core.TemplateRef, },
    { type: _angular_core.ViewContainerRef, },
    { type: NgPlural, decorators: [{ type: _angular_core.Host },] },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@ngModule CommonModule
 *
 * \@whatItDoes Update an HTML element styles.
 *
 * \@howToUse
 * ```
 * <some-element [ngStyle]="{'font-style': styleExp}">...</some-element>
 *
 * <some-element [ngStyle]="{'max-width.px': widthExp}">...</some-element>
 *
 * <some-element [ngStyle]="objExp">...</some-element>
 * ```
 *
 * \@description
 *
 * The styles are updated according to the value of the expression evaluation:
 * - keys are style names with an optional `.<unit>` suffix (ie 'top.px', 'font-style.em'),
 * - values are the values assigned to those properties (expressed in the given unit).
 *
 * \@stable
 */
var NgStyle = (function () {
    /**
     * @param {?} _differs
     * @param {?} _ngEl
     * @param {?} _renderer
     */
    function NgStyle(_differs, _ngEl, _renderer) {
        this._differs = _differs;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
    }
    Object.defineProperty(NgStyle.prototype, "ngStyle", {
        /**
         * @param {?} v
         * @return {?}
         */
        set: function (v) {
            this._ngStyle = v;
            if (!this._differ && v) {
                this._differ = this._differs.find(v).create();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgStyle.prototype.ngDoCheck = function () {
        if (this._differ) {
            var /** @type {?} */ changes = this._differ.diff(this._ngStyle);
            if (changes) {
                this._applyChanges(changes);
            }
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    NgStyle.prototype._applyChanges = function (changes) {
        var _this = this;
        changes.forEachRemovedItem(function (record) { return _this._setStyle(record.key, null); });
        changes.forEachAddedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
        changes.forEachChangedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
    };
    /**
     * @param {?} nameAndUnit
     * @param {?} value
     * @return {?}
     */
    NgStyle.prototype._setStyle = function (nameAndUnit, value) {
        var _a = nameAndUnit.split('.'), name = _a[0], unit = _a[1];
        value = value != null && unit ? "" + value + unit : value;
        this._renderer.setElementStyle(this._ngEl.nativeElement, name, /** @type {?} */ (value));
    };
NgStyle.ɵfac = function NgStyle_Factory(t) { return new (t || NgStyle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.KeyValueDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(_angular_core.Renderer)); };
NgStyle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgStyle, selectors: [["", "ngStyle", ""]], inputs: { ngStyle: "ngStyle" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgStyle, [{
        type: _angular_core.Directive,
        args: [{ selector: '[ngStyle]' }]
    }], function () { return [{ type: ɵngcc0.KeyValueDiffers }, { type: ɵngcc0.ElementRef }, { type: _angular_core.Renderer }]; }, { ngStyle: [{
            type: _angular_core.Input
        }] }); })();
    return NgStyle;
}());
/**
 * @nocollapse
 */
NgStyle.ctorParameters = function () { return [
    { type: _angular_core.KeyValueDiffers, },
    { type: _angular_core.ElementRef, },
    { type: _angular_core.Renderer, },
]; };
NgStyle.propDecorators = {
    'ngStyle': [{ type: _angular_core.Input },],
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@ngModule CommonModule
 *
 * \@whatItDoes Inserts an embedded view from a prepared `TemplateRef`
 *
 * \@howToUse
 * ```
 * <ng-container *ngTemplateOutlet="templateRefExp; context: contextExp"></ng-container>
 * ```
 *
 * \@description
 *
 * You can attach a context object to the `EmbeddedViewRef` by setting `[ngTemplateOutletContext]`.
 * `[ngTemplateOutletContext]` should be an object, the object's keys will be available for binding
 * by the local template `let` declarations.
 *
 * Note: using the key `$implicit` in the context object will set it's value as default.
 *
 * ## Example
 *
 * {\@example common/ngTemplateOutlet/ts/module.ts region='NgTemplateOutlet'}
 *
 * \@experimental
 */
var NgTemplateOutlet = (function () {
    /**
     * @param {?} _viewContainerRef
     */
    function NgTemplateOutlet(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
    }
    Object.defineProperty(NgTemplateOutlet.prototype, "ngOutletContext", {
        /**
         * @deprecated v4.0.0 - Renamed to ngTemplateOutletContext.
         * @param {?} context
         * @return {?}
         */
        set: function (context) { this.ngTemplateOutletContext = context; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    NgTemplateOutlet.prototype.ngOnChanges = function (changes) {
        if (this._viewRef) {
            this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
        }
        if (this.ngTemplateOutlet) {
            this._viewRef = this._viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, this.ngTemplateOutletContext);
        }
    };
NgTemplateOutlet.ɵfac = function NgTemplateOutlet_Factory(t) { return new (t || NgTemplateOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
NgTemplateOutlet.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgTemplateOutlet, selectors: [["", "ngTemplateOutlet", ""]], inputs: { ngOutletContext: "ngOutletContext", ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgTemplateOutlet, [{
        type: _angular_core.Directive,
        args: [{ selector: '[ngTemplateOutlet]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { ngOutletContext: [{
            type: _angular_core.Input
        }], ngTemplateOutletContext: [{
            type: _angular_core.Input
        }], ngTemplateOutlet: [{
            type: _angular_core.Input
        }] }); })();
    return NgTemplateOutlet;
}());
/**
 * @nocollapse
 */
NgTemplateOutlet.ctorParameters = function () { return [
    { type: _angular_core.ViewContainerRef, },
]; };
NgTemplateOutlet.propDecorators = {
    'ngTemplateOutletContext': [{ type: _angular_core.Input },],
    'ngTemplateOutlet': [{ type: _angular_core.Input },],
    'ngOutletContext': [{ type: _angular_core.Input },],
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A collection of Angular directives that are likely to be used in each and every Angular
 * application.
 */
var COMMON_DIRECTIVES = [
    NgClass,
    NgComponentOutlet,
    NgForOf,
    NgIf,
    NgTemplateOutlet,
    NgStyle,
    NgSwitch,
    NgSwitchCase,
    NgSwitchDefault,
    NgPlural,
    NgPluralCase,
];
/**
 * A collection of deprecated directives that are no longer part of the core module.
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} type
 * @param {?} value
 * @return {?}
 */
function invalidPipeArgumentError(type, value) {
    return Error("InvalidPipeArgument: '" + value + "' for pipe '" + _angular_core.ɵstringify(type) + "'");
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ObservableStrategy = (function () {
    function ObservableStrategy() {
    }
    /**
     * @param {?} async
     * @param {?} updateLatestValue
     * @return {?}
     */
    ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
        return async.subscribe({ next: updateLatestValue, error: function (e) { throw e; } });
    };
    /**
     * @param {?} subscription
     * @return {?}
     */
    ObservableStrategy.prototype.dispose = function (subscription) { subscription.unsubscribe(); };
    /**
     * @param {?} subscription
     * @return {?}
     */
    ObservableStrategy.prototype.onDestroy = function (subscription) { subscription.unsubscribe(); };
    return ObservableStrategy;
}());
var PromiseStrategy = (function () {
    function PromiseStrategy() {
    }
    /**
     * @param {?} async
     * @param {?} updateLatestValue
     * @return {?}
     */
    PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
        return async.then(updateLatestValue, function (e) { throw e; });
    };
    /**
     * @param {?} subscription
     * @return {?}
     */
    PromiseStrategy.prototype.dispose = function (subscription) { };
    /**
     * @param {?} subscription
     * @return {?}
     */
    PromiseStrategy.prototype.onDestroy = function (subscription) { };
    return PromiseStrategy;
}());
var _promiseStrategy = new PromiseStrategy();
var _observableStrategy = new ObservableStrategy();
/**
 * \@ngModule CommonModule
 * \@whatItDoes Unwraps a value from an asynchronous primitive.
 * \@howToUse `observable_or_promise_expression | async`
 * \@description
 * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has
 * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for
 * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid
 * potential memory leaks.
 *
 *
 * ## Examples
 *
 * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the
 * promise.
 *
 * {\@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}
 *
 * It's also possible to use `async` with Observables. The example below binds the `time` Observable
 * to the view. The Observable continuously updates the view with the current time.
 *
 * {\@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}
 *
 * \@stable
 */
var AsyncPipe = (function () {
    /**
     * @param {?} _ref
     */
    function AsyncPipe(_ref) {
        this._ref = _ref;
        this._latestValue = null;
        this._latestReturnedValue = null;
        this._subscription = null;
        this._obj = null;
        this._strategy = ((null));
    }
    /**
     * @return {?}
     */
    AsyncPipe.prototype.ngOnDestroy = function () {
        if (this._subscription) {
            this._dispose();
        }
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    AsyncPipe.prototype.transform = function (obj) {
        if (!this._obj) {
            if (obj) {
                this._subscribe(obj);
            }
            this._latestReturnedValue = this._latestValue;
            return this._latestValue;
        }
        if (obj !== this._obj) {
            this._dispose();
            return this.transform(/** @type {?} */ (obj));
        }
        if (this._latestValue === this._latestReturnedValue) {
            return this._latestReturnedValue;
        }
        this._latestReturnedValue = this._latestValue;
        return _angular_core.WrappedValue.wrap(this._latestValue);
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    AsyncPipe.prototype._subscribe = function (obj) {
        var _this = this;
        this._obj = obj;
        this._strategy = this._selectStrategy(obj);
        this._subscription = this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    AsyncPipe.prototype._selectStrategy = function (obj) {
        if (_angular_core.ɵisPromise(obj)) {
            return _promiseStrategy;
        }
        if (_angular_core.ɵisObservable(obj)) {
            return _observableStrategy;
        }
        throw invalidPipeArgumentError(AsyncPipe, obj);
    };
    /**
     * @return {?}
     */
    AsyncPipe.prototype._dispose = function () {
        this._strategy.dispose(/** @type {?} */ ((this._subscription)));
        this._latestValue = null;
        this._latestReturnedValue = null;
        this._subscription = null;
        this._obj = null;
    };
    /**
     * @param {?} async
     * @param {?} value
     * @return {?}
     */
    AsyncPipe.prototype._updateLatestValue = function (async, value) {
        if (async === this._obj) {
            this._latestValue = value;
            this._ref.markForCheck();
        }
    };
AsyncPipe.ɵfac = function AsyncPipe_Factory(t) { return new (t || AsyncPipe)(ɵngcc0.ɵɵinjectPipeChangeDetectorRef()); };
AsyncPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "async", type: AsyncPipe, pure: false });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AsyncPipe, [{
        type: _angular_core.Pipe,
        args: [{ name: 'async', pure: false }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
    return AsyncPipe;
}());
/**
 * @nocollapse
 */
AsyncPipe.ctorParameters = function () { return [
    { type: _angular_core.ChangeDetectorRef, },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Transforms text to lowercase.
 *
 * {\@example  common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe' }
 *
 * \@stable
 */
var LowerCasePipe = (function () {
    function LowerCasePipe() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    LowerCasePipe.prototype.transform = function (value) {
        if (!value)
            return value;
        if (typeof value !== 'string') {
            throw invalidPipeArgumentError(LowerCasePipe, value);
        }
        return value.toLowerCase();
    };
LowerCasePipe.ɵfac = function LowerCasePipe_Factory(t) { return new (t || LowerCasePipe)(); };
LowerCasePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "lowercase", type: LowerCasePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LowerCasePipe, [{
        type: _angular_core.Pipe,
        args: [{ name: 'lowercase' }]
    }], function () { return []; }, null); })();
    return LowerCasePipe;
}());
/**
 * @nocollapse
 */
LowerCasePipe.ctorParameters = function () { return []; };
/**
 * Helper method to transform a single word to titlecase.
 *
 * \@stable
 * @param {?} word
 * @return {?}
 */
function titleCaseWord(word) {
    if (!word)
        return word;
    return word[0].toUpperCase() + word.substr(1).toLowerCase();
}
/**
 * Transforms text to titlecase.
 *
 * \@stable
 */
var TitleCasePipe = (function () {
    function TitleCasePipe() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    TitleCasePipe.prototype.transform = function (value) {
        if (!value)
            return value;
        if (typeof value !== 'string') {
            throw invalidPipeArgumentError(TitleCasePipe, value);
        }
        return value.split(/\b/g).map(function (word) { return titleCaseWord(word); }).join('');
    };
TitleCasePipe.ɵfac = function TitleCasePipe_Factory(t) { return new (t || TitleCasePipe)(); };
TitleCasePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "titlecase", type: TitleCasePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TitleCasePipe, [{
        type: _angular_core.Pipe,
        args: [{ name: 'titlecase' }]
    }], function () { return []; }, null); })();
    return TitleCasePipe;
}());
/**
 * @nocollapse
 */
TitleCasePipe.ctorParameters = function () { return []; };
/**
 * Transforms text to uppercase.
 *
 * \@stable
 */
var UpperCasePipe = (function () {
    function UpperCasePipe() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    UpperCasePipe.prototype.transform = function (value) {
        if (!value)
            return value;
        if (typeof value !== 'string') {
            throw invalidPipeArgumentError(UpperCasePipe, value);
        }
        return value.toUpperCase();
    };
UpperCasePipe.ɵfac = function UpperCasePipe_Factory(t) { return new (t || UpperCasePipe)(); };
UpperCasePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "uppercase", type: UpperCasePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UpperCasePipe, [{
        type: _angular_core.Pipe,
        args: [{ name: 'uppercase' }]
    }], function () { return []; }, null); })();
    return UpperCasePipe;
}());
/**
 * @nocollapse
 */
UpperCasePipe.ctorParameters = function () { return []; };
var NumberFormatStyle = {};
NumberFormatStyle.Decimal = 0;
NumberFormatStyle.Percent = 1;
NumberFormatStyle.Currency = 2;
NumberFormatStyle[NumberFormatStyle.Decimal] = "Decimal";
NumberFormatStyle[NumberFormatStyle.Percent] = "Percent";
NumberFormatStyle[NumberFormatStyle.Currency] = "Currency";
var NumberFormatter = (function () {
    function NumberFormatter() {
    }
    /**
     * @param {?} num
     * @param {?} locale
     * @param {?} style
     * @param {?=} __3
     * @return {?}
     */
    NumberFormatter.format = function (num, locale, style, _a) {
        var _b = _a === void 0 ? {} : _a, minimumIntegerDigits = _b.minimumIntegerDigits, minimumFractionDigits = _b.minimumFractionDigits, maximumFractionDigits = _b.maximumFractionDigits, currency = _b.currency, _c = _b.currencyAsSymbol, currencyAsSymbol = _c === void 0 ? false : _c;
        var /** @type {?} */ options = {
            minimumIntegerDigits: minimumIntegerDigits,
            minimumFractionDigits: minimumFractionDigits,
            maximumFractionDigits: maximumFractionDigits,
            style: NumberFormatStyle[style].toLowerCase()
        };
        if (style == NumberFormatStyle.Currency) {
            options.currency = typeof currency == 'string' ? currency : undefined;
            options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
        }
        return new Intl.NumberFormat(locale, options).format(num);
    };
    return NumberFormatter;
}());
var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;
var PATTERN_ALIASES = {
    // Keys are quoted so they do not get renamed during closure compilation.
    'yMMMdjms': datePartGetterFactory(combine([
        digitCondition('year', 1),
        nameCondition('month', 3),
        digitCondition('day', 1),
        digitCondition('hour', 1),
        digitCondition('minute', 1),
        digitCondition('second', 1),
    ])),
    'yMdjm': datePartGetterFactory(combine([
        digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),
        digitCondition('hour', 1), digitCondition('minute', 1)
    ])),
    'yMMMMEEEEd': datePartGetterFactory(combine([
        digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),
        digitCondition('day', 1)
    ])),
    'yMMMMd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
    'yMMMd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
    'yMd': datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
    'jms': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
    'jm': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
};
var DATE_FORMATS = {
    // Keys are quoted so they do not get renamed.
    'yyyy': datePartGetterFactory(digitCondition('year', 4)),
    'yy': datePartGetterFactory(digitCondition('year', 2)),
    'y': datePartGetterFactory(digitCondition('year', 1)),
    'MMMM': datePartGetterFactory(nameCondition('month', 4)),
    'MMM': datePartGetterFactory(nameCondition('month', 3)),
    'MM': datePartGetterFactory(digitCondition('month', 2)),
    'M': datePartGetterFactory(digitCondition('month', 1)),
    'LLLL': datePartGetterFactory(nameCondition('month', 4)),
    'L': datePartGetterFactory(nameCondition('month', 1)),
    'dd': datePartGetterFactory(digitCondition('day', 2)),
    'd': datePartGetterFactory(digitCondition('day', 1)),
    'HH': digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),
    'H': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
    'hh': digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),
    'h': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
    'jj': datePartGetterFactory(digitCondition('hour', 2)),
    'j': datePartGetterFactory(digitCondition('hour', 1)),
    'mm': digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
    'm': datePartGetterFactory(digitCondition('minute', 1)),
    'ss': digitModifier(datePartGetterFactory(digitCondition('second', 2))),
    's': datePartGetterFactory(digitCondition('second', 1)),
    // while ISO 8601 requires fractions to be prefixed with `.` or `,`
    // we can be just safely rely on using `sss` since we currently don't support single or two digit
    // fractions
    'sss': datePartGetterFactory(digitCondition('second', 3)),
    'EEEE': datePartGetterFactory(nameCondition('weekday', 4)),
    'EEE': datePartGetterFactory(nameCondition('weekday', 3)),
    'EE': datePartGetterFactory(nameCondition('weekday', 2)),
    'E': datePartGetterFactory(nameCondition('weekday', 1)),
    'a': hourClockExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
    'Z': timeZoneGetter('short'),
    'z': timeZoneGetter('long'),
    'ww': datePartGetterFactory({}),
    // first Thursday of the year. not support ?
    'w': datePartGetterFactory({}),
    // of the year not support ?
    'G': datePartGetterFactory(nameCondition('era', 1)),
    'GG': datePartGetterFactory(nameCondition('era', 2)),
    'GGG': datePartGetterFactory(nameCondition('era', 3)),
    'GGGG': datePartGetterFactory(nameCondition('era', 4))
};
/**
 * @param {?} inner
 * @return {?}
 */
function digitModifier(inner) {
    return function (date, locale) {
        var /** @type {?} */ result = inner(date, locale);
        return result.length == 1 ? '0' + result : result;
    };
}
/**
 * @param {?} inner
 * @return {?}
 */
function hourClockExtractor(inner) {
    return function (date, locale) { return inner(date, locale).split(' ')[1]; };
}
/**
 * @param {?} inner
 * @return {?}
 */
function hourExtractor(inner) {
    return function (date, locale) { return inner(date, locale).split(' ')[0]; };
}
/**
 * @param {?} date
 * @param {?} locale
 * @param {?} options
 * @return {?}
 */
function intlDateFormat(date, locale, options) {
    return new Intl.DateTimeFormat(locale, options).format(date).replace(/[\u200e\u200f]/g, '');
}
/**
 * @param {?} timezone
 * @return {?}
 */
function timeZoneGetter(timezone) {
    // To workaround `Intl` API restriction for single timezone let format with 24 hours
    var /** @type {?} */ options = { hour: '2-digit', hour12: false, timeZoneName: timezone };
    return function (date, locale) {
        var /** @type {?} */ result = intlDateFormat(date, locale, options);
        // Then extract first 3 letters that related to hours
        return result ? result.substring(3) : '';
    };
}
/**
 * @param {?} options
 * @param {?} value
 * @return {?}
 */
function hour12Modify(options, value) {
    options.hour12 = value;
    return options;
}
/**
 * @param {?} prop
 * @param {?} len
 * @return {?}
 */
function digitCondition(prop, len) {
    var /** @type {?} */ result = {};
    result[prop] = len === 2 ? '2-digit' : 'numeric';
    return result;
}
/**
 * @param {?} prop
 * @param {?} len
 * @return {?}
 */
function nameCondition(prop, len) {
    var /** @type {?} */ result = {};
    if (len < 4) {
        result[prop] = len > 1 ? 'short' : 'narrow';
    }
    else {
        result[prop] = 'long';
    }
    return result;
}
/**
 * @param {?} options
 * @return {?}
 */
function combine(options) {
    return ((Object)).assign.apply(((Object)), [{}].concat(options));
}
/**
 * @param {?} ret
 * @return {?}
 */
function datePartGetterFactory(ret) {
    return function (date, locale) { return intlDateFormat(date, locale, ret); };
}
var DATE_FORMATTER_CACHE = new Map();
/**
 * @param {?} format
 * @param {?} date
 * @param {?} locale
 * @return {?}
 */
function dateFormatter(format, date, locale) {
    var /** @type {?} */ fn = PATTERN_ALIASES[format];
    if (fn)
        return fn(date, locale);
    var /** @type {?} */ cacheKey = format;
    var /** @type {?} */ parts = DATE_FORMATTER_CACHE.get(cacheKey);
    if (!parts) {
        parts = [];
        var /** @type {?} */ match = void 0;
        DATE_FORMATS_SPLIT.exec(format);
        var /** @type {?} */ _format = format;
        while (_format) {
            match = DATE_FORMATS_SPLIT.exec(_format);
            if (match) {
                parts = parts.concat(match.slice(1));
                _format = ((parts.pop()));
            }
            else {
                parts.push(_format);
                _format = null;
            }
        }
        DATE_FORMATTER_CACHE.set(cacheKey, parts);
    }
    return parts.reduce(function (text, part) {
        var /** @type {?} */ fn = DATE_FORMATS[part];
        return text + (fn ? fn(date, locale) : partToTime(part));
    }, '');
}
/**
 * @param {?} part
 * @return {?}
 */
function partToTime(part) {
    return part === '\'\'' ? '\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
}
var DateFormatter = (function () {
    function DateFormatter() {
    }
    /**
     * @param {?} date
     * @param {?} locale
     * @param {?} pattern
     * @return {?}
     */
    DateFormatter.format = function (date, locale, pattern) {
        return dateFormatter(pattern, date, locale);
    };
    return DateFormatter;
}());
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var _NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
/**
 * @param {?} pipe
 * @param {?} locale
 * @param {?} value
 * @param {?} style
 * @param {?=} digits
 * @param {?=} currency
 * @param {?=} currencyAsSymbol
 * @return {?}
 */
function formatNumber(pipe, locale, value, style, digits, currency, currencyAsSymbol) {
    if (currency === void 0) { currency = null; }
    if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
    if (value == null)
        return null;
    // Convert strings to numbers
    value = typeof value === 'string' && isNumeric(value) ? +value : value;
    if (typeof value !== 'number') {
        throw invalidPipeArgumentError(pipe, value);
    }
    var /** @type {?} */ minInt = undefined;
    var /** @type {?} */ minFraction = undefined;
    var /** @type {?} */ maxFraction = undefined;
    if (style !== NumberFormatStyle.Currency) {
        // rely on Intl default for currency
        minInt = 1;
        minFraction = 0;
        maxFraction = 3;
    }
    if (digits) {
        var /** @type {?} */ parts = digits.match(_NUMBER_FORMAT_REGEXP);
        if (parts === null) {
            throw new Error(digits + " is not a valid digit info for number pipes");
        }
        if (parts[1] != null) {
            minInt = parseIntAutoRadix(parts[1]);
        }
        if (parts[3] != null) {
            minFraction = parseIntAutoRadix(parts[3]);
        }
        if (parts[5] != null) {
            maxFraction = parseIntAutoRadix(parts[5]);
        }
    }
    return NumberFormatter.format(/** @type {?} */ (value), locale, style, {
        minimumIntegerDigits: minInt,
        minimumFractionDigits: minFraction,
        maximumFractionDigits: maxFraction,
        currency: currency,
        currencyAsSymbol: currencyAsSymbol,
    });
}
/**
 * \@ngModule CommonModule
 * \@whatItDoes Formats a number according to locale rules.
 * \@howToUse `number_expression | number[:digitInfo]`
 *
 * Formats a number as text. Group sizing and separator and other locale-specific
 * configurations are based on the active locale.
 *
 * where `expression` is a number:
 *  - `digitInfo` is a `string` which has a following format: <br>
 *     <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>
 *   - `minIntegerDigits` is the minimum number of integer digits to use. Defaults to `1`.
 *   - `minFractionDigits` is the minimum number of digits after fraction. Defaults to `0`.
 *   - `maxFractionDigits` is the maximum number of digits after fraction. Defaults to `3`.
 *
 * For more information on the acceptable range for each of these numbers and other
 * details see your native internationalization library.
 *
 * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
 * and may require a polyfill. See {\@linkDocs guide/browser-support} for details.
 *
 * ### Example
 *
 * {\@example common/pipes/ts/number_pipe.ts region='NumberPipe'}
 *
 * \@stable
 */
var DecimalPipe = (function () {
    /**
     * @param {?} _locale
     */
    function DecimalPipe(_locale) {
        this._locale = _locale;
    }
    /**
     * @param {?} value
     * @param {?=} digits
     * @return {?}
     */
    DecimalPipe.prototype.transform = function (value, digits) {
        return formatNumber(DecimalPipe, this._locale, value, NumberFormatStyle.Decimal, digits);
    };
DecimalPipe.ɵfac = function DecimalPipe_Factory(t) { return new (t || DecimalPipe)(ɵngcc0.ɵɵdirectiveInject(_angular_core.LOCALE_ID)); };
DecimalPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "number", type: DecimalPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DecimalPipe, [{
        type: _angular_core.Pipe,
        args: [{ name: 'number' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: _angular_core.Inject,
                args: [_angular_core.LOCALE_ID]
            }] }]; }, null); })();
    return DecimalPipe;
}());
/**
 * @nocollapse
 */
DecimalPipe.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
]; };
/**
 * \@ngModule CommonModule
 * \@whatItDoes Formats a number as a percentage according to locale rules.
 * \@howToUse `number_expression | percent[:digitInfo]`
 *
 * \@description
 *
 * Formats a number as percentage.
 *
 * - `digitInfo` See {\@link DecimalPipe} for detailed description.
 *
 * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
 * and may require a polyfill. See {\@linkDocs guide/browser-support} for details.
 *
 * ### Example
 *
 * {\@example common/pipes/ts/number_pipe.ts region='PercentPipe'}
 *
 * \@stable
 */
var PercentPipe = (function () {
    /**
     * @param {?} _locale
     */
    function PercentPipe(_locale) {
        this._locale = _locale;
    }
    /**
     * @param {?} value
     * @param {?=} digits
     * @return {?}
     */
    PercentPipe.prototype.transform = function (value, digits) {
        return formatNumber(PercentPipe, this._locale, value, NumberFormatStyle.Percent, digits);
    };
PercentPipe.ɵfac = function PercentPipe_Factory(t) { return new (t || PercentPipe)(ɵngcc0.ɵɵdirectiveInject(_angular_core.LOCALE_ID)); };
PercentPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "percent", type: PercentPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PercentPipe, [{
        type: _angular_core.Pipe,
        args: [{ name: 'percent' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: _angular_core.Inject,
                args: [_angular_core.LOCALE_ID]
            }] }]; }, null); })();
    return PercentPipe;
}());
/**
 * @nocollapse
 */
PercentPipe.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
]; };
/**
 * \@ngModule CommonModule
 * \@whatItDoes Formats a number as currency using locale rules.
 * \@howToUse `number_expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]`
 * \@description
 *
 * Use `currency` to format a number as currency.
 *
 * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such
 *    as `USD` for the US dollar and `EUR` for the euro.
 * - `symbolDisplay` is a boolean indicating whether to use the currency symbol or code.
 *   - `true`: use symbol (e.g. `$`).
 *   - `false`(default): use code (e.g. `USD`).
 * - `digitInfo` See {\@link DecimalPipe} for detailed description.
 *
 * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
 * and may require a polyfill. See {\@linkDocs guide/browser-support} for details.
 *
 * ### Example
 *
 * {\@example common/pipes/ts/number_pipe.ts region='CurrencyPipe'}
 *
 * \@stable
 */
var CurrencyPipe = (function () {
    /**
     * @param {?} _locale
     */
    function CurrencyPipe(_locale) {
        this._locale = _locale;
    }
    /**
     * @param {?} value
     * @param {?=} currencyCode
     * @param {?=} symbolDisplay
     * @param {?=} digits
     * @return {?}
     */
    CurrencyPipe.prototype.transform = function (value, currencyCode, symbolDisplay, digits) {
        if (currencyCode === void 0) { currencyCode = 'USD'; }
        if (symbolDisplay === void 0) { symbolDisplay = false; }
        return formatNumber(CurrencyPipe, this._locale, value, NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
    };
CurrencyPipe.ɵfac = function CurrencyPipe_Factory(t) { return new (t || CurrencyPipe)(ɵngcc0.ɵɵdirectiveInject(_angular_core.LOCALE_ID)); };
CurrencyPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "currency", type: CurrencyPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CurrencyPipe, [{
        type: _angular_core.Pipe,
        args: [{ name: 'currency' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: _angular_core.Inject,
                args: [_angular_core.LOCALE_ID]
            }] }]; }, null); })();
    return CurrencyPipe;
}());
/**
 * @nocollapse
 */
CurrencyPipe.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
]; };
/**
 * @param {?} text
 * @return {?}
 */
function parseIntAutoRadix(text) {
    var /** @type {?} */ result = parseInt(text);
    if (isNaN(result)) {
        throw new Error('Invalid integer literal when parsing ' + text);
    }
    return result;
}
/**
 * @param {?} value
 * @return {?}
 */
function isNumeric(value) {
    return !isNaN(value - parseFloat(value));
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ISO8601_DATE_REGEX = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
/**
 * \@ngModule CommonModule
 * \@whatItDoes Formats a date according to locale rules.
 * \@howToUse `date_expression | date[:format]`
 * \@description
 *
 * Where:
 * - `expression` is a date object or a number (milliseconds since UTC epoch) or an ISO string
 * (https://www.w3.org/TR/NOTE-datetime).
 * - `format` indicates which date/time components to include. The format can be predefined as
 *   shown below or custom as shown in the table.
 *   - `'medium'`: equivalent to `'yMMMdjms'` (e.g. `Sep 3, 2010, 12:05:08 PM` for `en-US`)
 *   - `'short'`: equivalent to `'yMdjm'` (e.g. `9/3/2010, 12:05 PM` for `en-US`)
 *   - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. `Friday, September 3, 2010` for `en-US`)
 *   - `'longDate'`: equivalent to `'yMMMMd'` (e.g. `September 3, 2010` for `en-US`)
 *   - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. `Sep 3, 2010` for `en-US`)
 *   - `'shortDate'`: equivalent to `'yMd'` (e.g. `9/3/2010` for `en-US`)
 *   - `'mediumTime'`: equivalent to `'jms'` (e.g. `12:05:08 PM` for `en-US`)
 *   - `'shortTime'`: equivalent to `'jm'` (e.g. `12:05 PM` for `en-US`)
 *
 *
 *  | Component | Symbol | Narrow | Short Form   | Long Form         | Numeric   | 2-digit   |
 *  |-----------|:------:|--------|--------------|-------------------|-----------|-----------|
 *  | era       |   G    | G (A)  | GGG (AD)     | GGGG (Anno Domini)| -         | -         |
 *  | year      |   y    | -      | -            | -                 | y (2015)  | yy (15)   |
 *  | month     |   M    | L (S)  | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |
 *  | day       |   d    | -      | -            | -                 | d (3)     | dd (03)   |
 *  | weekday   |   E    | E (S)  | EEE (Sun)    | EEEE (Sunday)     | -         | -         |
 *  | hour      |   j    | -      | -            | -                 | j (13)    | jj (13)   |
 *  | hour12    |   h    | -      | -            | -                 | h (1 PM)  | hh (01 PM)|
 *  | hour24    |   H    | -      | -            | -                 | H (13)    | HH (13)   |
 *  | minute    |   m    | -      | -            | -                 | m (5)     | mm (05)   |
 *  | second    |   s    | -      | -            | -                 | s (9)     | ss (09)   |
 *  | timezone  |   z    | -      | -            | z (Pacific Standard Time)| -  | -         |
 *  | timezone  |   Z    | -      | Z (GMT-8:00) | -                 | -         | -         |
 *  | timezone  |   a    | -      | a (PM)       | -                 | -         | -         |
 *
 * In javascript, only the components specified will be respected (not the ordering,
 * punctuations, ...) and details of the formatting will be dependent on the locale.
 *
 * Timezone of the formatted text will be the local system timezone of the end-user's machine.
 *
 * When the expression is a ISO string without time (e.g. 2016-09-19) the time zone offset is not
 * applied and the formatted text will have the same day, month and year of the expression.
 *
 * WARNINGS:
 * - this pipe is marked as pure hence it will not be re-evaluated when the input is mutated.
 *   Instead users should treat the date as an immutable object and change the reference when the
 *   pipe needs to re-run (this is to avoid reformatting the date on every change detection run
 *   which would be an expensive operation).
 * - this pipe uses the Internationalization API. Therefore it is only reliable in Chrome and Opera
 *   browsers.
 *
 * ### Examples
 *
 * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)
 * in the _local_ time and locale is 'en-US':
 *
 * ```
 *     {{ dateObj | date }}               // output is 'Jun 15, 2015'
 *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'
 *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'
 *     {{ dateObj | date:'mmss' }}        // output is '43:11'
 * ```
 *
 * {\@example common/pipes/ts/date_pipe.ts region='DatePipe'}
 *
 * \@stable
 */
var DatePipe = (function () {
    /**
     * @param {?} _locale
     */
    function DatePipe(_locale) {
        this._locale = _locale;
    }
    /**
     * @param {?} value
     * @param {?=} pattern
     * @return {?}
     */
    DatePipe.prototype.transform = function (value, pattern) {
        if (pattern === void 0) { pattern = 'mediumDate'; }
        var /** @type {?} */ date;
        if (isBlank(value) || value !== value)
            return null;
        if (typeof value === 'string') {
            value = value.trim();
        }
        if (isDate(value)) {
            date = value;
        }
        else if (isNumeric(value)) {
            date = new Date(parseFloat(value));
        }
        else if (typeof value === 'string' && /^(\d{4}-\d{1,2}-\d{1,2})$/.test(value)) {
            /**
            * For ISO Strings without time the day, month and year must be extracted from the ISO String
            * before Date creation to avoid time offset and errors in the new Date.
            * If we only replace '-' with ',' in the ISO String ("2015,01,01"), and try to create a new
            * date, some browsers (e.g. IE 9) will throw an invalid Date error
            * If we leave the '-' ("2015-01-01") and try to create a new Date("2015-01-01") the timeoffset
            * is applied
            * Note: ISO months are 0 for January, 1 for February, ...
            */
            var _a = value.split('-').map(function (val) { return parseInt(val, 10); }), y = _a[0], m = _a[1], d = _a[2];
            date = new Date(y, m - 1, d);
        }
        else {
            date = new Date(value);
        }
        if (!isDate(date)) {
            var /** @type {?} */ match = void 0;
            if ((typeof value === 'string') && (match = value.match(ISO8601_DATE_REGEX))) {
                date = isoStringToDate(match);
            }
            else {
                throw invalidPipeArgumentError(DatePipe, value);
            }
        }
        return DateFormatter.format(date, this._locale, DatePipe._ALIASES[pattern] || pattern);
    };
DatePipe.ɵfac = function DatePipe_Factory(t) { return new (t || DatePipe)(ɵngcc0.ɵɵdirectiveInject(_angular_core.LOCALE_ID)); };
DatePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "date", type: DatePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePipe, [{
        type: _angular_core.Pipe,
        args: [{ name: 'date', pure: true }]
    }], function () { return [{ type: undefined, decorators: [{
                type: _angular_core.Inject,
                args: [_angular_core.LOCALE_ID]
            }] }]; }, null); })();
    return DatePipe;
}());
/**
 * \@internal
 */
DatePipe._ALIASES = {
    'medium': 'yMMMdjms',
    'short': 'yMdjm',
    'fullDate': 'yMMMMEEEEd',
    'longDate': 'yMMMMd',
    'mediumDate': 'yMMMd',
    'shortDate': 'yMd',
    'mediumTime': 'jms',
    'shortTime': 'jm'
};
/**
 * @nocollapse
 */
DatePipe.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
]; };
/**
 * @param {?} obj
 * @return {?}
 */
function isBlank(obj) {
    return obj == null || obj === '';
}
/**
 * @param {?} obj
 * @return {?}
 */
function isDate(obj) {
    return obj instanceof Date && !isNaN(obj.valueOf());
}
/**
 * @param {?} match
 * @return {?}
 */
function isoStringToDate(match) {
    var /** @type {?} */ date = new Date(0);
    var /** @type {?} */ tzHour = 0;
    var /** @type {?} */ tzMin = 0;
    var /** @type {?} */ dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
    var /** @type {?} */ timeSetter = match[8] ? date.setUTCHours : date.setHours;
    if (match[9]) {
        tzHour = toInt(match[9] + match[10]);
        tzMin = toInt(match[9] + match[11]);
    }
    dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
    var /** @type {?} */ h = toInt(match[4] || '0') - tzHour;
    var /** @type {?} */ m = toInt(match[5] || '0') - tzMin;
    var /** @type {?} */ s = toInt(match[6] || '0');
    var /** @type {?} */ ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
    timeSetter.call(date, h, m, s, ms);
    return date;
}
/**
 * @param {?} str
 * @return {?}
 */
function toInt(str) {
    return parseInt(str, 10);
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var _INTERPOLATION_REGEXP = /#/g;
/**
 * \@ngModule CommonModule
 * \@whatItDoes Maps a value to a string that pluralizes the value according to locale rules.
 * \@howToUse `expression | i18nPlural:mapping`
 * \@description
 *
 *  Where:
 *  - `expression` is a number.
 *  - `mapping` is an object that mimics the ICU format, see
 *    http://userguide.icu-project.org/formatparse/messages
 *
 *  ## Example
 *
 * {\@example common/pipes/ts/i18n_pipe.ts region='I18nPluralPipeComponent'}
 *
 * \@experimental
 */
var I18nPluralPipe = (function () {
    /**
     * @param {?} _localization
     */
    function I18nPluralPipe(_localization) {
        this._localization = _localization;
    }
    /**
     * @param {?} value
     * @param {?} pluralMap
     * @return {?}
     */
    I18nPluralPipe.prototype.transform = function (value, pluralMap) {
        if (value == null)
            return '';
        if (typeof pluralMap !== 'object' || pluralMap === null) {
            throw invalidPipeArgumentError(I18nPluralPipe, pluralMap);
        }
        var /** @type {?} */ key = getPluralCategory(value, Object.keys(pluralMap), this._localization);
        return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
    };
I18nPluralPipe.ɵfac = function I18nPluralPipe_Factory(t) { return new (t || I18nPluralPipe)(ɵngcc0.ɵɵdirectiveInject(NgLocalization)); };
I18nPluralPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "i18nPlural", type: I18nPluralPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(I18nPluralPipe, [{
        type: _angular_core.Pipe,
        args: [{ name: 'i18nPlural', pure: true }]
    }], function () { return [{ type: NgLocalization }]; }, null); })();
    return I18nPluralPipe;
}());
/**
 * @nocollapse
 */
I18nPluralPipe.ctorParameters = function () { return [
    { type: NgLocalization, },
]; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@ngModule CommonModule
 * \@whatItDoes Generic selector that displays the string that matches the current value.
 * \@howToUse `expression | i18nSelect:mapping`
 * \@description
 *
 *  Where `mapping` is an object that indicates the text that should be displayed
 *  for different values of the provided `expression`.
 *  If none of the keys of the mapping match the value of the `expression`, then the content
 *  of the `other` key is returned when present, otherwise an empty string is returned.
 *
 *  ## Example
 *
 * {\@example common/pipes/ts/i18n_pipe.ts region='I18nSelectPipeComponent'}
 *
 *  \@experimental
 */
var I18nSelectPipe = (function () {
    function I18nSelectPipe() {
    }
    /**
     * @param {?} value
     * @param {?} mapping
     * @return {?}
     */
    I18nSelectPipe.prototype.transform = function (value, mapping) {
        if (value == null)
            return '';
        if (typeof mapping !== 'object' || typeof value !== 'string') {
            throw invalidPipeArgumentError(I18nSelectPipe, mapping);
        }
        if (mapping.hasOwnProperty(value)) {
            return mapping[value];
        }
        if (mapping.hasOwnProperty('other')) {
            return mapping['other'];
        }
        return '';
    };
I18nSelectPipe.ɵfac = function I18nSelectPipe_Factory(t) { return new (t || I18nSelectPipe)(); };
I18nSelectPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "i18nSelect", type: I18nSelectPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(I18nSelectPipe, [{
        type: _angular_core.Pipe,
        args: [{ name: 'i18nSelect', pure: true }]
    }], function () { return []; }, null); })();
    return I18nSelectPipe;
}());
/**
 * @nocollapse
 */
I18nSelectPipe.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@ngModule CommonModule
 * \@whatItDoes Converts value into JSON string.
 * \@howToUse `expression | json`
 * \@description
 *
 * Converts value into string using `JSON.stringify`. Useful for debugging.
 *
 * ### Example
 * {\@example common/pipes/ts/json_pipe.ts region='JsonPipe'}
 *
 * \@stable
 */
var JsonPipe = (function () {
    function JsonPipe() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    JsonPipe.prototype.transform = function (value) { return JSON.stringify(value, null, 2); };
JsonPipe.ɵfac = function JsonPipe_Factory(t) { return new (t || JsonPipe)(); };
JsonPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "json", type: JsonPipe, pure: false });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(JsonPipe, [{
        type: _angular_core.Pipe,
        args: [{ name: 'json', pure: false }]
    }], function () { return []; }, null); })();
    return JsonPipe;
}());
/**
 * @nocollapse
 */
JsonPipe.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@ngModule CommonModule
 * \@whatItDoes Creates a new List or String containing a subset (slice) of the elements.
 * \@howToUse `array_or_string_expression | slice:start[:end]`
 * \@description
 *
 * Where the input expression is a `List` or `String`, and:
 * - `start`: The starting index of the subset to return.
 *   - **a positive integer**: return the item at `start` index and all items after
 *     in the list or string expression.
 *   - **a negative integer**: return the item at `start` index from the end and all items after
 *     in the list or string expression.
 *   - **if positive and greater than the size of the expression**: return an empty list or string.
 *   - **if negative and greater than the size of the expression**: return entire list or string.
 * - `end`: The ending index of the subset to return.
 *   - **omitted**: return all items until the end.
 *   - **if positive**: return all items before `end` index of the list or string.
 *   - **if negative**: return all items before `end` index from the end of the list or string.
 *
 * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`
 * and `String.prototype.slice()`.
 *
 * When operating on a [List], the returned list is always a copy even when all
 * the elements are being returned.
 *
 * When operating on a blank value, the pipe returns the blank value.
 *
 * ## List Example
 *
 * This `ngFor` example:
 *
 * {\@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}
 *
 * produces the following:
 *
 *     <li>b</li>
 *     <li>c</li>
 *
 * ## String Examples
 *
 * {\@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}
 *
 * \@stable
 */
var SlicePipe = (function () {
    function SlicePipe() {
    }
    /**
     * @param {?} value
     * @param {?} start
     * @param {?=} end
     * @return {?}
     */
    SlicePipe.prototype.transform = function (value, start, end) {
        if (value == null)
            return value;
        if (!this.supports(value)) {
            throw invalidPipeArgumentError(SlicePipe, value);
        }
        return value.slice(start, end);
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    SlicePipe.prototype.supports = function (obj) { return typeof obj === 'string' || Array.isArray(obj); };
SlicePipe.ɵfac = function SlicePipe_Factory(t) { return new (t || SlicePipe)(); };
SlicePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "slice", type: SlicePipe, pure: false });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SlicePipe, [{
        type: _angular_core.Pipe,
        args: [{ name: 'slice', pure: false }]
    }], function () { return []; }, null); })();
    return SlicePipe;
}());
/**
 * @nocollapse
 */
SlicePipe.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * This module provides a set of common Pipes.
 */
/**
 * A collection of Angular pipes that are likely to be used in each and every application.
 */
var COMMON_PIPES = [
    AsyncPipe,
    UpperCasePipe,
    LowerCasePipe,
    JsonPipe,
    SlicePipe,
    DecimalPipe,
    PercentPipe,
    TitleCasePipe,
    CurrencyPipe,
    DatePipe,
    I18nPluralPipe,
    I18nSelectPipe,
];
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * The module that includes all the basic Angular directives like {\@link NgIf}, {\@link NgForOf}, ...
 *
 * \@stable
 */
var CommonModule = (function () {
    function CommonModule() {
    }
CommonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CommonModule });
CommonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function CommonModule_Factory(t) { return new (t || CommonModule)(); }, providers: [
        { provide: NgLocalization, useClass: NgLocaleLocalization },
    ] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CommonModule, { declarations: [NgClass,
        NgComponentOutlet,
        NgForOf,
        NgIf,
        NgTemplateOutlet,
        NgStyle,
        NgSwitch,
        NgSwitchCase,
        NgSwitchDefault,
        NgPlural,
        NgPluralCase,
        AsyncPipe,
        UpperCasePipe,
        LowerCasePipe,
        JsonPipe,
        SlicePipe,
        DecimalPipe,
        PercentPipe,
        TitleCasePipe,
        CurrencyPipe,
        DatePipe,
        I18nPluralPipe,
        I18nSelectPipe], exports: [NgClass,
        NgComponentOutlet,
        NgForOf,
        NgIf,
        NgTemplateOutlet,
        NgStyle,
        NgSwitch,
        NgSwitchCase,
        NgSwitchDefault,
        NgPlural,
        NgPluralCase,
        AsyncPipe,
        UpperCasePipe,
        LowerCasePipe,
        JsonPipe,
        SlicePipe,
        DecimalPipe,
        PercentPipe,
        TitleCasePipe,
        CurrencyPipe,
        DatePipe,
        I18nPluralPipe,
        I18nSelectPipe] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CommonModule, [{
        type: _angular_core.NgModule,
        args: [{
                declarations: [COMMON_DIRECTIVES, COMMON_PIPES],
                exports: [COMMON_DIRECTIVES, COMMON_PIPES],
                providers: [
                    { provide: NgLocalization, useClass: NgLocaleLocalization },
                ]
            }]
    }], function () { return []; }, null); })();
    return CommonModule;
}());
/**
 * @nocollapse
 */
CommonModule.ctorParameters = function () { return []; };
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the common package.
 */
/**
 * \@stable
 */
var VERSION = new _angular_core.Version('4.1.3');

var AngularFontAwesomeModule = (function () {
    function AngularFontAwesomeModule() {
    }
AngularFontAwesomeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AngularFontAwesomeModule });
AngularFontAwesomeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AngularFontAwesomeModule_Factory(t) { return new (t || AngularFontAwesomeModule)(); }, providers: [AngularFontAwesomeService], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AngularFontAwesomeModule, { declarations: [AngularFontAwesomeComponent], imports: [CommonModule], exports: [AngularFontAwesomeComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularFontAwesomeModule, [{
        type: _angular_core.NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [AngularFontAwesomeComponent],
                providers: [AngularFontAwesomeService],
                exports: [AngularFontAwesomeComponent]
            }]
    }], function () { return []; }, null); })();
    return AngularFontAwesomeModule;
}());
/**
 * @nocollapse
 */
AngularFontAwesomeModule.ctorParameters = function () { return []; };

/**
 * Generated bundle index. Do not edit.
 */

exports.AngularFontAwesomeComponent = AngularFontAwesomeComponent;
exports.AngularFontAwesomeService = AngularFontAwesomeService;
exports.AngularFontAwesomeModule = AngularFontAwesomeModule;

Object.defineProperty(exports, '__esModule', { value: true });
exports.NgClass = NgClass;
exports.NgComponentOutlet = NgComponentOutlet;
exports.NgForOf = NgForOf;
exports.NgIf = NgIf;
exports.NgTemplateOutlet = NgTemplateOutlet;
exports.NgStyle = NgStyle;
exports.NgSwitch = NgSwitch;
exports.NgSwitchCase = NgSwitchCase;
exports.NgSwitchDefault = NgSwitchDefault;
exports.NgPlural = NgPlural;
exports.NgPluralCase = NgPluralCase;
exports.AsyncPipe = AsyncPipe;
exports.UpperCasePipe = UpperCasePipe;
exports.LowerCasePipe = LowerCasePipe;
exports.JsonPipe = JsonPipe;
exports.SlicePipe = SlicePipe;
exports.DecimalPipe = DecimalPipe;
exports.PercentPipe = PercentPipe;
exports.TitleCasePipe = TitleCasePipe;
exports.CurrencyPipe = CurrencyPipe;
exports.DatePipe = DatePipe;
exports.I18nPluralPipe = I18nPluralPipe;
exports.I18nSelectPipe = I18nSelectPipe;

})));


//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1mb250LWF3ZXNvbWUudW1kLmpzIiwic291cmNlcyI6WyJhbmd1bGFyLWZvbnQtYXdlc29tZS51bWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7aUdBQ3dFO3NFQUNsQjt5QkFDNUM7MEJBQ1M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBK0NiOztLQUVELEFBT0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBaUJHOztLQUVBLEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBFQXlZa0Y7O0tBRS9FLEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBaUl1Rjs7cUJBRXBFLEFBR25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FzSHVGOztxQkFFcEUsQUFHbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FpR0k7O21CQUVhLEFBR2pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkE4bEJJOztLQUVELEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBb0hJOztLQUVELEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBc1FJOztLQUVELEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBNk1JOztLQUVELEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQThLSTs7S0FFRCxBQUdIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkE4QzJIOztLQUV4SCxBQUdIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBMkNHOztLQUVBLEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBa0dJOztLQUVELEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQXVDRzs7S0FFQSxBQUdIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBOEZJOztLQUVELEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQXVFSTs7S0FFRCxBQUdIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0ZBMk5JOztLQUVELEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQW1DSTs7S0FFRCxBQUdIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBb0NJOztLQUVELEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREF3Qkk7O0tBRUQsQUFHSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FzV0k7O0tBRUQsQUFHSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBeUNJOztLQUVELEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBaURJOztLQUVELEFBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBMEpJOzs7Ozs7Ozs7Ozs7Ozs7RUFlSixBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3RUErRkk7O0tBRUQsQUFHSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFvREk7O0tBRUQsQUFHSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBZ0M2Rjs7S0FFMUYsQUFHSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBNkUwRzs7S0FFdkcsQUFHSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBZ0RHOztLQUVBLEFBU0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREF3Qkc7O0tBRUEsQUFRSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3Q0FjNEQiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpKSA6XHJcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJ10sIGZhY3RvcnkpIDpcclxuXHQoZmFjdG9yeSgoZ2xvYmFsLmFuZ3VsYXJGb250QXdlc29tZSA9IGdsb2JhbC5hbmd1bGFyRm9udEF3ZXNvbWUgfHwge30pLGdsb2JhbC5uZy5jb3JlKSk7XHJcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFuZ3VsYXJGb250QXdlc29tZUNvbXBvbmVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBbmd1bGFyRm9udEF3ZXNvbWVDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9uYWxDbGFzc2VzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuZ3VsYXJGb250QXdlc29tZUNvbXBvbmVudC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5hbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwibmFtZVwiIHByb3BlcnR5IGZvciBBbmd1bGFyMiBGb250IEF3ZXNvbWUgY29tcG9uZW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRUb09wdGlvbmFsQ2xhc3NlcyhcImZhLVwiICsgdGhpcy5zaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZml4ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRUb09wdGlvbmFsQ2xhc3NlcyhcImZhLWZ3XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRUb09wdGlvbmFsQ2xhc3NlcyhcImZhLVwiICsgdGhpcy5hbmltYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yb3RhdGUpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcm90YXRlQ2xhc3MgPSAodHlwZW9mIHRoaXMucm90YXRlID09PSAnbnVtYmVyJykgPyBcImZhLXJvdGF0ZS1cIiArIHRoaXMucm90YXRlXHJcbiAgICAgICAgICAgICAgICA6IFwiZmEtZmxpcC1cIiArIHRoaXMucm90YXRlO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFRvT3B0aW9uYWxDbGFzc2VzKHJvdGF0ZUNsYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaW52ZXJzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFRvT3B0aW9uYWxDbGFzc2VzKFwiZmEtaW52ZXJzZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuZ3VsYXJGb250QXdlc29tZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uYWxDbGFzc2VzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9uYWxDbGFzc2VzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFkZENsYXNzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmd1bGFyRm9udEF3ZXNvbWVDb21wb25lbnQucHJvdG90eXBlLmFkZFRvT3B0aW9uYWxDbGFzc2VzID0gZnVuY3Rpb24gKGFkZENsYXNzKSB7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9uYWxDbGFzc2VzLnB1c2goYWRkQ2xhc3MpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBbmd1bGFyRm9udEF3ZXNvbWVDb21wb25lbnQ7XHJcbn0oKSk7XHJcbkFuZ3VsYXJGb250QXdlc29tZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCwgYXJnczogW3tcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZmEnLFxyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGkgY2xhc3M9XFxcImZhIGZhLXt7IG5hbWUgfX1cXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBbbmdDbGFzc109XFxcIm9wdGlvbmFsQ2xhc3Nlc1xcXCIgPjwvaT4gXCIsXHJcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIlwiXVxyXG4gICAgICAgICAgICB9LF0gfSxcclxuXTtcclxuLyoqXHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5Bbmd1bGFyRm9udEF3ZXNvbWVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcclxuQW5ndWxhckZvbnRBd2Vzb21lQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xyXG4gICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcclxuICAgICd0aXRsZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG4gICAgJ3NpemUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcclxuICAgICdmaXhlZCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG4gICAgJ2FuaW1hdGlvbic6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG4gICAgJ3JvdGF0ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG4gICAgJ2ludmVyc2UnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcclxufTtcclxuXHJcbnZhciBBbmd1bGFyRm9udEF3ZXNvbWVTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFuZ3VsYXJGb250QXdlc29tZVNlcnZpY2UoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQW5ndWxhckZvbnRBd2Vzb21lU2VydmljZTtcclxufSgpKTtcclxuQW5ndWxhckZvbnRBd2Vzb21lU2VydmljZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcclxuXTtcclxuLyoqXHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5Bbmd1bGFyRm9udEF3ZXNvbWVTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XHJcblxyXG52YXIgX19leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxuLyoqXHJcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjQuMS4zXHJcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cclxuICogTGljZW5zZTogTUlUXHJcbiAqL1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSBieSBhbiBhcHBsaWNhdGlvbiBkZXZlbG9wZXIuIEluc3RlYWQsIHVzZVxyXG4gKiB7XFxAbGluayBMb2NhdGlvbn0uXHJcbiAqXHJcbiAqIGBQbGF0Zm9ybUxvY2F0aW9uYCBlbmNhcHN1bGF0ZXMgYWxsIGNhbGxzIHRvIERPTSBhcGlzLCB3aGljaCBhbGxvd3MgdGhlIFJvdXRlciB0byBiZSBwbGF0Zm9ybVxyXG4gKiBhZ25vc3RpYy5cclxuICogVGhpcyBtZWFucyB0aGF0IHdlIGNhbiBoYXZlIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbiBvZiBgUGxhdGZvcm1Mb2NhdGlvbmAgZm9yIHRoZSBkaWZmZXJlbnRcclxuICogcGxhdGZvcm1zIHRoYXQgYW5ndWxhciBzdXBwb3J0cy4gRm9yIGV4YW1wbGUsIGBcXEBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJgIHByb3ZpZGVzIGFuXHJcbiAqIGltcGxlbWVudGF0aW9uIHNwZWNpZmljIHRvIHRoZSBicm93c2VyIGVudmlyb25tZW50LCB3aGlsZSBgXFxAYW5ndWxhci9wbGF0Zm9ybS13ZWJ3b3JrZXJgIHByb3ZpZGVzXHJcbiAqIG9uZSBzdWl0YWJsZSBmb3IgdXNlIHdpdGggd2ViIHdvcmtlcnMuXHJcbiAqXHJcbiAqIFRoZSBgUGxhdGZvcm1Mb2NhdGlvbmAgY2xhc3MgaXMgdXNlZCBkaXJlY3RseSBieSBhbGwgaW1wbGVtZW50YXRpb25zIG9mIHtcXEBsaW5rIExvY2F0aW9uU3RyYXRlZ3l9XHJcbiAqIHdoZW4gdGhleSBuZWVkIHRvIGludGVyYWN0IHdpdGggdGhlIERPTSBhcGlzIGxpa2UgcHVzaFN0YXRlLCBwb3BTdGF0ZSwgZXRjLi4uXHJcbiAqXHJcbiAqIHtcXEBsaW5rIExvY2F0aW9uU3RyYXRlZ3l9IGluIHR1cm4gaXMgdXNlZCBieSB0aGUge1xcQGxpbmsgTG9jYXRpb259IHNlcnZpY2Ugd2hpY2ggaXMgdXNlZCBkaXJlY3RseVxyXG4gKiBieSB0aGUge1xcQGxpbmsgUm91dGVyfSBpbiBvcmRlciB0byBuYXZpZ2F0ZSBiZXR3ZWVuIHJvdXRlcy4gU2luY2UgYWxsIGludGVyYWN0aW9ucyBiZXR3ZWVuIHtcXEBsaW5rXHJcbiAqIFJvdXRlcn0gL1xyXG4gKiB7XFxAbGluayBMb2NhdGlvbn0gLyB7XFxAbGluayBMb2NhdGlvblN0cmF0ZWd5fSBhbmQgRE9NIGFwaXMgZmxvdyB0aHJvdWdoIHRoZSBgUGxhdGZvcm1Mb2NhdGlvbmBcclxuICogY2xhc3MgdGhleSBhcmUgYWxsIHBsYXRmb3JtIGluZGVwZW5kZW50LlxyXG4gKlxyXG4gKiBcXEBzdGFibGVcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG52YXIgUGxhdGZvcm1Mb2NhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQbGF0Zm9ybUxvY2F0aW9uKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmdldEJhc2VIcmVmRnJvbURPTSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gez99IGZuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5vblBvcFN0YXRlID0gZnVuY3Rpb24gKGZuKSB7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHs/fSBmblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUub25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUucGF0aG5hbWUgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSB0aXRsZVxyXG4gICAgICogQHBhcmFtIHs/fSB1cmxcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCkgeyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVcclxuICAgICAqIEBwYXJhbSB7P30gdGl0bGVcclxuICAgICAqIEBwYXJhbSB7P30gdXJsXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwpIHsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICByZXR1cm4gUGxhdGZvcm1Mb2NhdGlvbjtcclxufSgpKTtcclxuLyoqXHJcbiAqIFxcQHdoYXRJdERvZXMgaW5kaWNhdGVzIHdoZW4gYSBsb2NhdGlvbiBpcyBpbml0aWFsaXplZFxyXG4gKiBcXEBleHBlcmltZW50YWxcclxuICovXHJcbnZhciBMT0NBVElPTl9JTklUSUFMSVpFRCA9IG5ldyBfYW5ndWxhcl9jb3JlLkluamVjdGlvblRva2VuKCdMb2NhdGlvbiBJbml0aWFsaXplZCcpO1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBgTG9jYXRpb25TdHJhdGVneWAgaXMgcmVzcG9uc2libGUgZm9yIHJlcHJlc2VudGluZyBhbmQgcmVhZGluZyByb3V0ZSBzdGF0ZVxyXG4gKiBmcm9tIHRoZSBicm93c2VyJ3MgVVJMLiBBbmd1bGFyIHByb3ZpZGVzIHR3byBzdHJhdGVnaWVzOlxyXG4gKiB7XFxAbGluayBIYXNoTG9jYXRpb25TdHJhdGVneX0gYW5kIHtcXEBsaW5rIFBhdGhMb2NhdGlvblN0cmF0ZWd5fS5cclxuICpcclxuICogVGhpcyBpcyB1c2VkIHVuZGVyIHRoZSBob29kIG9mIHRoZSB7XFxAbGluayBMb2NhdGlvbn0gc2VydmljZS5cclxuICpcclxuICogQXBwbGljYXRpb25zIHNob3VsZCB1c2UgdGhlIHtcXEBsaW5rIFJvdXRlcn0gb3Ige1xcQGxpbmsgTG9jYXRpb259IHNlcnZpY2VzIHRvXHJcbiAqIGludGVyYWN0IHdpdGggYXBwbGljYXRpb24gcm91dGUgc3RhdGUuXHJcbiAqXHJcbiAqIEZvciBpbnN0YW5jZSwge1xcQGxpbmsgSGFzaExvY2F0aW9uU3RyYXRlZ3l9IHByb2R1Y2VzIFVSTHMgbGlrZVxyXG4gKiBgaHR0cDovL2V4YW1wbGUuY29tIy9mb29gLCBhbmQge1xcQGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9IHByb2R1Y2VzXHJcbiAqIGBodHRwOi8vZXhhbXBsZS5jb20vZm9vYCBhcyBhbiBlcXVpdmFsZW50IFVSTC5cclxuICpcclxuICogU2VlIHRoZXNlIHR3byBjbGFzc2VzIGZvciBtb3JlLlxyXG4gKlxyXG4gKiBcXEBzdGFibGVcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG52YXIgTG9jYXRpb25TdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMb2NhdGlvblN0cmF0ZWd5KCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSB7Pz19IGluY2x1ZGVIYXNoXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKGluY2x1ZGVIYXNoKSB7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcm5hbFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucHJlcGFyZUV4dGVybmFsVXJsID0gZnVuY3Rpb24gKGludGVybmFsKSB7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSB0aXRsZVxyXG4gICAgICogQHBhcmFtIHs/fSB1cmxcclxuICAgICAqIEBwYXJhbSB7P30gcXVlcnlQYXJhbXNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCwgcXVlcnlQYXJhbXMpIHsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IHRpdGxlXHJcbiAgICAgKiBAcGFyYW0gez99IHVybFxyXG4gICAgICogQHBhcmFtIHs/fSBxdWVyeVBhcmFtc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsLCBxdWVyeVBhcmFtcykgeyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gez99IGZuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5vblBvcFN0YXRlID0gZnVuY3Rpb24gKGZuKSB7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZ2V0QmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICByZXR1cm4gTG9jYXRpb25TdHJhdGVneTtcclxufSgpKTtcclxuLyoqXHJcbiAqIFRoZSBgQVBQX0JBU0VfSFJFRmAgdG9rZW4gcmVwcmVzZW50cyB0aGUgYmFzZSBocmVmIHRvIGJlIHVzZWQgd2l0aCB0aGVcclxuICoge1xcQGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9LlxyXG4gKlxyXG4gKiBJZiB5b3UncmUgdXNpbmcge1xcQGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9LCB5b3UgbXVzdCBwcm92aWRlIGEgcHJvdmlkZXIgdG8gYSBzdHJpbmdcclxuICogcmVwcmVzZW50aW5nIHRoZSBVUkwgcHJlZml4IHRoYXQgc2hvdWxkIGJlIHByZXNlcnZlZCB3aGVuIGdlbmVyYXRpbmcgYW5kIHJlY29nbml6aW5nXHJcbiAqIFVSTHMuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHtDb21wb25lbnQsIE5nTW9kdWxlfSBmcm9tICdcXEBhbmd1bGFyL2NvcmUnO1xyXG4gKiBpbXBvcnQge0FQUF9CQVNFX0hSRUZ9IGZyb20gJ1xcQGFuZ3VsYXIvY29tbW9uJztcclxuICpcclxuICogXFxATmdNb2R1bGUoe1xyXG4gKiAgIHByb3ZpZGVyczogW3twcm92aWRlOiBBUFBfQkFTRV9IUkVGLCB1c2VWYWx1ZTogJy9teS9hcHAnfV1cclxuICogfSlcclxuICogY2xhc3MgQXBwTW9kdWxlIHt9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBcXEBzdGFibGVcclxuICovXHJcbnZhciBBUFBfQkFTRV9IUkVGID0gbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0aW9uVG9rZW4oJ2FwcEJhc2VIcmVmJyk7XHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIFxcQHdoYXRJdERvZXMgYExvY2F0aW9uYCBpcyBhIHNlcnZpY2UgdGhhdCBhcHBsaWNhdGlvbnMgY2FuIHVzZSB0byBpbnRlcmFjdCB3aXRoIGEgYnJvd3NlcidzIFVSTC5cclxuICogXFxAZGVzY3JpcHRpb25cclxuICogRGVwZW5kaW5nIG9uIHdoaWNoIHtcXEBsaW5rIExvY2F0aW9uU3RyYXRlZ3l9IGlzIHVzZWQsIGBMb2NhdGlvbmAgd2lsbCBlaXRoZXIgcGVyc2lzdFxyXG4gKiB0byB0aGUgVVJMJ3MgcGF0aCBvciB0aGUgVVJMJ3MgaGFzaCBzZWdtZW50LlxyXG4gKlxyXG4gKiBOb3RlOiBpdCdzIGJldHRlciB0byB1c2Uge1xcQGxpbmsgUm91dGVyI25hdmlnYXRlfSBzZXJ2aWNlIHRvIHRyaWdnZXIgcm91dGUgY2hhbmdlcy4gVXNlXHJcbiAqIGBMb2NhdGlvbmAgb25seSBpZiB5b3UgbmVlZCB0byBpbnRlcmFjdCB3aXRoIG9yIGNyZWF0ZSBub3JtYWxpemVkIFVSTHMgb3V0c2lkZSBvZlxyXG4gKiByb3V0aW5nLlxyXG4gKlxyXG4gKiBgTG9jYXRpb25gIGlzIHJlc3BvbnNpYmxlIGZvciBub3JtYWxpemluZyB0aGUgVVJMIGFnYWluc3QgdGhlIGFwcGxpY2F0aW9uJ3MgYmFzZSBocmVmLlxyXG4gKiBBIG5vcm1hbGl6ZWQgVVJMIGlzIGFic29sdXRlIGZyb20gdGhlIFVSTCBob3N0LCBpbmNsdWRlcyB0aGUgYXBwbGljYXRpb24ncyBiYXNlIGhyZWYsIGFuZCBoYXMgbm9cclxuICogdHJhaWxpbmcgc2xhc2g6XHJcbiAqIC0gYC9teS9hcHAvdXNlci8xMjNgIGlzIG5vcm1hbGl6ZWRcclxuICogLSBgbXkvYXBwL3VzZXIvMTIzYCAqKmlzIG5vdCoqIG5vcm1hbGl6ZWRcclxuICogLSBgL215L2FwcC91c2VyLzEyMy9gICoqaXMgbm90Kiogbm9ybWFsaXplZFxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiB7XFxAZXhhbXBsZSBjb21tb24vbG9jYXRpb24vdHMvcGF0aF9sb2NhdGlvbl9jb21wb25lbnQudHMgcmVnaW9uPSdMb2NhdGlvbkNvbXBvbmVudCd9XHJcbiAqIFxcQHN0YWJsZVxyXG4gKi9cclxudmFyIExvY2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwbGF0Zm9ybVN0cmF0ZWd5XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIExvY2F0aW9uKHBsYXRmb3JtU3RyYXRlZ3kpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFxcQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kgPSBwbGF0Zm9ybVN0cmF0ZWd5O1xyXG4gICAgICAgIHZhciBicm93c2VyQmFzZUhyZWYgPSB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LmdldEJhc2VIcmVmKCk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSBMb2NhdGlvbi5zdHJpcFRyYWlsaW5nU2xhc2goX3N0cmlwSW5kZXhIdG1sKGJyb3dzZXJCYXNlSHJlZikpO1xyXG4gICAgICAgIHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kub25Qb3BTdGF0ZShmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3N1YmplY3QuZW1pdCh7XHJcbiAgICAgICAgICAgICAgICAndXJsJzogX3RoaXMucGF0aCh0cnVlKSxcclxuICAgICAgICAgICAgICAgICdwb3AnOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiBldi50eXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/PX0gaW5jbHVkZUhhc2hcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKGluY2x1ZGVIYXNoKSB7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVIYXNoID09PSB2b2lkIDApIHsgaW5jbHVkZUhhc2ggPSBmYWxzZTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSh0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LnBhdGgoaW5jbHVkZUhhc2gpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIHBhdGggYW5kIGNvbXBhcmVzIHRvIHRoZSBjdXJyZW50IG5vcm1hbGl6ZWQgcGF0aC5cclxuICAgICAqIEBwYXJhbSB7P30gcGF0aFxyXG4gICAgICogQHBhcmFtIHs/PX0gcXVlcnlcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5pc0N1cnJlbnRQYXRoRXF1YWxUbyA9IGZ1bmN0aW9uIChwYXRoLCBxdWVyeSkge1xyXG4gICAgICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwKSB7IHF1ZXJ5ID0gJyc7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoKCkgPT0gdGhpcy5ub3JtYWxpemUocGF0aCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5KSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBVUkwsIHJldHVybnMgdGhlIG5vcm1hbGl6ZWQgVVJMIHBhdGggd2l0aG91dCBsZWFkaW5nIG9yXHJcbiAgICAgKiB0cmFpbGluZyBzbGFzaGVzLlxyXG4gICAgICogQHBhcmFtIHs/fSB1cmxcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIExvY2F0aW9uLnN0cmlwVHJhaWxpbmdTbGFzaChfc3RyaXBCYXNlSHJlZih0aGlzLl9iYXNlSHJlZiwgX3N0cmlwSW5kZXhIdG1sKHVybCkpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIFVSTCwgcmV0dXJucyB0aGUgcGxhdGZvcm0tc3BlY2lmaWMgZXh0ZXJuYWwgVVJMIHBhdGguXHJcbiAgICAgKiBJZiB0aGUgZ2l2ZW4gVVJMIGRvZXNuJ3QgYmVnaW4gd2l0aCBhIGxlYWRpbmcgc2xhc2ggKGAnLydgKSwgdGhpcyBtZXRob2QgYWRkcyBvbmVcclxuICAgICAqIGJlZm9yZSBub3JtYWxpemluZy4gVGhpcyBtZXRob2Qgd2lsbCBhbHNvIGFkZCBhIGhhc2ggaWYgYEhhc2hMb2NhdGlvblN0cmF0ZWd5YCBpc1xyXG4gICAgICogdXNlZCwgb3IgdGhlIGBBUFBfQkFTRV9IUkVGYCBpZiB0aGUgYFBhdGhMb2NhdGlvblN0cmF0ZWd5YCBpcyBpbiB1c2UuXHJcbiAgICAgKiBAcGFyYW0gez99IHVybFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLnByZXBhcmVFeHRlcm5hbFVybCA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICBpZiAodXJsICYmIHVybFswXSAhPT0gJy8nKSB7XHJcbiAgICAgICAgICAgIHVybCA9ICcvJyArIHVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kucHJlcGFyZUV4dGVybmFsVXJsKHVybCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBicm93c2VycyBVUkwgdG8gdGhlIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gVVJMLCBhbmQgcHVzaGVzIGFcclxuICAgICAqIG5ldyBpdGVtIG9udG8gdGhlIHBsYXRmb3JtJ3MgaGlzdG9yeS5cclxuICAgICAqIEBwYXJhbSB7P30gcGF0aFxyXG4gICAgICogQHBhcmFtIHs/PX0gcXVlcnlcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIChwYXRoLCBxdWVyeSkge1xyXG4gICAgICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwKSB7IHF1ZXJ5ID0gJyc7IH1cclxuICAgICAgICB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LnB1c2hTdGF0ZShudWxsLCAnJywgcGF0aCwgcXVlcnkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgYnJvd3NlcnMgVVJMIHRvIHRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIFVSTCwgYW5kIHJlcGxhY2VzXHJcbiAgICAgKiB0aGUgdG9wIGl0ZW0gb24gdGhlIHBsYXRmb3JtJ3MgaGlzdG9yeSBzdGFjay5cclxuICAgICAqIEBwYXJhbSB7P30gcGF0aFxyXG4gICAgICogQHBhcmFtIHs/PX0gcXVlcnlcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiAocGF0aCwgcXVlcnkpIHtcclxuICAgICAgICBpZiAocXVlcnkgPT09IHZvaWQgMCkgeyBxdWVyeSA9ICcnOyB9XHJcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5yZXBsYWNlU3RhdGUobnVsbCwgJycsIHBhdGgsIHF1ZXJ5KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE5hdmlnYXRlcyBmb3J3YXJkIGluIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBMb2NhdGlvbi5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5mb3J3YXJkKCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIE5hdmlnYXRlcyBiYWNrIGluIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBMb2NhdGlvbi5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5iYWNrKCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSB0byB0aGUgcGxhdGZvcm0ncyBgcG9wU3RhdGVgIGV2ZW50cy5cclxuICAgICAqIEBwYXJhbSB7P30gb25OZXh0XHJcbiAgICAgKiBAcGFyYW0gez89fSBvblRocm93XHJcbiAgICAgKiBAcGFyYW0gez89fSBvblJldHVyblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvbk5leHQsIG9uVGhyb3csIG9uUmV0dXJuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YmplY3Quc3Vic2NyaWJlKHsgbmV4dDogb25OZXh0LCBlcnJvcjogb25UaHJvdywgY29tcGxldGU6IG9uUmV0dXJuIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBzdHJpbmcgb2YgdXJsIHBhcmFtZXRlcnMsIHByZXBlbmQgd2l0aCAnPycgaWYgbmVlZGVkLCBvdGhlcndpc2UgcmV0dXJuIHBhcmFtZXRlcnMgYXNcclxuICAgICAqIGlzLlxyXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBwYXJhbXMgJiYgcGFyYW1zWzBdICE9PSAnPycgPyAnPycgKyBwYXJhbXMgOiBwYXJhbXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiAyIHBhcnRzIG9mIGEgdXJsLCBqb2luIHRoZW0gd2l0aCBhIHNsYXNoIGlmIG5lZWRlZC5cclxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcclxuICAgICAqIEBwYXJhbSB7P30gZW5kXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBMb2NhdGlvbi5qb2luV2l0aFNsYXNoID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICBpZiAoc3RhcnQubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZC5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNsYXNoZXMgPSAwO1xyXG4gICAgICAgIGlmIChzdGFydC5lbmRzV2l0aCgnLycpKSB7XHJcbiAgICAgICAgICAgIHNsYXNoZXMrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZC5zdGFydHNXaXRoKCcvJykpIHtcclxuICAgICAgICAgICAgc2xhc2hlcysrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2xhc2hlcyA9PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFydCArIGVuZC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzbGFzaGVzID09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgZW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RhcnQgKyAnLycgKyBlbmQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB1cmwgaGFzIGEgdHJhaWxpbmcgc2xhc2gsIHJlbW92ZSBpdCwgb3RoZXJ3aXNlIHJldHVybiB1cmwgYXMgaXMuXHJcbiAgICAgKiBAcGFyYW0gez99IHVybFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTG9jYXRpb24uc3RyaXBUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJyk7IH07XHJcbiAgICByZXR1cm4gTG9jYXRpb247XHJcbn0oKSk7XHJcbkxvY2F0aW9uLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxyXG5dO1xyXG4vKipcclxuICogQG5vY29sbGFwc2VcclxuICovXHJcbkxvY2F0aW9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgeyB0eXBlOiBMb2NhdGlvblN0cmF0ZWd5LCB9LFxyXG5dOyB9O1xyXG4vKipcclxuICogQHBhcmFtIHs/fSBiYXNlSHJlZlxyXG4gKiBAcGFyYW0gez99IHVybFxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gX3N0cmlwQmFzZUhyZWYoYmFzZUhyZWYsIHVybCkge1xyXG4gICAgcmV0dXJuIGJhc2VIcmVmICYmIHVybC5zdGFydHNXaXRoKGJhc2VIcmVmKSA/IHVybC5zdWJzdHJpbmcoYmFzZUhyZWYubGVuZ3RoKSA6IHVybDtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSB1cmxcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIF9zdHJpcEluZGV4SHRtbCh1cmwpIHtcclxuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXFwvaW5kZXguaHRtbCQvLCAnJyk7XHJcbn1cclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogXFxAd2hhdEl0RG9lcyBVc2UgVVJMIGhhc2ggZm9yIHN0b3JpbmcgYXBwbGljYXRpb24gbG9jYXRpb24gZGF0YS5cclxuICogXFxAZGVzY3JpcHRpb25cclxuICogYEhhc2hMb2NhdGlvblN0cmF0ZWd5YCBpcyBhIHtcXEBsaW5rIExvY2F0aW9uU3RyYXRlZ3l9IHVzZWQgdG8gY29uZmlndXJlIHRoZVxyXG4gKiB7XFxAbGluayBMb2NhdGlvbn0gc2VydmljZSB0byByZXByZXNlbnQgaXRzIHN0YXRlIGluIHRoZVxyXG4gKiBbaGFzaCBmcmFnbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pZm9ybV9SZXNvdXJjZV9Mb2NhdG9yI1N5bnRheClcclxuICogb2YgdGhlIGJyb3dzZXIncyBVUkwuXHJcbiAqXHJcbiAqIEZvciBpbnN0YW5jZSwgaWYgeW91IGNhbGwgYGxvY2F0aW9uLmdvKCcvZm9vJylgLCB0aGUgYnJvd3NlcidzIFVSTCB3aWxsIGJlY29tZVxyXG4gKiBgZXhhbXBsZS5jb20jL2Zvb2AuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIHtcXEBleGFtcGxlIGNvbW1vbi9sb2NhdGlvbi90cy9oYXNoX2xvY2F0aW9uX2NvbXBvbmVudC50cyByZWdpb249J0xvY2F0aW9uQ29tcG9uZW50J31cclxuICpcclxuICogXFxAc3RhYmxlXHJcbiAqL1xyXG52YXIgSGFzaExvY2F0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEhhc2hMb2NhdGlvblN0cmF0ZWd5LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IF9wbGF0Zm9ybUxvY2F0aW9uXHJcbiAgICAgKiBAcGFyYW0gez89fSBfYmFzZUhyZWZcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gSGFzaExvY2F0aW9uU3RyYXRlZ3koX3BsYXRmb3JtTG9jYXRpb24sIF9iYXNlSHJlZikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX3BsYXRmb3JtTG9jYXRpb24gPSBfcGxhdGZvcm1Mb2NhdGlvbjtcclxuICAgICAgICBfdGhpcy5fYmFzZUhyZWYgPSAnJztcclxuICAgICAgICBpZiAoX2Jhc2VIcmVmICE9IG51bGwpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2Jhc2VIcmVmID0gX2Jhc2VIcmVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5vblBvcFN0YXRlID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5vblBvcFN0YXRlKGZuKTtcclxuICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLm9uSGFzaENoYW5nZShmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZ2V0QmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9iYXNlSHJlZjsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/PX0gaW5jbHVkZUhhc2hcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKGluY2x1ZGVIYXNoKSB7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVIYXNoID09PSB2b2lkIDApIHsgaW5jbHVkZUhhc2ggPSBmYWxzZTsgfVxyXG4gICAgICAgIC8vIHRoZSBoYXNoIHZhbHVlIGlzIGFsd2F5cyBwcmVmaXhlZCB3aXRoIGEgYCNgXHJcbiAgICAgICAgLy8gYW5kIGlmIGl0IGlzIGVtcHR5IHRoZW4gaXQgd2lsbCBzdGF5IGVtcHR5XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGF0aCA9IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uaGFzaDtcclxuICAgICAgICBpZiAocGF0aCA9PSBudWxsKVxyXG4gICAgICAgICAgICBwYXRoID0gJyMnO1xyXG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDAgPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGg7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGludGVybmFsXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucHJlcGFyZUV4dGVybmFsVXJsID0gZnVuY3Rpb24gKGludGVybmFsKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsID0gTG9jYXRpb24uam9pbldpdGhTbGFzaCh0aGlzLl9iYXNlSHJlZiwgaW50ZXJuYWwpO1xyXG4gICAgICAgIHJldHVybiB1cmwubGVuZ3RoID4gMCA/ICgnIycgKyB1cmwpIDogdXJsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSB0aXRsZVxyXG4gICAgICogQHBhcmFtIHs/fSBwYXRoXHJcbiAgICAgKiBAcGFyYW0gez99IHF1ZXJ5UGFyYW1zXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucHVzaFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgcGF0aCwgcXVlcnlQYXJhbXMpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmwgPSB0aGlzLnByZXBhcmVFeHRlcm5hbFVybChwYXRoICsgTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpKTtcclxuICAgICAgICBpZiAodXJsLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHVybCA9IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucGF0aG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVcclxuICAgICAqIEBwYXJhbSB7P30gdGl0bGVcclxuICAgICAqIEBwYXJhbSB7P30gcGF0aFxyXG4gICAgICogQHBhcmFtIHs/fSBxdWVyeVBhcmFtc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsID0gdGhpcy5wcmVwYXJlRXh0ZXJuYWxVcmwocGF0aCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSk7XHJcbiAgICAgICAgaWYgKHVybC5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB1cmwgPSB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnBhdGhuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5mb3J3YXJkKCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLmJhY2soKTsgfTtcclxuICAgIHJldHVybiBIYXNoTG9jYXRpb25TdHJhdGVneTtcclxufShMb2NhdGlvblN0cmF0ZWd5KSk7XHJcbkhhc2hMb2NhdGlvblN0cmF0ZWd5LmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxyXG5dO1xyXG4vKipcclxuICogQG5vY29sbGFwc2VcclxuICovXHJcbkhhc2hMb2NhdGlvblN0cmF0ZWd5LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgeyB0eXBlOiBQbGF0Zm9ybUxvY2F0aW9uLCB9LFxyXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW0FQUF9CQVNFX0hSRUYsXSB9LF0gfSxcclxuXTsgfTtcclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogXFxAd2hhdEl0RG9lcyBVc2UgVVJMIGZvciBzdG9yaW5nIGFwcGxpY2F0aW9uIGxvY2F0aW9uIGRhdGEuXHJcbiAqIFxcQGRlc2NyaXB0aW9uXHJcbiAqIGBQYXRoTG9jYXRpb25TdHJhdGVneWAgaXMgYSB7XFxAbGluayBMb2NhdGlvblN0cmF0ZWd5fSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGVcclxuICoge1xcQGxpbmsgTG9jYXRpb259IHNlcnZpY2UgdG8gcmVwcmVzZW50IGl0cyBzdGF0ZSBpbiB0aGVcclxuICogW3BhdGhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaWZvcm1fUmVzb3VyY2VfTG9jYXRvciNTeW50YXgpIG9mIHRoZVxyXG4gKiBicm93c2VyJ3MgVVJMLlxyXG4gKlxyXG4gKiBJZiB5b3UncmUgdXNpbmcgYFBhdGhMb2NhdGlvblN0cmF0ZWd5YCwgeW91IG11c3QgcHJvdmlkZSBhIHtcXEBsaW5rIEFQUF9CQVNFX0hSRUZ9XHJcbiAqIG9yIGFkZCBhIGJhc2UgZWxlbWVudCB0byB0aGUgZG9jdW1lbnQuIFRoaXMgVVJMIHByZWZpeCB0aGF0IHdpbGwgYmUgcHJlc2VydmVkXHJcbiAqIHdoZW4gZ2VuZXJhdGluZyBhbmQgcmVjb2duaXppbmcgVVJMcy5cclxuICpcclxuICogRm9yIGluc3RhbmNlLCBpZiB5b3UgcHJvdmlkZSBhbiBgQVBQX0JBU0VfSFJFRmAgb2YgYCcvbXkvYXBwJ2AgYW5kIGNhbGxcclxuICogYGxvY2F0aW9uLmdvKCcvZm9vJylgLCB0aGUgYnJvd3NlcidzIFVSTCB3aWxsIGJlY29tZVxyXG4gKiBgZXhhbXBsZS5jb20vbXkvYXBwL2Zvb2AuXHJcbiAqXHJcbiAqIFNpbWlsYXJseSwgaWYgeW91IGFkZCBgPGJhc2UgaHJlZj0nL215L2FwcCcvPmAgdG8gdGhlIGRvY3VtZW50IGFuZCBjYWxsXHJcbiAqIGBsb2NhdGlvbi5nbygnL2ZvbycpYCwgdGhlIGJyb3dzZXIncyBVUkwgd2lsbCBiZWNvbWVcclxuICogYGV4YW1wbGUuY29tL215L2FwcC9mb29gLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiB7XFxAZXhhbXBsZSBjb21tb24vbG9jYXRpb24vdHMvcGF0aF9sb2NhdGlvbl9jb21wb25lbnQudHMgcmVnaW9uPSdMb2NhdGlvbkNvbXBvbmVudCd9XHJcbiAqXHJcbiAqIFxcQHN0YWJsZVxyXG4gKi9cclxudmFyIFBhdGhMb2NhdGlvblN0cmF0ZWd5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQYXRoTG9jYXRpb25TdHJhdGVneSwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBfcGxhdGZvcm1Mb2NhdGlvblxyXG4gICAgICogQHBhcmFtIHs/PX0gaHJlZlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBQYXRoTG9jYXRpb25TdHJhdGVneShfcGxhdGZvcm1Mb2NhdGlvbiwgaHJlZikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX3BsYXRmb3JtTG9jYXRpb24gPSBfcGxhdGZvcm1Mb2NhdGlvbjtcclxuICAgICAgICBpZiAoaHJlZiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhyZWYgPSBfdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5nZXRCYXNlSHJlZkZyb21ET00oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhyZWYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBiYXNlIGhyZWYgc2V0LiBQbGVhc2UgcHJvdmlkZSBhIHZhbHVlIGZvciB0aGUgQVBQX0JBU0VfSFJFRiB0b2tlbiBvciBhZGQgYSBiYXNlIGVsZW1lbnQgdG8gdGhlIGRvY3VtZW50LlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuX2Jhc2VIcmVmID0gaHJlZjtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5vblBvcFN0YXRlID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5vblBvcFN0YXRlKGZuKTtcclxuICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLm9uSGFzaENoYW5nZShmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZ2V0QmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9iYXNlSHJlZjsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcm5hbFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnByZXBhcmVFeHRlcm5hbFVybCA9IGZ1bmN0aW9uIChpbnRlcm5hbCkge1xyXG4gICAgICAgIHJldHVybiBMb2NhdGlvbi5qb2luV2l0aFNsYXNoKHRoaXMuX2Jhc2VIcmVmLCBpbnRlcm5hbCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez89fSBpbmNsdWRlSGFzaFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoaW5jbHVkZUhhc2gpIHtcclxuICAgICAgICBpZiAoaW5jbHVkZUhhc2ggPT09IHZvaWQgMCkgeyBpbmNsdWRlSGFzaCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGF0aG5hbWUgPSB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnBhdGhuYW1lICtcclxuICAgICAgICAgICAgTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXModGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5zZWFyY2gpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc2ggPSB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLmhhc2g7XHJcbiAgICAgICAgcmV0dXJuIGhhc2ggJiYgaW5jbHVkZUhhc2ggPyBcIlwiICsgcGF0aG5hbWUgKyBoYXNoIDogcGF0aG5hbWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IHRpdGxlXHJcbiAgICAgKiBAcGFyYW0gez99IHVybFxyXG4gICAgICogQHBhcmFtIHs/fSBxdWVyeVBhcmFtc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCwgcXVlcnlQYXJhbXMpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHRlcm5hbFVybCA9IHRoaXMucHJlcGFyZUV4dGVybmFsVXJsKHVybCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSk7XHJcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCBleHRlcm5hbFVybCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IHRpdGxlXHJcbiAgICAgKiBAcGFyYW0gez99IHVybFxyXG4gICAgICogQHBhcmFtIHs/fSBxdWVyeVBhcmFtc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCwgcXVlcnlQYXJhbXMpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHRlcm5hbFVybCA9IHRoaXMucHJlcGFyZUV4dGVybmFsVXJsKHVybCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSk7XHJcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCBleHRlcm5hbFVybCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5mb3J3YXJkKCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLmJhY2soKTsgfTtcclxuICAgIHJldHVybiBQYXRoTG9jYXRpb25TdHJhdGVneTtcclxufShMb2NhdGlvblN0cmF0ZWd5KSk7XHJcblBhdGhMb2NhdGlvblN0cmF0ZWd5LmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxyXG5dO1xyXG4vKipcclxuICogQG5vY29sbGFwc2VcclxuICovXHJcblBhdGhMb2NhdGlvblN0cmF0ZWd5LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgeyB0eXBlOiBQbGF0Zm9ybUxvY2F0aW9uLCB9LFxyXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW0FQUF9CQVNFX0hSRUYsXSB9LF0gfSxcclxuXTsgfTtcclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBcXEBleHBlcmltZW50YWxcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG52YXIgTmdMb2NhbGl6YXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdMb2NhbGl6YXRpb24oKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdMb2NhbGl6YXRpb24ucHJvdG90eXBlLmdldFBsdXJhbENhdGVnb3J5ID0gZnVuY3Rpb24gKHZhbHVlKSB7IH07XHJcbiAgICByZXR1cm4gTmdMb2NhbGl6YXRpb247XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwbHVyYWwgY2F0ZWdvcnkgZm9yIGEgZ2l2ZW4gdmFsdWUuXHJcbiAqIC0gXCI9dmFsdWVcIiB3aGVuIHRoZSBjYXNlIGV4aXN0cyxcclxuICogLSB0aGUgcGx1cmFsIGNhdGVnb3J5IG90aGVyd2lzZVxyXG4gKlxyXG4gKiBcXEBpbnRlcm5hbFxyXG4gKiBAcGFyYW0gez99IHZhbHVlXHJcbiAqIEBwYXJhbSB7P30gY2FzZXNcclxuICogQHBhcmFtIHs/fSBuZ0xvY2FsaXphdGlvblxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGx1cmFsQ2F0ZWdvcnkodmFsdWUsIGNhc2VzLCBuZ0xvY2FsaXphdGlvbikge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gXCI9XCIgKyB2YWx1ZTtcclxuICAgIGlmIChjYXNlcy5pbmRleE9mKGtleSkgPiAtMSkge1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBrZXkgPSBuZ0xvY2FsaXphdGlvbi5nZXRQbHVyYWxDYXRlZ29yeSh2YWx1ZSk7XHJcbiAgICBpZiAoY2FzZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgaWYgKGNhc2VzLmluZGV4T2YoJ290aGVyJykgPiAtMSkge1xyXG4gICAgICAgIHJldHVybiAnb3RoZXInO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcGx1cmFsIG1lc3NhZ2UgZm91bmQgZm9yIHZhbHVlIFxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwbHVyYWwgY2FzZSBiYXNlZCBvbiB0aGUgbG9jYWxlXHJcbiAqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxudmFyIE5nTG9jYWxlTG9jYWxpemF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOZ0xvY2FsZUxvY2FsaXphdGlvbiwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBsb2NhbGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTmdMb2NhbGVMb2NhbGl6YXRpb24obG9jYWxlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sb2NhbGUgPSBsb2NhbGU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ0xvY2FsZUxvY2FsaXphdGlvbi5wcm90b3R5cGUuZ2V0UGx1cmFsQ2F0ZWdvcnkgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbHVyYWwgPSBnZXRQbHVyYWxDYXNlKHRoaXMubG9jYWxlLCB2YWx1ZSk7XHJcbiAgICAgICAgc3dpdGNoIChwbHVyYWwpIHtcclxuICAgICAgICAgICAgY2FzZSBQbHVyYWwuWmVybzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnemVybyc7XHJcbiAgICAgICAgICAgIGNhc2UgUGx1cmFsLk9uZTpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnb25lJztcclxuICAgICAgICAgICAgY2FzZSBQbHVyYWwuVHdvOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0d28nO1xyXG4gICAgICAgICAgICBjYXNlIFBsdXJhbC5GZXc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zldyc7XHJcbiAgICAgICAgICAgIGNhc2UgUGx1cmFsLk1hbnk6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21hbnknO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdvdGhlcic7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBOZ0xvY2FsZUxvY2FsaXphdGlvbjtcclxufShOZ0xvY2FsaXphdGlvbikpO1xyXG5OZ0xvY2FsZUxvY2FsaXphdGlvbi5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcclxuXTtcclxuLyoqXHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5OZ0xvY2FsZUxvY2FsaXphdGlvbi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuTE9DQUxFX0lELF0gfSxdIH0sXHJcbl07IH07XHJcbnZhciBQbHVyYWwgPSB7fTtcclxuUGx1cmFsLlplcm8gPSAwO1xyXG5QbHVyYWwuT25lID0gMTtcclxuUGx1cmFsLlR3byA9IDI7XHJcblBsdXJhbC5GZXcgPSAzO1xyXG5QbHVyYWwuTWFueSA9IDQ7XHJcblBsdXJhbC5PdGhlciA9IDU7XHJcblBsdXJhbFtQbHVyYWwuWmVyb10gPSBcIlplcm9cIjtcclxuUGx1cmFsW1BsdXJhbC5PbmVdID0gXCJPbmVcIjtcclxuUGx1cmFsW1BsdXJhbC5Ud29dID0gXCJUd29cIjtcclxuUGx1cmFsW1BsdXJhbC5GZXddID0gXCJGZXdcIjtcclxuUGx1cmFsW1BsdXJhbC5NYW55XSA9IFwiTWFueVwiO1xyXG5QbHVyYWxbUGx1cmFsLk90aGVyXSA9IFwiT3RoZXJcIjtcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHBsdXJhbCBjYXNlIGJhc2VkIG9uIHRoZSBsb2NhbGVcclxuICpcclxuICogXFxAZXhwZXJpbWVudGFsXHJcbiAqIEBwYXJhbSB7P30gbG9jYWxlXHJcbiAqIEBwYXJhbSB7P30gbkxpa2VcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGdldFBsdXJhbENhc2UobG9jYWxlLCBuTGlrZSkge1xyXG4gICAgLy8gVE9ETyh2aWNiKTogbGF6eSBjb21wdXRlXHJcbiAgICBpZiAodHlwZW9mIG5MaWtlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIG5MaWtlID0gcGFyc2VJbnQoLyoqIEB0eXBlIHs/fSAqLyAobkxpa2UpLCAxMCk7XHJcbiAgICB9XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuID0gKG5MaWtlKTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5EZWNpbWFsID0gbi50b1N0cmluZygpLnJlcGxhY2UoL15bXi5dKlxcLj8vLCAnJyk7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2ID0gbkRlY2ltYWwubGVuZ3RoO1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZiA9IHBhcnNlSW50KG5EZWNpbWFsLCAxMCk7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ID0gcGFyc2VJbnQobi50b1N0cmluZygpLnJlcGxhY2UoL15bXi5dKlxcLj98MCskL2csICcnKSwgMTApIHx8IDA7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYW5nID0gbG9jYWxlLnNwbGl0KCctJylbMF0udG9Mb3dlckNhc2UoKTtcclxuICAgIHN3aXRjaCAobGFuZykge1xyXG4gICAgICAgIGNhc2UgJ2FmJzpcclxuICAgICAgICBjYXNlICdhc2EnOlxyXG4gICAgICAgIGNhc2UgJ2F6JzpcclxuICAgICAgICBjYXNlICdiZW0nOlxyXG4gICAgICAgIGNhc2UgJ2Jleic6XHJcbiAgICAgICAgY2FzZSAnYmcnOlxyXG4gICAgICAgIGNhc2UgJ2JyeCc6XHJcbiAgICAgICAgY2FzZSAnY2UnOlxyXG4gICAgICAgIGNhc2UgJ2NnZyc6XHJcbiAgICAgICAgY2FzZSAnY2hyJzpcclxuICAgICAgICBjYXNlICdja2InOlxyXG4gICAgICAgIGNhc2UgJ2VlJzpcclxuICAgICAgICBjYXNlICdlbCc6XHJcbiAgICAgICAgY2FzZSAnZW8nOlxyXG4gICAgICAgIGNhc2UgJ2VzJzpcclxuICAgICAgICBjYXNlICdldSc6XHJcbiAgICAgICAgY2FzZSAnZm8nOlxyXG4gICAgICAgIGNhc2UgJ2Z1cic6XHJcbiAgICAgICAgY2FzZSAnZ3N3JzpcclxuICAgICAgICBjYXNlICdoYSc6XHJcbiAgICAgICAgY2FzZSAnaGF3JzpcclxuICAgICAgICBjYXNlICdodSc6XHJcbiAgICAgICAgY2FzZSAnamdvJzpcclxuICAgICAgICBjYXNlICdqbWMnOlxyXG4gICAgICAgIGNhc2UgJ2thJzpcclxuICAgICAgICBjYXNlICdrayc6XHJcbiAgICAgICAgY2FzZSAna2tqJzpcclxuICAgICAgICBjYXNlICdrbCc6XHJcbiAgICAgICAgY2FzZSAna3MnOlxyXG4gICAgICAgIGNhc2UgJ2tzYic6XHJcbiAgICAgICAgY2FzZSAna3knOlxyXG4gICAgICAgIGNhc2UgJ2xiJzpcclxuICAgICAgICBjYXNlICdsZyc6XHJcbiAgICAgICAgY2FzZSAnbWFzJzpcclxuICAgICAgICBjYXNlICdtZ28nOlxyXG4gICAgICAgIGNhc2UgJ21sJzpcclxuICAgICAgICBjYXNlICdtbic6XHJcbiAgICAgICAgY2FzZSAnbmInOlxyXG4gICAgICAgIGNhc2UgJ25kJzpcclxuICAgICAgICBjYXNlICduZSc6XHJcbiAgICAgICAgY2FzZSAnbm4nOlxyXG4gICAgICAgIGNhc2UgJ25uaCc6XHJcbiAgICAgICAgY2FzZSAnbnluJzpcclxuICAgICAgICBjYXNlICdvbSc6XHJcbiAgICAgICAgY2FzZSAnb3InOlxyXG4gICAgICAgIGNhc2UgJ29zJzpcclxuICAgICAgICBjYXNlICdwcyc6XHJcbiAgICAgICAgY2FzZSAncm0nOlxyXG4gICAgICAgIGNhc2UgJ3JvZic6XHJcbiAgICAgICAgY2FzZSAncndrJzpcclxuICAgICAgICBjYXNlICdzYXEnOlxyXG4gICAgICAgIGNhc2UgJ3NlaCc6XHJcbiAgICAgICAgY2FzZSAnc24nOlxyXG4gICAgICAgIGNhc2UgJ3NvJzpcclxuICAgICAgICBjYXNlICdzcSc6XHJcbiAgICAgICAgY2FzZSAndGEnOlxyXG4gICAgICAgIGNhc2UgJ3RlJzpcclxuICAgICAgICBjYXNlICd0ZW8nOlxyXG4gICAgICAgIGNhc2UgJ3RrJzpcclxuICAgICAgICBjYXNlICd0cic6XHJcbiAgICAgICAgY2FzZSAndWcnOlxyXG4gICAgICAgIGNhc2UgJ3V6JzpcclxuICAgICAgICBjYXNlICd2byc6XHJcbiAgICAgICAgY2FzZSAndnVuJzpcclxuICAgICAgICBjYXNlICd3YWUnOlxyXG4gICAgICAgIGNhc2UgJ3hvZyc6XHJcbiAgICAgICAgICAgIGlmIChuID09PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAnYWdxJzpcclxuICAgICAgICBjYXNlICdiYXMnOlxyXG4gICAgICAgIGNhc2UgJ2N1JzpcclxuICAgICAgICBjYXNlICdkYXYnOlxyXG4gICAgICAgIGNhc2UgJ2RqZSc6XHJcbiAgICAgICAgY2FzZSAnZHVhJzpcclxuICAgICAgICBjYXNlICdkeW8nOlxyXG4gICAgICAgIGNhc2UgJ2VidSc6XHJcbiAgICAgICAgY2FzZSAnZXdvJzpcclxuICAgICAgICBjYXNlICdndXonOlxyXG4gICAgICAgIGNhc2UgJ2thbSc6XHJcbiAgICAgICAgY2FzZSAna2hxJzpcclxuICAgICAgICBjYXNlICdraSc6XHJcbiAgICAgICAgY2FzZSAna2xuJzpcclxuICAgICAgICBjYXNlICdrb2snOlxyXG4gICAgICAgIGNhc2UgJ2tzZic6XHJcbiAgICAgICAgY2FzZSAnbHJjJzpcclxuICAgICAgICBjYXNlICdsdSc6XHJcbiAgICAgICAgY2FzZSAnbHVvJzpcclxuICAgICAgICBjYXNlICdsdXknOlxyXG4gICAgICAgIGNhc2UgJ21lcic6XHJcbiAgICAgICAgY2FzZSAnbWZlJzpcclxuICAgICAgICBjYXNlICdtZ2gnOlxyXG4gICAgICAgIGNhc2UgJ211YSc6XHJcbiAgICAgICAgY2FzZSAnbXpuJzpcclxuICAgICAgICBjYXNlICdubWcnOlxyXG4gICAgICAgIGNhc2UgJ251cyc6XHJcbiAgICAgICAgY2FzZSAncXUnOlxyXG4gICAgICAgIGNhc2UgJ3JuJzpcclxuICAgICAgICBjYXNlICdydyc6XHJcbiAgICAgICAgY2FzZSAnc2JwJzpcclxuICAgICAgICBjYXNlICd0d3EnOlxyXG4gICAgICAgIGNhc2UgJ3ZhaSc6XHJcbiAgICAgICAgY2FzZSAneWF2JzpcclxuICAgICAgICBjYXNlICd5dWUnOlxyXG4gICAgICAgIGNhc2UgJ3pnaCc6XHJcbiAgICAgICAgY2FzZSAnYWsnOlxyXG4gICAgICAgIGNhc2UgJ2xuJzpcclxuICAgICAgICBjYXNlICdtZyc6XHJcbiAgICAgICAgY2FzZSAncGEnOlxyXG4gICAgICAgIGNhc2UgJ3RpJzpcclxuICAgICAgICAgICAgaWYgKG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+PSAwICYmIG4gPD0gMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xyXG4gICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xyXG4gICAgICAgIGNhc2UgJ2FtJzpcclxuICAgICAgICBjYXNlICdhcyc6XHJcbiAgICAgICAgY2FzZSAnYm4nOlxyXG4gICAgICAgIGNhc2UgJ2ZhJzpcclxuICAgICAgICBjYXNlICdndSc6XHJcbiAgICAgICAgY2FzZSAnaGknOlxyXG4gICAgICAgIGNhc2UgJ2tuJzpcclxuICAgICAgICBjYXNlICdtcic6XHJcbiAgICAgICAgY2FzZSAnenUnOlxyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBuID09PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAnYXInOlxyXG4gICAgICAgICAgICBpZiAobiA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuWmVybztcclxuICAgICAgICAgICAgaWYgKG4gPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcclxuICAgICAgICAgICAgaWYgKG4gPT09IDIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcclxuICAgICAgICAgICAgaWYgKG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAzICYmIG4gJSAxMDAgPD0gMTApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcclxuICAgICAgICAgICAgaWYgKG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAxMSAmJiBuICUgMTAwIDw9IDk5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xyXG4gICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xyXG4gICAgICAgIGNhc2UgJ2FzdCc6XHJcbiAgICAgICAgY2FzZSAnY2EnOlxyXG4gICAgICAgIGNhc2UgJ2RlJzpcclxuICAgICAgICBjYXNlICdlbic6XHJcbiAgICAgICAgY2FzZSAnZXQnOlxyXG4gICAgICAgIGNhc2UgJ2ZpJzpcclxuICAgICAgICBjYXNlICdmeSc6XHJcbiAgICAgICAgY2FzZSAnZ2wnOlxyXG4gICAgICAgIGNhc2UgJ2l0JzpcclxuICAgICAgICBjYXNlICdubCc6XHJcbiAgICAgICAgY2FzZSAnc3YnOlxyXG4gICAgICAgIGNhc2UgJ3N3JzpcclxuICAgICAgICBjYXNlICd1cic6XHJcbiAgICAgICAgY2FzZSAneWknOlxyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiB2ID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAnYmUnOlxyXG4gICAgICAgICAgICBpZiAobiAlIDEwID09PSAxICYmICEobiAlIDEwMCA9PT0gMTEpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIGlmIChuICUgMTAgPT09IE1hdGguZmxvb3IobiAlIDEwKSAmJiBuICUgMTAgPj0gMiAmJiBuICUgMTAgPD0gNCAmJlxyXG4gICAgICAgICAgICAgICAgIShuICUgMTAwID49IDEyICYmIG4gJSAxMDAgPD0gMTQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XHJcbiAgICAgICAgICAgIGlmIChuICUgMTAgPT09IDAgfHwgbiAlIDEwID09PSBNYXRoLmZsb29yKG4gJSAxMCkgJiYgbiAlIDEwID49IDUgJiYgbiAlIDEwIDw9IDkgfHxcclxuICAgICAgICAgICAgICAgIG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAxMSAmJiBuICUgMTAwIDw9IDE0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xyXG4gICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xyXG4gICAgICAgIGNhc2UgJ2JyJzpcclxuICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMSAmJiAhKG4gJSAxMDAgPT09IDExIHx8IG4gJSAxMDAgPT09IDcxIHx8IG4gJSAxMDAgPT09IDkxKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xyXG4gICAgICAgICAgICBpZiAobiAlIDEwID09PSAyICYmICEobiAlIDEwMCA9PT0gMTIgfHwgbiAlIDEwMCA9PT0gNzIgfHwgbiAlIDEwMCA9PT0gOTIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XHJcbiAgICAgICAgICAgIGlmIChuICUgMTAgPT09IE1hdGguZmxvb3IobiAlIDEwKSAmJiAobiAlIDEwID49IDMgJiYgbiAlIDEwIDw9IDQgfHwgbiAlIDEwID09PSA5KSAmJlxyXG4gICAgICAgICAgICAgICAgIShuICUgMTAwID49IDEwICYmIG4gJSAxMDAgPD0gMTkgfHwgbiAlIDEwMCA+PSA3MCAmJiBuICUgMTAwIDw9IDc5IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbiAlIDEwMCA+PSA5MCAmJiBuICUgMTAwIDw9IDk5KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xyXG4gICAgICAgICAgICBpZiAoIShuID09PSAwKSAmJiBuICUgMWU2ID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xyXG4gICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xyXG4gICAgICAgIGNhc2UgJ2JzJzpcclxuICAgICAgICBjYXNlICdocic6XHJcbiAgICAgICAgY2FzZSAnc3InOlxyXG4gICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IDEgJiYgIShpICUgMTAwID09PSAxMSkgfHwgZiAlIDEwID09PSAxICYmICEoZiAlIDEwMCA9PT0gMTEpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gTWF0aC5mbG9vcihpICUgMTApICYmIGkgJSAxMCA+PSAyICYmIGkgJSAxMCA8PSA0ICYmXHJcbiAgICAgICAgICAgICAgICAhKGkgJSAxMDAgPj0gMTIgJiYgaSAlIDEwMCA8PSAxNCkgfHxcclxuICAgICAgICAgICAgICAgIGYgJSAxMCA9PT0gTWF0aC5mbG9vcihmICUgMTApICYmIGYgJSAxMCA+PSAyICYmIGYgJSAxMCA8PSA0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIShmICUgMTAwID49IDEyICYmIGYgJSAxMDAgPD0gMTQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAnY3MnOlxyXG4gICAgICAgIGNhc2UgJ3NrJzpcclxuICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgdiA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gTWF0aC5mbG9vcihpKSAmJiBpID49IDIgJiYgaSA8PSA0ICYmIHYgPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcclxuICAgICAgICAgICAgaWYgKCEodiA9PT0gMCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAnY3knOlxyXG4gICAgICAgICAgICBpZiAobiA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuWmVybztcclxuICAgICAgICAgICAgaWYgKG4gPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcclxuICAgICAgICAgICAgaWYgKG4gPT09IDIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcclxuICAgICAgICAgICAgaWYgKG4gPT09IDMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcclxuICAgICAgICAgICAgaWYgKG4gPT09IDYpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAnZGEnOlxyXG4gICAgICAgICAgICBpZiAobiA9PT0gMSB8fCAhKHQgPT09IDApICYmIChpID09PSAwIHx8IGkgPT09IDEpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAnZHNiJzpcclxuICAgICAgICBjYXNlICdoc2InOlxyXG4gICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAwID09PSAxIHx8IGYgJSAxMDAgPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcclxuICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gMiB8fCBmICUgMTAwID09PSAyKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMDAgPT09IE1hdGguZmxvb3IoaSAlIDEwMCkgJiYgaSAlIDEwMCA+PSAzICYmIGkgJSAxMDAgPD0gNCB8fFxyXG4gICAgICAgICAgICAgICAgZiAlIDEwMCA9PT0gTWF0aC5mbG9vcihmICUgMTAwKSAmJiBmICUgMTAwID49IDMgJiYgZiAlIDEwMCA8PSA0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAnZmYnOlxyXG4gICAgICAgIGNhc2UgJ2ZyJzpcclxuICAgICAgICBjYXNlICdoeSc6XHJcbiAgICAgICAgY2FzZSAna2FiJzpcclxuICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xyXG4gICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xyXG4gICAgICAgIGNhc2UgJ2ZpbCc6XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAwICYmIChpID09PSAxIHx8IGkgPT09IDIgfHwgaSA9PT0gMykgfHxcclxuICAgICAgICAgICAgICAgIHYgPT09IDAgJiYgIShpICUgMTAgPT09IDQgfHwgaSAlIDEwID09PSA2IHx8IGkgJSAxMCA9PT0gOSkgfHxcclxuICAgICAgICAgICAgICAgICEodiA9PT0gMCkgJiYgIShmICUgMTAgPT09IDQgfHwgZiAlIDEwID09PSA2IHx8IGYgJSAxMCA9PT0gOSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcclxuICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcclxuICAgICAgICBjYXNlICdnYSc6XHJcbiAgICAgICAgICAgIGlmIChuID09PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIGlmIChuID09PSAyKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XHJcbiAgICAgICAgICAgIGlmIChuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPj0gMyAmJiBuIDw9IDYpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcclxuICAgICAgICAgICAgaWYgKG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+PSA3ICYmIG4gPD0gMTApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAnZ2QnOlxyXG4gICAgICAgICAgICBpZiAobiA9PT0gMSB8fCBuID09PSAxMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xyXG4gICAgICAgICAgICBpZiAobiA9PT0gMiB8fCBuID09PSAxMilcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xyXG4gICAgICAgICAgICBpZiAobiA9PT0gTWF0aC5mbG9vcihuKSAmJiAobiA+PSAzICYmIG4gPD0gMTAgfHwgbiA+PSAxMyAmJiBuIDw9IDE5KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xyXG4gICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xyXG4gICAgICAgIGNhc2UgJ2d2JzpcclxuICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gMilcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgKGkgJSAxMDAgPT09IDAgfHwgaSAlIDEwMCA9PT0gMjAgfHwgaSAlIDEwMCA9PT0gNDAgfHwgaSAlIDEwMCA9PT0gNjAgfHwgaSAlIDEwMCA9PT0gODApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XHJcbiAgICAgICAgICAgIGlmICghKHYgPT09IDApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xyXG4gICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xyXG4gICAgICAgIGNhc2UgJ2hlJzpcclxuICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgdiA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMiAmJiB2ID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAwICYmICEobiA+PSAwICYmIG4gPD0gMTApICYmIG4gJSAxMCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcclxuICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcclxuICAgICAgICBjYXNlICdpcyc6XHJcbiAgICAgICAgICAgIGlmICh0ID09PSAwICYmIGkgJSAxMCA9PT0gMSAmJiAhKGkgJSAxMDAgPT09IDExKSB8fCAhKHQgPT09IDApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAna3NoJzpcclxuICAgICAgICAgICAgaWYgKG4gPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlplcm87XHJcbiAgICAgICAgICAgIGlmIChuID09PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAna3cnOlxyXG4gICAgICAgIGNhc2UgJ25hcSc6XHJcbiAgICAgICAgY2FzZSAnc2UnOlxyXG4gICAgICAgIGNhc2UgJ3Ntbic6XHJcbiAgICAgICAgICAgIGlmIChuID09PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIGlmIChuID09PSAyKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAnbGFnJzpcclxuICAgICAgICAgICAgaWYgKG4gPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlplcm87XHJcbiAgICAgICAgICAgIGlmICgoaSA9PT0gMCB8fCBpID09PSAxKSAmJiAhKG4gPT09IDApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAnbHQnOlxyXG4gICAgICAgICAgICBpZiAobiAlIDEwID09PSAxICYmICEobiAlIDEwMCA+PSAxMSAmJiBuICUgMTAwIDw9IDE5KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xyXG4gICAgICAgICAgICBpZiAobiAlIDEwID09PSBNYXRoLmZsb29yKG4gJSAxMCkgJiYgbiAlIDEwID49IDIgJiYgbiAlIDEwIDw9IDkgJiZcclxuICAgICAgICAgICAgICAgICEobiAlIDEwMCA+PSAxMSAmJiBuICUgMTAwIDw9IDE5KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xyXG4gICAgICAgICAgICBpZiAoIShmID09PSAwKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcclxuICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcclxuICAgICAgICBjYXNlICdsdic6XHJcbiAgICAgICAgY2FzZSAncHJnJzpcclxuICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMCB8fCBuICUgMTAwID09PSBNYXRoLmZsb29yKG4gJSAxMDApICYmIG4gJSAxMDAgPj0gMTEgJiYgbiAlIDEwMCA8PSAxOSB8fFxyXG4gICAgICAgICAgICAgICAgdiA9PT0gMiAmJiBmICUgMTAwID09PSBNYXRoLmZsb29yKGYgJSAxMDApICYmIGYgJSAxMDAgPj0gMTEgJiYgZiAlIDEwMCA8PSAxOSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuWmVybztcclxuICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMSAmJiAhKG4gJSAxMDAgPT09IDExKSB8fCB2ID09PSAyICYmIGYgJSAxMCA9PT0gMSAmJiAhKGYgJSAxMDAgPT09IDExKSB8fFxyXG4gICAgICAgICAgICAgICAgISh2ID09PSAyKSAmJiBmICUgMTAgPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcclxuICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcclxuICAgICAgICBjYXNlICdtayc6XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gMSB8fCBmICUgMTAgPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcclxuICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcclxuICAgICAgICBjYXNlICdtdCc6XHJcbiAgICAgICAgICAgIGlmIChuID09PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIGlmIChuID09PSAwIHx8IG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAyICYmIG4gJSAxMDAgPD0gMTApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcclxuICAgICAgICAgICAgaWYgKG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAxMSAmJiBuICUgMTAwIDw9IDE5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xyXG4gICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xyXG4gICAgICAgIGNhc2UgJ3BsJzpcclxuICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgdiA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IE1hdGguZmxvb3IoaSAlIDEwKSAmJiBpICUgMTAgPj0gMiAmJiBpICUgMTAgPD0gNCAmJlxyXG4gICAgICAgICAgICAgICAgIShpICUgMTAwID49IDEyICYmIGkgJSAxMDAgPD0gMTQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAwICYmICEoaSA9PT0gMSkgJiYgaSAlIDEwID09PSBNYXRoLmZsb29yKGkgJSAxMCkgJiYgaSAlIDEwID49IDAgJiYgaSAlIDEwIDw9IDEgfHxcclxuICAgICAgICAgICAgICAgIHYgPT09IDAgJiYgaSAlIDEwID09PSBNYXRoLmZsb29yKGkgJSAxMCkgJiYgaSAlIDEwID49IDUgJiYgaSAlIDEwIDw9IDkgfHxcclxuICAgICAgICAgICAgICAgIHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gTWF0aC5mbG9vcihpICUgMTAwKSAmJiBpICUgMTAwID49IDEyICYmIGkgJSAxMDAgPD0gMTQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAncHQnOlxyXG4gICAgICAgICAgICBpZiAobiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID49IDAgJiYgbiA8PSAyICYmICEobiA9PT0gMikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcclxuICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcclxuICAgICAgICBjYXNlICdybyc6XHJcbiAgICAgICAgICAgIGlmIChpID09PSAxICYmIHYgPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcclxuICAgICAgICAgICAgaWYgKCEodiA9PT0gMCkgfHwgbiA9PT0gMCB8fFxyXG4gICAgICAgICAgICAgICAgIShuID09PSAxKSAmJiBuICUgMTAwID09PSBNYXRoLmZsb29yKG4gJSAxMDApICYmIG4gJSAxMDAgPj0gMSAmJiBuICUgMTAwIDw9IDE5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAncnUnOlxyXG4gICAgICAgIGNhc2UgJ3VrJzpcclxuICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAxICYmICEoaSAlIDEwMCA9PT0gMTEpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gTWF0aC5mbG9vcihpICUgMTApICYmIGkgJSAxMCA+PSAyICYmIGkgJSAxMCA8PSA0ICYmXHJcbiAgICAgICAgICAgICAgICAhKGkgJSAxMDAgPj0gMTIgJiYgaSAlIDEwMCA8PSAxNCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcclxuICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAwIHx8XHJcbiAgICAgICAgICAgICAgICB2ID09PSAwICYmIGkgJSAxMCA9PT0gTWF0aC5mbG9vcihpICUgMTApICYmIGkgJSAxMCA+PSA1ICYmIGkgJSAxMCA8PSA5IHx8XHJcbiAgICAgICAgICAgICAgICB2ID09PSAwICYmIGkgJSAxMDAgPT09IE1hdGguZmxvb3IoaSAlIDEwMCkgJiYgaSAlIDEwMCA+PSAxMSAmJiBpICUgMTAwIDw9IDE0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xyXG4gICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xyXG4gICAgICAgIGNhc2UgJ3NoaSc6XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwIHx8IG4gPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcclxuICAgICAgICAgICAgaWYgKG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+PSAyICYmIG4gPD0gMTApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcclxuICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcclxuICAgICAgICBjYXNlICdzaSc6XHJcbiAgICAgICAgICAgIGlmIChuID09PSAwIHx8IG4gPT09IDEgfHwgaSA9PT0gMCAmJiBmID09PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgY2FzZSAnc2wnOlxyXG4gICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAwID09PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMDAgPT09IDIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcclxuICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gTWF0aC5mbG9vcihpICUgMTAwKSAmJiBpICUgMTAwID49IDMgJiYgaSAlIDEwMCA8PSA0IHx8ICEodiA9PT0gMCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcclxuICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcclxuICAgICAgICBjYXNlICd0em0nOlxyXG4gICAgICAgICAgICBpZiAobiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID49IDAgJiYgbiA8PSAxIHx8IG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+PSAxMSAmJiBuIDw9IDk5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XHJcbiAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBcXEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcclxuICpcclxuICogXFxAd2hhdEl0RG9lcyBBZGRzIGFuZCByZW1vdmVzIENTUyBjbGFzc2VzIG9uIGFuIEhUTUwgZWxlbWVudC5cclxuICpcclxuICogXFxAaG93VG9Vc2VcclxuICogYGBgXHJcbiAqICAgICA8c29tZS1lbGVtZW50IFtuZ0NsYXNzXT1cIidmaXJzdCBzZWNvbmQnXCI+Li4uPC9zb21lLWVsZW1lbnQ+XHJcbiAqXHJcbiAqICAgICA8c29tZS1lbGVtZW50IFtuZ0NsYXNzXT1cIlsnZmlyc3QnLCAnc2Vjb25kJ11cIj4uLi48L3NvbWUtZWxlbWVudD5cclxuICpcclxuICogICAgIDxzb21lLWVsZW1lbnQgW25nQ2xhc3NdPVwieydmaXJzdCc6IHRydWUsICdzZWNvbmQnOiB0cnVlLCAndGhpcmQnOiBmYWxzZX1cIj4uLi48L3NvbWUtZWxlbWVudD5cclxuICpcclxuICogICAgIDxzb21lLWVsZW1lbnQgW25nQ2xhc3NdPVwic3RyaW5nRXhwfGFycmF5RXhwfG9iakV4cFwiPi4uLjwvc29tZS1lbGVtZW50PlxyXG4gKlxyXG4gKiAgICAgPHNvbWUtZWxlbWVudCBbbmdDbGFzc109XCJ7J2NsYXNzMSBjbGFzczIgY2xhc3MzJyA6IHRydWV9XCI+Li4uPC9zb21lLWVsZW1lbnQ+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBcXEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBUaGUgQ1NTIGNsYXNzZXMgYXJlIHVwZGF0ZWQgYXMgZm9sbG93cywgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIHRoZSBleHByZXNzaW9uIGV2YWx1YXRpb246XHJcbiAqIC0gYHN0cmluZ2AgLSB0aGUgQ1NTIGNsYXNzZXMgbGlzdGVkIGluIHRoZSBzdHJpbmcgKHNwYWNlIGRlbGltaXRlZCkgYXJlIGFkZGVkLFxyXG4gKiAtIGBBcnJheWAgLSB0aGUgQ1NTIGNsYXNzZXMgZGVjbGFyZWQgYXMgQXJyYXkgZWxlbWVudHMgYXJlIGFkZGVkLFxyXG4gKiAtIGBPYmplY3RgIC0ga2V5cyBhcmUgQ1NTIGNsYXNzZXMgdGhhdCBnZXQgYWRkZWQgd2hlbiB0aGUgZXhwcmVzc2lvbiBnaXZlbiBpbiB0aGUgdmFsdWVcclxuICogICAgICAgICAgICAgIGV2YWx1YXRlcyB0byBhIHRydXRoeSB2YWx1ZSwgb3RoZXJ3aXNlIHRoZXkgYXJlIHJlbW92ZWQuXHJcbiAqXHJcbiAqIFxcQHN0YWJsZVxyXG4gKi9cclxudmFyIE5nQ2xhc3MgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IF9pdGVyYWJsZURpZmZlcnNcclxuICAgICAqIEBwYXJhbSB7P30gX2tleVZhbHVlRGlmZmVyc1xyXG4gICAgICogQHBhcmFtIHs/fSBfbmdFbFxyXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTmdDbGFzcyhfaXRlcmFibGVEaWZmZXJzLCBfa2V5VmFsdWVEaWZmZXJzLCBfbmdFbCwgX3JlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy5faXRlcmFibGVEaWZmZXJzID0gX2l0ZXJhYmxlRGlmZmVycztcclxuICAgICAgICB0aGlzLl9rZXlWYWx1ZURpZmZlcnMgPSBfa2V5VmFsdWVEaWZmZXJzO1xyXG4gICAgICAgIHRoaXMuX25nRWwgPSBfbmdFbDtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcclxuICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ2xhc3MucHJvdG90eXBlLCBcImtsYXNzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHZcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlJbml0aWFsQ2xhc3Nlcyh0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXMgPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB2LnNwbGl0KC9cXHMrLykgOiBbXTtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlJbml0aWFsQ2xhc3NlcyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2xhc3Nlcyh0aGlzLl9yYXdDbGFzcywgZmFsc2UpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ2xhc3MucHJvdG90eXBlLCBcIm5nQ2xhc3NcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xhc3Nlcyh0aGlzLl9yYXdDbGFzcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fa2V5VmFsdWVEaWZmZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9yYXdDbGFzcyA9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHYuc3BsaXQoL1xccysvKSA6IHY7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yYXdDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9hbmd1bGFyX2NvcmUuybVpc0xpc3RMaWtlSXRlcmFibGUodGhpcy5fcmF3Q2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlcmFibGVEaWZmZXIgPSB0aGlzLl9pdGVyYWJsZURpZmZlcnMuZmluZCh0aGlzLl9yYXdDbGFzcykuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlWYWx1ZURpZmZlciA9IHRoaXMuX2tleVZhbHVlRGlmZmVycy5maW5kKHRoaXMuX3Jhd0NsYXNzKS5jcmVhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2l0ZXJhYmxlRGlmZmVyKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGl0ZXJhYmxlQ2hhbmdlcyA9IHRoaXMuX2l0ZXJhYmxlRGlmZmVyLmRpZmYoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5fcmF3Q2xhc3MpKTtcclxuICAgICAgICAgICAgaWYgKGl0ZXJhYmxlQ2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlJdGVyYWJsZUNoYW5nZXMoaXRlcmFibGVDaGFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9rZXlWYWx1ZURpZmZlcikge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlWYWx1ZUNoYW5nZXMgPSB0aGlzLl9rZXlWYWx1ZURpZmZlci5kaWZmKC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuX3Jhd0NsYXNzKSk7XHJcbiAgICAgICAgICAgIGlmIChrZXlWYWx1ZUNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5S2V5VmFsdWVDaGFuZ2VzKGtleVZhbHVlQ2hhbmdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHJhd0NsYXNzVmFsXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5fY2xlYW51cENsYXNzZXMgPSBmdW5jdGlvbiAocmF3Q2xhc3NWYWwpIHtcclxuICAgICAgICB0aGlzLl9hcHBseUNsYXNzZXMocmF3Q2xhc3NWYWwsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuX2FwcGx5SW5pdGlhbENsYXNzZXMoZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5fYXBwbHlLZXlWYWx1ZUNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgcmV0dXJuIF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQua2V5LCByZWNvcmQuY3VycmVudFZhbHVlKTsgfSk7XHJcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoQ2hhbmdlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5rZXksIHJlY29yZC5jdXJyZW50VmFsdWUpOyB9KTtcclxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWNvcmQucHJldmlvdXNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5rZXksIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5fYXBwbHlJdGVyYWJsZUNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZWNvcmQuaXRlbSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQuaXRlbSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZ0NsYXNzIGNhbiBvbmx5IHRvZ2dsZSBDU1MgY2xhc3NlcyBleHByZXNzZWQgYXMgc3RyaW5ncywgZ290IFwiICsgX2FuZ3VsYXJfY29yZS7JtXN0cmluZ2lmeShyZWNvcmQuaXRlbSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5pdGVtLCBmYWxzZSk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpc0NsZWFudXBcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nQ2xhc3MucHJvdG90eXBlLl9hcHBseUluaXRpYWxDbGFzc2VzID0gZnVuY3Rpb24gKGlzQ2xlYW51cCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoa2xhc3MpIHsgcmV0dXJuIF90aGlzLl90b2dnbGVDbGFzcyhrbGFzcywgIWlzQ2xlYW51cCk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSByYXdDbGFzc1ZhbFxyXG4gICAgICogQHBhcmFtIHs/fSBpc0NsZWFudXBcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nQ2xhc3MucHJvdG90eXBlLl9hcHBseUNsYXNzZXMgPSBmdW5jdGlvbiAocmF3Q2xhc3NWYWwsIGlzQ2xlYW51cCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHJhd0NsYXNzVmFsKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd0NsYXNzVmFsKSB8fCByYXdDbGFzc1ZhbCBpbnN0YW5jZW9mIFNldCkge1xyXG4gICAgICAgICAgICAgICAgKChyYXdDbGFzc1ZhbCkpLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3Moa2xhc3MsICFpc0NsZWFudXApOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJhd0NsYXNzVmFsKS5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdDbGFzc1ZhbFtrbGFzc10gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RvZ2dsZUNsYXNzKGtsYXNzLCAhaXNDbGVhbnVwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBrbGFzc1xyXG4gICAgICogQHBhcmFtIHs/fSBlbmFibGVkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5fdG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiAoa2xhc3MsIGVuYWJsZWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGtsYXNzID0ga2xhc3MudHJpbSgpO1xyXG4gICAgICAgIGlmIChrbGFzcykge1xyXG4gICAgICAgICAgICBrbGFzcy5zcGxpdCgvXFxzKy9nKS5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykgeyBfdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKF90aGlzLl9uZ0VsLm5hdGl2ZUVsZW1lbnQsIGtsYXNzLCAhIWVuYWJsZWQpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5nQ2xhc3M7XHJcbn0oKSk7XHJcbk5nQ2xhc3MuZGVjb3JhdG9ycyA9IFtcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nQ2xhc3NdJyB9LF0gfSxcclxuXTtcclxuLyoqXHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5OZ0NsYXNzLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkl0ZXJhYmxlRGlmZmVycywgfSxcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5LZXlWYWx1ZURpZmZlcnMsIH0sXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcclxuXTsgfTtcclxuTmdDbGFzcy5wcm9wRGVjb3JhdG9ycyA9IHtcclxuICAgICdrbGFzcyc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnY2xhc3MnLF0gfSxdLFxyXG4gICAgJ25nQ2xhc3MnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcclxufTtcclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogSW5zdGFudGlhdGVzIGEgc2luZ2xlIHtcXEBsaW5rIENvbXBvbmVudH0gdHlwZSBhbmQgaW5zZXJ0cyBpdHMgSG9zdCBWaWV3IGludG8gY3VycmVudCBWaWV3LlxyXG4gKiBgTmdDb21wb25lbnRPdXRsZXRgIHByb3ZpZGVzIGEgZGVjbGFyYXRpdmUgYXBwcm9hY2ggZm9yIGR5bmFtaWMgY29tcG9uZW50IGNyZWF0aW9uLlxyXG4gKlxyXG4gKiBgTmdDb21wb25lbnRPdXRsZXRgIHJlcXVpcmVzIGEgY29tcG9uZW50IHR5cGUsIGlmIGEgZmFsc3kgdmFsdWUgaXMgc2V0IHRoZSB2aWV3IHdpbGwgY2xlYXIgYW5kXHJcbiAqIGFueSBleGlzdGluZyBjb21wb25lbnQgd2lsbCBnZXQgZGVzdHJveWVkLlxyXG4gKlxyXG4gKiAjIyMgRmluZSB0dW5lIGNvbnRyb2xcclxuICpcclxuICogWW91IGNhbiBjb250cm9sIHRoZSBjb21wb25lbnQgY3JlYXRpb24gcHJvY2VzcyBieSB1c2luZyB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIGF0dHJpYnV0ZXM6XHJcbiAqXHJcbiAqICogYG5nQ29tcG9uZW50T3V0bGV0SW5qZWN0b3JgOiBPcHRpb25hbCBjdXN0b20ge1xcQGxpbmsgSW5qZWN0b3J9IHRoYXQgd2lsbCBiZSB1c2VkIGFzIHBhcmVudCBmb3JcclxuICogdGhlIENvbXBvbmVudC4gRGVmYXVsdHMgdG8gdGhlIGluamVjdG9yIG9mIHRoZSBjdXJyZW50IHZpZXcgY29udGFpbmVyLlxyXG4gKlxyXG4gKiAqIGBuZ0NvbXBvbmVudE91dGxldENvbnRlbnRgOiBPcHRpb25hbCBsaXN0IG9mIHByb2plY3RhYmxlIG5vZGVzIHRvIGluc2VydCBpbnRvIHRoZSBjb250ZW50XHJcbiAqIHNlY3Rpb24gb2YgdGhlIGNvbXBvbmVudCwgaWYgZXhpc3RzLlxyXG4gKlxyXG4gKiAqIGBuZ0NvbXBvbmVudE91dGxldE5nTW9kdWxlRmFjdG9yeWA6IE9wdGlvbmFsIG1vZHVsZSBmYWN0b3J5IHRvIGFsbG93IGR5bmFtaWNhbGx5IGxvYWRpbmcgb3RoZXJcclxuICogbW9kdWxlLCB0aGVuIGxvYWQgYSBjb21wb25lbnQgZnJvbSB0aGF0IG1vZHVsZS5cclxuICpcclxuICogIyMjIFN5bnRheFxyXG4gKlxyXG4gKiBTaW1wbGVcclxuICogYGBgXHJcbiAqIDxuZy1jb250YWluZXIgKm5nQ29tcG9uZW50T3V0bGV0PVwiY29tcG9uZW50VHlwZUV4cHJlc3Npb25cIj48L25nLWNvbnRhaW5lcj5cclxuICogYGBgXHJcbiAqXHJcbiAqIEN1c3RvbWl6ZWQgaW5qZWN0b3IvY29udGVudFxyXG4gKiBgYGBcclxuICogPG5nLWNvbnRhaW5lciAqbmdDb21wb25lbnRPdXRsZXQ9XCJjb21wb25lbnRUeXBlRXhwcmVzc2lvbjtcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluamVjdG9yOiBpbmplY3RvckV4cHJlc3Npb247XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50Tm9kZXNFeHByZXNzaW9uO1wiPlxyXG4gKiA8L25nLWNvbnRhaW5lcj5cclxuICogYGBgXHJcbiAqXHJcbiAqIEN1c3RvbWl6ZWQgbmdNb2R1bGVGYWN0b3J5XHJcbiAqIGBgYFxyXG4gKiA8bmctY29udGFpbmVyICpuZ0NvbXBvbmVudE91dGxldD1cImNvbXBvbmVudFR5cGVFeHByZXNzaW9uO1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5OiBtb2R1bGVGYWN0b3J5O1wiPlxyXG4gKiA8L25nLWNvbnRhaW5lcj5cclxuICogYGBgXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICoge1xcQGV4YW1wbGUgY29tbW9uL25nQ29tcG9uZW50T3V0bGV0L3RzL21vZHVsZS50cyByZWdpb249J1NpbXBsZUV4YW1wbGUnfVxyXG4gKlxyXG4gKiBBIG1vcmUgY29tcGxldGUgZXhhbXBsZSB3aXRoIGFkZGl0aW9uYWwgb3B0aW9uczpcclxuICpcclxuICoge1xcQGV4YW1wbGUgY29tbW9uL25nQ29tcG9uZW50T3V0bGV0L3RzL21vZHVsZS50cyByZWdpb249J0NvbXBsZXRlRXhhbXBsZSd9XHJcbiAqIEEgbW9yZSBjb21wbGV0ZSBleGFtcGxlIHdpdGggbmdNb2R1bGVGYWN0b3J5OlxyXG4gKlxyXG4gKiB7XFxAZXhhbXBsZSBjb21tb24vbmdDb21wb25lbnRPdXRsZXQvdHMvbW9kdWxlLnRzIHJlZ2lvbj0nTmdNb2R1bGVGYWN0b3J5RXhhbXBsZSd9XHJcbiAqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxudmFyIE5nQ29tcG9uZW50T3V0bGV0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBfdmlld0NvbnRhaW5lclJlZlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBOZ0NvbXBvbmVudE91dGxldChfdmlld0NvbnRhaW5lclJlZikge1xyXG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcclxuICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX21vZHVsZVJlZiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdDb21wb25lbnRPdXRsZXQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fY29tcG9uZW50UmVmID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5uZ0NvbXBvbmVudE91dGxldCkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbEluamVjdG9yID0gdGhpcy5uZ0NvbXBvbmVudE91dGxldEluamVjdG9yIHx8IHRoaXMuX3ZpZXdDb250YWluZXJSZWYucGFyZW50SW5qZWN0b3I7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzWyduZ0NvbXBvbmVudE91dGxldE5nTW9kdWxlRmFjdG9yeSddKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kdWxlUmVmKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vZHVsZVJlZi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZ0NvbXBvbmVudE91dGxldE5nTW9kdWxlRmFjdG9yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudE1vZHVsZSA9IGVsSW5qZWN0b3IuZ2V0KF9hbmd1bGFyX2NvcmUuTmdNb2R1bGVSZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vZHVsZVJlZiA9IHRoaXMubmdDb21wb25lbnRPdXRsZXROZ01vZHVsZUZhY3RvcnkuY3JlYXRlKHBhcmVudE1vZHVsZS5pbmplY3Rvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb2R1bGVSZWYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IHRoaXMuX21vZHVsZVJlZiA/IHRoaXMuX21vZHVsZVJlZi5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgOlxyXG4gICAgICAgICAgICAgICAgZWxJbmplY3Rvci5nZXQoX2FuZ3VsYXJfY29yZS5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRGYWN0b3J5ID0gY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KHRoaXMubmdDb21wb25lbnRPdXRsZXQpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYgPSB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChjb21wb25lbnRGYWN0b3J5LCB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmxlbmd0aCwgZWxJbmplY3RvciwgdGhpcy5uZ0NvbXBvbmVudE91dGxldENvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nQ29tcG9uZW50T3V0bGV0LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fbW9kdWxlUmVmKVxyXG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVSZWYuZGVzdHJveSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBOZ0NvbXBvbmVudE91dGxldDtcclxufSgpKTtcclxuTmdDb21wb25lbnRPdXRsZXQuZGVjb3JhdG9ycyA9IFtcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nQ29tcG9uZW50T3V0bGV0XScgfSxdIH0sXHJcbl07XHJcbi8qKlxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuTmdDb21wb25lbnRPdXRsZXQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZiwgfSxcclxuXTsgfTtcclxuTmdDb21wb25lbnRPdXRsZXQucHJvcERlY29yYXRvcnMgPSB7XHJcbiAgICAnbmdDb21wb25lbnRPdXRsZXQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcclxuICAgICduZ0NvbXBvbmVudE91dGxldEluamVjdG9yJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXHJcbiAgICAnbmdDb21wb25lbnRPdXRsZXRDb250ZW50JzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXHJcbiAgICAnbmdDb21wb25lbnRPdXRsZXROZ01vZHVsZUZhY3RvcnknOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcclxufTtcclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogXFxAc3RhYmxlXHJcbiAqL1xyXG52YXIgTmdGb3JPZkNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99ICRpbXBsaWNpdFxyXG4gICAgICogQHBhcmFtIHs/fSBuZ0Zvck9mXHJcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XHJcbiAgICAgKiBAcGFyYW0gez99IGNvdW50XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE5nRm9yT2ZDb250ZXh0KCRpbXBsaWNpdCwgbmdGb3JPZiwgaW5kZXgsIGNvdW50KSB7XHJcbiAgICAgICAgdGhpcy4kaW1wbGljaXQgPSAkaW1wbGljaXQ7XHJcbiAgICAgICAgdGhpcy5uZ0Zvck9mID0gbmdGb3JPZjtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yT2ZDb250ZXh0LnByb3RvdHlwZSwgXCJmaXJzdFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPT09IDA7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yT2ZDb250ZXh0LnByb3RvdHlwZSwgXCJsYXN0XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbmRleCA9PT0gdGhpcy5jb3VudCAtIDE7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yT2ZDb250ZXh0LnByb3RvdHlwZSwgXCJldmVuXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbmRleCAlIDIgPT09IDA7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yT2ZDb250ZXh0LnByb3RvdHlwZSwgXCJvZGRcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5ldmVuOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBOZ0Zvck9mQ29udGV4dDtcclxufSgpKTtcclxuLyoqXHJcbiAqIFRoZSBgTmdGb3JPZmAgZGlyZWN0aXZlIGluc3RhbnRpYXRlcyBhIHRlbXBsYXRlIG9uY2UgcGVyIGl0ZW0gZnJvbSBhbiBpdGVyYWJsZS4gVGhlIGNvbnRleHRcclxuICogZm9yIGVhY2ggaW5zdGFudGlhdGVkIHRlbXBsYXRlIGluaGVyaXRzIGZyb20gdGhlIG91dGVyIGNvbnRleHQgd2l0aCB0aGUgZ2l2ZW4gbG9vcCB2YXJpYWJsZVxyXG4gKiBzZXQgdG8gdGhlIGN1cnJlbnQgaXRlbSBmcm9tIHRoZSBpdGVyYWJsZS5cclxuICpcclxuICogIyMjIExvY2FsIFZhcmlhYmxlc1xyXG4gKlxyXG4gKiBgTmdGb3JPZmAgcHJvdmlkZXMgc2V2ZXJhbCBleHBvcnRlZCB2YWx1ZXMgdGhhdCBjYW4gYmUgYWxpYXNlZCB0byBsb2NhbCB2YXJpYWJsZXM6XHJcbiAqXHJcbiAqIC0gYCRpbXBsaWNpdDogVGA6IFRoZSB2YWx1ZSBvZiB0aGUgaW5kaXZpZHVhbCBpdGVtcyBpbiB0aGUgaXRlcmFibGUgKGBuZ0Zvck9mYCkuXHJcbiAqIC0gYG5nRm9yT2Y6IE5nSXRlcmFibGU8VD5gOiBUaGUgdmFsdWUgb2YgdGhlIGl0ZXJhYmxlIGV4cHJlc3Npb24uIFVzZWZ1bCB3aGVuIHRoZSBleHByZXNzaW9uIGlzXHJcbiAqIG1vcmUgY29tcGxleCB0aGVuIGEgcHJvcGVydHkgYWNjZXNzLCBmb3IgZXhhbXBsZSB3aGVuIHVzaW5nIHRoZSBhc3luYyBwaXBlIChgdXNlclN0cmVhbXMgfFxyXG4gKiBhc3luY2ApLlxyXG4gKiAtIGBpbmRleDogbnVtYmVyYDogVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGl0ZW0gaW4gdGhlIGl0ZXJhYmxlLlxyXG4gKiAtIGBmaXJzdDogYm9vbGVhbmA6IFRydWUgd2hlbiB0aGUgaXRlbSBpcyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgaXRlcmFibGUuXHJcbiAqIC0gYGxhc3Q6IGJvb2xlYW5gOiBUcnVlIHdoZW4gdGhlIGl0ZW0gaXMgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaXRlcmFibGUuXHJcbiAqIC0gYGV2ZW46IGJvb2xlYW5gOiBUcnVlIHdoZW4gdGhlIGl0ZW0gaGFzIGFuIGV2ZW4gaW5kZXggaW4gdGhlIGl0ZXJhYmxlLlxyXG4gKiAtIGBvZGQ6IGJvb2xlYW5gOiBUcnVlIHdoZW4gdGhlIGl0ZW0gaGFzIGFuIG9kZCBpbmRleCBpbiB0aGUgaXRlcmFibGUuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8bGkgKm5nRm9yPVwibGV0IHVzZXIgb2YgdXNlck9ic2VydmFibGUgfCBhc3luYyBhcyB1c2VyczsgaW5kZXggYXMgaTsgZmlyc3QgYXMgaXNGaXJzdFwiPlxyXG4gKiAgICB7e2l9fS97e3VzZXJzLmxlbmd0aH19LiB7e3VzZXJ9fSA8c3BhbiAqbmdJZj1cImlzRmlyc3RcIj5kZWZhdWx0PC9zcGFuPlxyXG4gKiA8L2xpPlxyXG4gKiBgYGBcclxuICpcclxuICogIyMjIENoYW5nZSBQcm9wYWdhdGlvblxyXG4gKlxyXG4gKiBXaGVuIHRoZSBjb250ZW50cyBvZiB0aGUgaXRlcmF0b3IgY2hhbmdlcywgYE5nRm9yT2ZgIG1ha2VzIHRoZSBjb3JyZXNwb25kaW5nIGNoYW5nZXMgdG8gdGhlIERPTTpcclxuICpcclxuICogKiBXaGVuIGFuIGl0ZW0gaXMgYWRkZWQsIGEgbmV3IGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBpcyBhZGRlZCB0byB0aGUgRE9NLlxyXG4gKiAqIFdoZW4gYW4gaXRlbSBpcyByZW1vdmVkLCBpdHMgdGVtcGxhdGUgaW5zdGFuY2UgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uXHJcbiAqICogV2hlbiBpdGVtcyBhcmUgcmVvcmRlcmVkLCB0aGVpciByZXNwZWN0aXZlIHRlbXBsYXRlcyBhcmUgcmVvcmRlcmVkIGluIHRoZSBET00uXHJcbiAqICogT3RoZXJ3aXNlLCB0aGUgRE9NIGVsZW1lbnQgZm9yIHRoYXQgaXRlbSB3aWxsIHJlbWFpbiB0aGUgc2FtZS5cclxuICpcclxuICogQW5ndWxhciB1c2VzIG9iamVjdCBpZGVudGl0eSB0byB0cmFjayBpbnNlcnRpb25zIGFuZCBkZWxldGlvbnMgd2l0aGluIHRoZSBpdGVyYXRvciBhbmQgcmVwcm9kdWNlXHJcbiAqIHRob3NlIGNoYW5nZXMgaW4gdGhlIERPTS4gVGhpcyBoYXMgaW1wb3J0YW50IGltcGxpY2F0aW9ucyBmb3IgYW5pbWF0aW9ucyBhbmQgYW55IHN0YXRlZnVsXHJcbiAqIGNvbnRyb2xzIChzdWNoIGFzIGA8aW5wdXQ+YCBlbGVtZW50cyB3aGljaCBhY2NlcHQgdXNlciBpbnB1dCkgdGhhdCBhcmUgcHJlc2VudC4gSW5zZXJ0ZWQgcm93cyBjYW5cclxuICogYmUgYW5pbWF0ZWQgaW4sIGRlbGV0ZWQgcm93cyBjYW4gYmUgYW5pbWF0ZWQgb3V0LCBhbmQgdW5jaGFuZ2VkIHJvd3MgcmV0YWluIGFueSB1bnNhdmVkIHN0YXRlXHJcbiAqIHN1Y2ggYXMgdXNlciBpbnB1dC5cclxuICpcclxuICogSXQgaXMgcG9zc2libGUgZm9yIHRoZSBpZGVudGl0aWVzIG9mIGVsZW1lbnRzIGluIHRoZSBpdGVyYXRvciB0byBjaGFuZ2Ugd2hpbGUgdGhlIGRhdGEgZG9lcyBub3QuXHJcbiAqIFRoaXMgY2FuIGhhcHBlbiwgZm9yIGV4YW1wbGUsIGlmIHRoZSBpdGVyYXRvciBwcm9kdWNlZCBmcm9tIGFuIFJQQyB0byB0aGUgc2VydmVyLCBhbmQgdGhhdFxyXG4gKiBSUEMgaXMgcmUtcnVuLiBFdmVuIGlmIHRoZSBkYXRhIGhhc24ndCBjaGFuZ2VkLCB0aGUgc2Vjb25kIHJlc3BvbnNlIHdpbGwgcHJvZHVjZSBvYmplY3RzIHdpdGhcclxuICogZGlmZmVyZW50IGlkZW50aXRpZXMsIGFuZCBBbmd1bGFyIHdpbGwgdGVhciBkb3duIHRoZSBlbnRpcmUgRE9NIGFuZCByZWJ1aWxkIGl0IChhcyBpZiBhbGwgb2xkXHJcbiAqIGVsZW1lbnRzIHdlcmUgZGVsZXRlZCBhbmQgYWxsIG5ldyBlbGVtZW50cyBpbnNlcnRlZCkuIFRoaXMgaXMgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbiBhbmQgc2hvdWxkXHJcbiAqIGJlIGF2b2lkZWQgaWYgcG9zc2libGUuXHJcbiAqXHJcbiAqIFRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCB0cmFja2luZyBhbGdvcml0aG0sIGBOZ0Zvck9mYCBzdXBwb3J0cyBgdHJhY2tCeWAgb3B0aW9uLlxyXG4gKiBgdHJhY2tCeWAgdGFrZXMgYSBmdW5jdGlvbiB3aGljaCBoYXMgdHdvIGFyZ3VtZW50czogYGluZGV4YCBhbmQgYGl0ZW1gLlxyXG4gKiBJZiBgdHJhY2tCeWAgaXMgZ2l2ZW4sIEFuZ3VsYXIgdHJhY2tzIGNoYW5nZXMgYnkgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24uXHJcbiAqXHJcbiAqICMjIyBTeW50YXhcclxuICpcclxuICogLSBgPGxpICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBpbmRleCBhcyBpOyB0cmFja0J5OiB0cmFja0J5Rm5cIj4uLi48L2xpPmBcclxuICogLSBgPGxpIHRlbXBsYXRlPVwibmdGb3IgbGV0IGl0ZW0gb2YgaXRlbXM7IGluZGV4IGFzIGk7IHRyYWNrQnk6IHRyYWNrQnlGblwiPi4uLjwvbGk+YFxyXG4gKlxyXG4gKiBXaXRoIGA8bmctdGVtcGxhdGU+YCBlbGVtZW50OlxyXG4gKlxyXG4gKiBgYGBcclxuICogPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cIml0ZW1zXCIgbGV0LWk9XCJpbmRleFwiIFtuZ0ZvclRyYWNrQnldPVwidHJhY2tCeUZuXCI+XHJcbiAqICAgPGxpPi4uLjwvbGk+XHJcbiAqIDwvbmctdGVtcGxhdGU+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBTZWUgYSBbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LVnVYeERwMHFpbkdEeW8zMDdRVz9wPXByZXZpZXcpIGZvciBhIG1vcmUgZGV0YWlsZWRcclxuICogZXhhbXBsZS5cclxuICpcclxuICogXFxAc3RhYmxlXHJcbiAqL1xyXG52YXIgTmdGb3JPZiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gX3ZpZXdDb250YWluZXJcclxuICAgICAqIEBwYXJhbSB7P30gX3RlbXBsYXRlXHJcbiAgICAgKiBAcGFyYW0gez99IF9kaWZmZXJzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE5nRm9yT2YoX3ZpZXdDb250YWluZXIsIF90ZW1wbGF0ZSwgX2RpZmZlcnMpIHtcclxuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyID0gX3ZpZXdDb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBfdGVtcGxhdGU7XHJcbiAgICAgICAgdGhpcy5fZGlmZmVycyA9IF9kaWZmZXJzO1xyXG4gICAgICAgIHRoaXMuX2RpZmZlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JPZi5wcm90b3R5cGUsIFwibmdGb3JUcmFja0J5XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdHJhY2tCeUZuOyB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgIGlmIChfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpICYmIGZuICE9IG51bGwgJiYgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiB1c2UgYSBsb2cgc2VydmljZSBvbmNlIHRoZXJlIGlzIGEgcHVibGljIG9uZSBhdmFpbGFibGVcclxuICAgICAgICAgICAgICAgIGlmICgoY29uc29sZSkgJiYgKGNvbnNvbGUud2FybikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ0cmFja0J5IG11c3QgYmUgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkoZm4pICsgXCIuIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2RvY3MvdHMvbGF0ZXN0L2FwaS9jb21tb24vaW5kZXgvTmdGb3ItZGlyZWN0aXZlLmh0bWwjISNjaGFuZ2UtcHJvcGFnYXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrQnlGbiA9IGZuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yT2YucHJvdG90eXBlLCBcIm5nRm9yVGVtcGxhdGVcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8oVFMyLjEpOiBtYWtlIFRlbXBsYXRlUmVmPFBhcnRpYWw8TmdGb3JSb3dPZjxUPj4+IG9uY2Ugd2UgbW92ZSB0byBUUyB2Mi4xXHJcbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHR5cGUgaXMgdG9vIHJlc3RyaWN0aXZlOyBhIHRlbXBsYXRlIHRoYXQganVzdCB1c2VzIGluZGV4LCBmb3IgZXhhbXBsZSxcclxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGFjY2VwdGFibGUuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nRm9yT2YucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoJ25nRm9yT2YnIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgLy8gUmVhY3Qgb24gbmdGb3JPZiBjaGFuZ2VzIG9ubHkgb25jZSBhbGwgaW5wdXRzIGhhdmUgYmVlbiBpbml0aWFsaXplZFxyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGNoYW5nZXNbJ25nRm9yT2YnXS5jdXJyZW50VmFsdWU7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGlmZmVyICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZCh2YWx1ZSkuY3JlYXRlKHRoaXMubmdGb3JUcmFja0J5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgJ1wiICsgdmFsdWUgKyBcIicgb2YgdHlwZSAnXCIgKyBnZXRUeXBlTmFtZUZvckRlYnVnZ2luZyh2YWx1ZSkgKyBcIicuIE5nRm9yIG9ubHkgc3VwcG9ydHMgYmluZGluZyB0byBJdGVyYWJsZXMgc3VjaCBhcyBBcnJheXMuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdGb3JPZi5wcm90b3R5cGUubmdEb0NoZWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaWZmZXIpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMubmdGb3JPZik7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2VzKGNoYW5nZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdGb3JPZi5wcm90b3R5cGUuX2FwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnNlcnRUdXBsZXMgPSBbXTtcclxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hPcGVyYXRpb24oZnVuY3Rpb24gKGl0ZW0sIGFkanVzdGVkUHJldmlvdXNJbmRleCwgY3VycmVudEluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLnByZXZpb3VzSW5kZXggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlldyA9IF90aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyhfdGhpcy5fdGVtcGxhdGUsIG5ldyBOZ0Zvck9mQ29udGV4dCgvKiogQHR5cGUgez99ICovICgobnVsbCkpLCBfdGhpcy5uZ0Zvck9mLCAtMSwgLTEpLCBjdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHVwbGUgPSBuZXcgUmVjb3JkVmlld1R1cGxlKGl0ZW0sIHZpZXcpO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0VHVwbGVzLnB1c2godHVwbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJbmRleCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fdmlld0NvbnRhaW5lci5yZW1vdmUoYWRqdXN0ZWRQcmV2aW91c0luZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXcgPSAoKF90aGlzLl92aWV3Q29udGFpbmVyLmdldChhZGp1c3RlZFByZXZpb3VzSW5kZXgpKSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fdmlld0NvbnRhaW5lci5tb3ZlKHZpZXcsIGN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0dXBsZSA9IG5ldyBSZWNvcmRWaWV3VHVwbGUoaXRlbSwgLyoqIEB0eXBlIHs/fSAqLyAodmlldykpO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0VHVwbGVzLnB1c2godHVwbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGluc2VydFR1cGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9wZXJWaWV3Q2hhbmdlKGluc2VydFR1cGxlc1tpXS52aWV3LCBpbnNlcnRUdXBsZXNbaV0ucmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMCwgLyoqIEB0eXBlIHs/fSAqLyBpbGVuID0gdGhpcy5fdmlld0NvbnRhaW5lci5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld1JlZiA9ICh0aGlzLl92aWV3Q29udGFpbmVyLmdldChpKSk7XHJcbiAgICAgICAgICAgIHZpZXdSZWYuY29udGV4dC5pbmRleCA9IGk7XHJcbiAgICAgICAgICAgIHZpZXdSZWYuY29udGV4dC5jb3VudCA9IGlsZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaElkZW50aXR5Q2hhbmdlKGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld1JlZiA9IChfdGhpcy5fdmlld0NvbnRhaW5lci5nZXQocmVjb3JkLmN1cnJlbnRJbmRleCkpO1xyXG4gICAgICAgICAgICB2aWV3UmVmLmNvbnRleHQuJGltcGxpY2l0ID0gcmVjb3JkLml0ZW07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHZpZXdcclxuICAgICAqIEBwYXJhbSB7P30gcmVjb3JkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ0Zvck9mLnByb3RvdHlwZS5fcGVyVmlld0NoYW5nZSA9IGZ1bmN0aW9uICh2aWV3LCByZWNvcmQpIHtcclxuICAgICAgICB2aWV3LmNvbnRleHQuJGltcGxpY2l0ID0gcmVjb3JkLml0ZW07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5nRm9yT2Y7XHJcbn0oKSk7XHJcbk5nRm9yT2YuZGVjb3JhdG9ycyA9IFtcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nRm9yXVtuZ0Zvck9mXScgfSxdIH0sXHJcbl07XHJcbi8qKlxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuTmdGb3JPZi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmLCB9LFxyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkl0ZXJhYmxlRGlmZmVycywgfSxcclxuXTsgfTtcclxuTmdGb3JPZi5wcm9wRGVjb3JhdG9ycyA9IHtcclxuICAgICduZ0Zvck9mJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXHJcbiAgICAnbmdGb3JUcmFja0J5JzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXHJcbiAgICAnbmdGb3JUZW1wbGF0ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG59O1xyXG52YXIgUmVjb3JkVmlld1R1cGxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSByZWNvcmRcclxuICAgICAqIEBwYXJhbSB7P30gdmlld1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZWNvcmRWaWV3VHVwbGUocmVjb3JkLCB2aWV3KSB7XHJcbiAgICAgICAgdGhpcy5yZWNvcmQgPSByZWNvcmQ7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgIH1cclxuICAgIHJldHVybiBSZWNvcmRWaWV3VHVwbGU7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHR5cGVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGdldFR5cGVOYW1lRm9yRGVidWdnaW5nKHR5cGUpIHtcclxuICAgIHJldHVybiB0eXBlWyduYW1lJ10gfHwgdHlwZW9mIHR5cGU7XHJcbn1cclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogQ29uZGl0aW9uYWxseSBpbmNsdWRlcyBhIHRlbXBsYXRlIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiBhbiBgZXhwcmVzc2lvbmAuXHJcbiAqXHJcbiAqIGBuZ0lmYCBldmFsdWF0ZXMgdGhlIGBleHByZXNzaW9uYCBhbmQgdGhlbiByZW5kZXJzIHRoZSBgdGhlbmAgb3IgYGVsc2VgIHRlbXBsYXRlIGluIGl0cyBwbGFjZVxyXG4gKiB3aGVuIGV4cHJlc3Npb24gaXMgdHJ1dGh5IG9yIGZhbHN5IHJlc3BlY3RpdmVseS4gVHlwaWNhbGx5IHRoZTpcclxuICogIC0gYHRoZW5gIHRlbXBsYXRlIGlzIHRoZSBpbmxpbmUgdGVtcGxhdGUgb2YgYG5nSWZgIHVubGVzcyBib3VuZCB0byBhIGRpZmZlcmVudCB2YWx1ZS5cclxuICogIC0gYGVsc2VgIHRlbXBsYXRlIGlzIGJsYW5rIHVubGVzcyBpdCBpcyBib3VuZC5cclxuICpcclxuICogIyMgTW9zdCBjb21tb24gdXNhZ2VcclxuICpcclxuICogVGhlIG1vc3QgY29tbW9uIHVzYWdlIG9mIHRoZSBgbmdJZmAgZGlyZWN0aXZlIGlzIHRvIGNvbmRpdGlvbmFsbHkgc2hvdyB0aGUgaW5saW5lIHRlbXBsYXRlIGFzXHJcbiAqIHNlZW4gaW4gdGhpcyBleGFtcGxlOlxyXG4gKiB7XFxAZXhhbXBsZSBjb21tb24vbmdJZi90cy9tb2R1bGUudHMgcmVnaW9uPSdOZ0lmU2ltcGxlJ31cclxuICpcclxuICogIyMgU2hvd2luZyBhbiBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZSB1c2luZyBgZWxzZWBcclxuICpcclxuICogSWYgaXQgaXMgbmVjZXNzYXJ5IHRvIGRpc3BsYXkgYSB0ZW1wbGF0ZSB3aGVuIHRoZSBgZXhwcmVzc2lvbmAgaXMgZmFsc3kgdXNlIHRoZSBgZWxzZWAgdGVtcGxhdGVcclxuICogYmluZGluZyBhcyBzaG93bi4gTm90ZSB0aGF0IHRoZSBgZWxzZWAgYmluZGluZyBwb2ludHMgdG8gYSBgPG5nLXRlbXBsYXRlPmAgbGFiZWxlZCBgI2Vsc2VCbG9ja2AuXHJcbiAqIFRoZSB0ZW1wbGF0ZSBjYW4gYmUgZGVmaW5lZCBhbnl3aGVyZSBpbiB0aGUgY29tcG9uZW50IHZpZXcgYnV0IGlzIHR5cGljYWxseSBwbGFjZWQgcmlnaHQgYWZ0ZXJcclxuICogYG5nSWZgIGZvciByZWFkYWJpbGl0eS5cclxuICpcclxuICoge1xcQGV4YW1wbGUgY29tbW9uL25nSWYvdHMvbW9kdWxlLnRzIHJlZ2lvbj0nTmdJZkVsc2UnfVxyXG4gKlxyXG4gKiAjIyBVc2luZyBub24taW5saW5lZCBgdGhlbmAgdGVtcGxhdGVcclxuICpcclxuICogVXN1YWxseSB0aGUgYHRoZW5gIHRlbXBsYXRlIGlzIHRoZSBpbmxpbmVkIHRlbXBsYXRlIG9mIHRoZSBgbmdJZmAsIGJ1dCBpdCBjYW4gYmUgY2hhbmdlZCB1c2luZ1xyXG4gKiBhIGJpbmRpbmcgKGp1c3QgbGlrZSBgZWxzZWApLiBCZWNhdXNlIGB0aGVuYCBhbmQgYGVsc2VgIGFyZSBiaW5kaW5ncywgdGhlIHRlbXBsYXRlIHJlZmVyZW5jZXMgY2FuXHJcbiAqIGNoYW5nZSBhdCBydW50aW1lIGFzIHNob3duIGluIHRoaXMgZXhhbXBsZS5cclxuICpcclxuICoge1xcQGV4YW1wbGUgY29tbW9uL25nSWYvdHMvbW9kdWxlLnRzIHJlZ2lvbj0nTmdJZlRoZW5FbHNlJ31cclxuICpcclxuICogIyMgU3RvcmluZyBjb25kaXRpb25hbCByZXN1bHQgaW4gYSB2YXJpYWJsZVxyXG4gKlxyXG4gKiBBIGNvbW1vbiBwYXR0ZXJuIGlzIHRoYXQgd2UgbmVlZCB0byBzaG93IGEgc2V0IG9mIHByb3BlcnRpZXMgZnJvbSB0aGUgc2FtZSBvYmplY3QuIElmIHRoZVxyXG4gKiBvYmplY3QgaXMgdW5kZWZpbmVkLCB0aGVuIHdlIGhhdmUgdG8gdXNlIHRoZSBzYWZlLXRyYXZlcnNhbC1vcGVyYXRvciBgPy5gIHRvIGd1YXJkIGFnYWluc3RcclxuICogZGVyZWZlcmVuY2luZyBhIGBudWxsYCB2YWx1ZS4gVGhpcyBpcyBlc3BlY2lhbGx5IHRoZSBjYXNlIHdoZW4gd2FpdGluZyBvbiBhc3luYyBkYXRhIHN1Y2ggYXNcclxuICogd2hlbiB1c2luZyB0aGUgYGFzeW5jYCBwaXBlIGFzIHNob3duIGluIGZvbG93aW5nIGV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBIZWxsbyB7eyAodXNlclN0cmVhbXxhc3luYyk/Lmxhc3QgfX0sIHt7ICh1c2VyU3RyZWFtfGFzeW5jKT8uZmlyc3QgfX0hXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCBpbmVmZmljaWVuY2llcyBpbiB0aGUgYWJvdmUgZXhhbXBsZTpcclxuICogIC0gV2UgY3JlYXRlIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgb24gYHVzZXJTdHJlYW1gLiBPbmUgZm9yIGVhY2ggYGFzeW5jYCBwaXBlLCBvciB0d28gaW4gdGhlXHJcbiAqICAgIGV4YW1wbGUgYWJvdmUuXHJcbiAqICAtIFdlIGNhbm5vdCBkaXNwbGF5IGFuIGFsdGVybmF0aXZlIHNjcmVlbiB3aGlsZSB3YWl0aW5nIGZvciB0aGUgZGF0YSB0byBhcnJpdmUgYXN5bmNocm9ub3VzbHkuXHJcbiAqICAtIFdlIGhhdmUgdG8gdXNlIHRoZSBzYWZlLXRyYXZlcnNhbC1vcGVyYXRvciBgPy5gIHRvIGFjY2VzcyBwcm9wZXJ0aWVzLCB3aGljaCBpcyBjdW1iZXJzb21lLlxyXG4gKiAgLSBXZSBoYXZlIHRvIHBsYWNlIHRoZSBgYXN5bmNgIHBpcGUgaW4gcGFyZW50aGVzaXMuXHJcbiAqXHJcbiAqIEEgYmV0dGVyIHdheSB0byBkbyB0aGlzIGlzIHRvIHVzZSBgbmdJZmAgYW5kIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGNvbmRpdGlvbiBpbiBhIGxvY2FsXHJcbiAqIHZhcmlhYmxlIGFzIHNob3duIGluIHRoZSB0aGUgZXhhbXBsZSBiZWxvdzpcclxuICpcclxuICoge1xcQGV4YW1wbGUgY29tbW9uL25nSWYvdHMvbW9kdWxlLnRzIHJlZ2lvbj0nTmdJZkFzJ31cclxuICpcclxuICogTm90aWNlIHRoYXQ6XHJcbiAqICAtIFdlIHVzZSBvbmx5IG9uZSBgYXN5bmNgIHBpcGUgYW5kIGhlbmNlIG9ubHkgb25lIHN1YnNjcmlwdGlvbiBnZXRzIGNyZWF0ZWQuXHJcbiAqICAtIGBuZ0lmYCBzdG9yZXMgdGhlIHJlc3VsdCBvZiB0aGUgYHVzZXJTdHJlYW18YXN5bmNgIGluIHRoZSBsb2NhbCB2YXJpYWJsZSBgdXNlcmAuXHJcbiAqICAtIFRoZSBsb2NhbCBgdXNlcmAgY2FuIHRoZW4gYmUgYm91bmQgcmVwZWF0ZWRseSBpbiBhIG1vcmUgZWZmaWNpZW50IHdheS5cclxuICogIC0gTm8gbmVlZCB0byB1c2UgdGhlIHNhZmUtdHJhdmVyc2FsLW9wZXJhdG9yIGA/LmAgdG8gYWNjZXNzIHByb3BlcnRpZXMgYXMgYG5nSWZgIHdpbGwgb25seVxyXG4gKiAgICBkaXNwbGF5IHRoZSBkYXRhIGlmIGB1c2VyU3RyZWFtYCByZXR1cm5zIGEgdmFsdWUuXHJcbiAqICAtIFdlIGNhbiBkaXNwbGF5IGFuIGFsdGVybmF0aXZlIHRlbXBsYXRlIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBkYXRhLlxyXG4gKlxyXG4gKiAjIyMgU3ludGF4XHJcbiAqXHJcbiAqIFNpbXBsZSBmb3JtOlxyXG4gKiAtIGA8ZGl2ICpuZ0lmPVwiY29uZGl0aW9uXCI+Li4uPC9kaXY+YFxyXG4gKiAtIGA8ZGl2IHRlbXBsYXRlPVwibmdJZiBjb25kaXRpb25cIj4uLi48L2Rpdj5gXHJcbiAqIC0gYDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJjb25kaXRpb25cIj48ZGl2Pi4uLjwvZGl2PjwvbmctdGVtcGxhdGU+YFxyXG4gKlxyXG4gKiBGb3JtIHdpdGggYW4gZWxzZSBibG9jazpcclxuICogYGBgXHJcbiAqIDxkaXYgKm5nSWY9XCJjb25kaXRpb247IGVsc2UgZWxzZUJsb2NrXCI+Li4uPC9kaXY+XHJcbiAqIDxuZy10ZW1wbGF0ZSAjZWxzZUJsb2NrPi4uLjwvbmctdGVtcGxhdGU+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBGb3JtIHdpdGggYSBgdGhlbmAgYW5kIGBlbHNlYCBibG9jazpcclxuICogYGBgXHJcbiAqIDxkaXYgKm5nSWY9XCJjb25kaXRpb247IHRoZW4gdGhlbkJsb2NrIGVsc2UgZWxzZUJsb2NrXCI+PC9kaXY+XHJcbiAqIDxuZy10ZW1wbGF0ZSAjdGhlbkJsb2NrPi4uLjwvbmctdGVtcGxhdGU+XHJcbiAqIDxuZy10ZW1wbGF0ZSAjZWxzZUJsb2NrPi4uLjwvbmctdGVtcGxhdGU+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBGb3JtIHdpdGggc3RvcmluZyB0aGUgdmFsdWUgbG9jYWxseTpcclxuICogYGBgXHJcbiAqIDxkaXYgKm5nSWY9XCJjb25kaXRpb24gYXMgdmFsdWU7IGVsc2UgZWxzZUJsb2NrXCI+e3t2YWx1ZX19PC9kaXY+XHJcbiAqIDxuZy10ZW1wbGF0ZSAjZWxzZUJsb2NrPi4uLjwvbmctdGVtcGxhdGU+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBcXEBzdGFibGVcclxuICovXHJcbnZhciBOZ0lmID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBfdmlld0NvbnRhaW5lclxyXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVJlZlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBOZ0lmKF92aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZikge1xyXG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIgPSBfdmlld0NvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gbmV3IE5nSWZDb250ZXh0KCk7XHJcbiAgICAgICAgdGhpcy5fdGhlblRlbXBsYXRlUmVmID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9lbHNlVGVtcGxhdGVSZWYgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RoZW5WaWV3UmVmID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9lbHNlVmlld1JlZiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGhlblRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdJZi5wcm90b3R5cGUsIFwibmdJZlwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb25kaXRpb25cclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGNvbmRpdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LiRpbXBsaWNpdCA9IHRoaXMuX2NvbnRleHQubmdJZiA9IGNvbmRpdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmlldygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nSWYucHJvdG90eXBlLCBcIm5nSWZUaGVuXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlUmVmXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0ZW1wbGF0ZVJlZikge1xyXG4gICAgICAgICAgICB0aGlzLl90aGVuVGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcclxuICAgICAgICAgICAgdGhpcy5fdGhlblZpZXdSZWYgPSBudWxsOyAvLyBjbGVhciBwcmV2aW91cyB2aWV3IGlmIGFueS5cclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmlldygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nSWYucHJvdG90eXBlLCBcIm5nSWZFbHNlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlUmVmXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0ZW1wbGF0ZVJlZikge1xyXG4gICAgICAgICAgICB0aGlzLl9lbHNlVGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcclxuICAgICAgICAgICAgdGhpcy5fZWxzZVZpZXdSZWYgPSBudWxsOyAvLyBjbGVhciBwcmV2aW91cyB2aWV3IGlmIGFueS5cclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmlldygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ0lmLnByb3RvdHlwZS5fdXBkYXRlVmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fY29udGV4dC4kaW1wbGljaXQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl90aGVuVmlld1JlZikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxzZVZpZXdSZWYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RoZW5UZW1wbGF0ZVJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RoZW5WaWV3UmVmID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGhlblRlbXBsYXRlUmVmLCB0aGlzLl9jb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9lbHNlVmlld1JlZikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGhlblZpZXdSZWYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Vsc2VUZW1wbGF0ZVJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vsc2VWaWV3UmVmID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fZWxzZVRlbXBsYXRlUmVmLCB0aGlzLl9jb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTmdJZjtcclxufSgpKTtcclxuTmdJZi5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdJZl0nIH0sXSB9LFxyXG5dO1xyXG4vKipcclxuICogQG5vY29sbGFwc2VcclxuICovXHJcbk5nSWYuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZiwgfSxcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgfSxcclxuXTsgfTtcclxuTmdJZi5wcm9wRGVjb3JhdG9ycyA9IHtcclxuICAgICduZ0lmJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXHJcbiAgICAnbmdJZlRoZW4nOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcclxuICAgICduZ0lmRWxzZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG59O1xyXG4vKipcclxuICogXFxAc3RhYmxlXHJcbiAqL1xyXG52YXIgTmdJZkNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdJZkNvbnRleHQoKSB7XHJcbiAgICAgICAgdGhpcy4kaW1wbGljaXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubmdJZiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTmdJZkNvbnRleHQ7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxudmFyIFN3aXRjaFZpZXcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IF92aWV3Q29udGFpbmVyUmVmXHJcbiAgICAgKiBAcGFyYW0gez99IF90ZW1wbGF0ZVJlZlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBTd2l0Y2hWaWV3KF92aWV3Q29udGFpbmVyUmVmLCBfdGVtcGxhdGVSZWYpIHtcclxuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gX3ZpZXdDb250YWluZXJSZWY7XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVSZWYgPSBfdGVtcGxhdGVSZWY7XHJcbiAgICAgICAgdGhpcy5fY3JlYXRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBTd2l0Y2hWaWV3LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fY3JlYXRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgU3dpdGNoVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9jcmVhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jbGVhcigpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjcmVhdGVkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBTd2l0Y2hWaWV3LnByb3RvdHlwZS5lbmZvcmNlU3RhdGUgPSBmdW5jdGlvbiAoY3JlYXRlZCkge1xyXG4gICAgICAgIGlmIChjcmVhdGVkICYmICF0aGlzLl9jcmVhdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFjcmVhdGVkICYmIHRoaXMuX2NyZWF0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBTd2l0Y2hWaWV3O1xyXG59KCkpO1xyXG4vKipcclxuICogXFxAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXHJcbiAqXHJcbiAqIFxcQHdoYXRJdERvZXMgQWRkcyAvIHJlbW92ZXMgRE9NIHN1Yi10cmVlcyB3aGVuIHRoZSBuZXN0IG1hdGNoIGV4cHJlc3Npb25zIG1hdGNoZXMgdGhlIHN3aXRjaFxyXG4gKiAgICAgICAgICAgICBleHByZXNzaW9uLlxyXG4gKlxyXG4gKiBcXEBob3dUb1VzZVxyXG4gKiBgYGBcclxuICogICAgIDxjb250YWluZXItZWxlbWVudCBbbmdTd2l0Y2hdPVwic3dpdGNoX2V4cHJlc3Npb25cIj5cclxuICogICAgICAgPHNvbWUtZWxlbWVudCAqbmdTd2l0Y2hDYXNlPVwibWF0Y2hfZXhwcmVzc2lvbl8xXCI+Li4uPC9zb21lLWVsZW1lbnQ+XHJcbiAqICAgICAgIDxzb21lLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fMlwiPi4uLjwvc29tZS1lbGVtZW50PlxyXG4gKiAgICAgICA8c29tZS1vdGhlci1lbGVtZW50ICpuZ1N3aXRjaENhc2U9XCJtYXRjaF9leHByZXNzaW9uXzNcIj4uLi48L3NvbWUtb3RoZXItZWxlbWVudD5cclxuICogICAgICAgPG5nLWNvbnRhaW5lciAqbmdTd2l0Y2hDYXNlPVwibWF0Y2hfZXhwcmVzc2lvbl8zXCI+XHJcbiAqICAgICAgICAgPCEtLSB1c2UgYSBuZy1jb250YWluZXIgdG8gZ3JvdXAgbXVsdGlwbGUgcm9vdCBub2RlcyAtLT5cclxuICogICAgICAgICA8aW5uZXItZWxlbWVudD48L2lubmVyLWVsZW1lbnQ+XHJcbiAqICAgICAgICAgPGlubmVyLW90aGVyLWVsZW1lbnQ+PC9pbm5lci1vdGhlci1lbGVtZW50PlxyXG4gKiAgICAgICA8L25nLWNvbnRhaW5lcj5cclxuICogICAgICAgPHNvbWUtZWxlbWVudCAqbmdTd2l0Y2hEZWZhdWx0Pi4uLjwvc29tZS1lbGVtZW50PlxyXG4gKiAgICAgPC9jb250YWluZXItZWxlbWVudD5cclxuICogYGBgXHJcbiAqIFxcQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIGBOZ1N3aXRjaGAgc3RhbXBzIG91dCBuZXN0ZWQgdmlld3Mgd2hlbiB0aGVpciBtYXRjaCBleHByZXNzaW9uIHZhbHVlIG1hdGNoZXMgdGhlIHZhbHVlIG9mIHRoZVxyXG4gKiBzd2l0Y2ggZXhwcmVzc2lvbi5cclxuICpcclxuICogSW4gb3RoZXIgd29yZHM6XHJcbiAqIC0geW91IGRlZmluZSBhIGNvbnRhaW5lciBlbGVtZW50ICh3aGVyZSB5b3UgcGxhY2UgdGhlIGRpcmVjdGl2ZSB3aXRoIGEgc3dpdGNoIGV4cHJlc3Npb24gb24gdGhlXHJcbiAqIGBbbmdTd2l0Y2hdPVwiLi4uXCJgIGF0dHJpYnV0ZSlcclxuICogLSB5b3UgZGVmaW5lIGlubmVyIHZpZXdzIGluc2lkZSB0aGUgYE5nU3dpdGNoYCBhbmQgcGxhY2UgYSBgKm5nU3dpdGNoQ2FzZWAgYXR0cmlidXRlIG9uIHRoZSB2aWV3XHJcbiAqIHJvb3QgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEVsZW1lbnRzIHdpdGhpbiBgTmdTd2l0Y2hgIGJ1dCBvdXRzaWRlIG9mIGEgYE5nU3dpdGNoQ2FzZWAgb3IgYE5nU3dpdGNoRGVmYXVsdGAgZGlyZWN0aXZlcyB3aWxsXHJcbiAqIGJlIHByZXNlcnZlZCBhdCB0aGUgbG9jYXRpb24uXHJcbiAqXHJcbiAqIFRoZSBgbmdTd2l0Y2hDYXNlYCBkaXJlY3RpdmUgaW5mb3JtcyB0aGUgcGFyZW50IGBOZ1N3aXRjaGAgb2Ygd2hpY2ggdmlldyB0byBkaXNwbGF5IHdoZW4gdGhlXHJcbiAqIGV4cHJlc3Npb24gaXMgZXZhbHVhdGVkLlxyXG4gKiBXaGVuIG5vIG1hdGNoaW5nIGV4cHJlc3Npb24gaXMgZm91bmQgb24gYSBgbmdTd2l0Y2hDYXNlYCB2aWV3LCB0aGUgYG5nU3dpdGNoRGVmYXVsdGAgdmlldyBpc1xyXG4gKiBzdGFtcGVkIG91dC5cclxuICpcclxuICogXFxAc3RhYmxlXHJcbiAqL1xyXG52YXIgTmdTd2l0Y2ggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmdTd2l0Y2goKSB7XHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdFVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jYXNlQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2xhc3RDYXNlQ2hlY2tJbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5fbGFzdENhc2VzTWF0Y2hlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU3dpdGNoLnByb3RvdHlwZSwgXCJuZ1N3aXRjaFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZXdWYWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbmdTd2l0Y2ggPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2Nhc2VDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGVmYXVsdENhc2VzKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFxcQGludGVybmFsXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX2FkZENhc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jYXNlQ291bnQrKzsgfTtcclxuICAgIC8qKlxyXG4gICAgICogXFxAaW50ZXJuYWxcclxuICAgICAqIEBwYXJhbSB7P30gdmlld1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdTd2l0Y2gucHJvdG90eXBlLl9hZGREZWZhdWx0ID0gZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2RlZmF1bHRWaWV3cykge1xyXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0Vmlld3MgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdFZpZXdzLnB1c2godmlldyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBcXEBpbnRlcm5hbFxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdTd2l0Y2gucHJvdG90eXBlLl9tYXRjaENhc2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVkID0gdmFsdWUgPT0gdGhpcy5fbmdTd2l0Y2g7XHJcbiAgICAgICAgdGhpcy5fbGFzdENhc2VzTWF0Y2hlZCA9IHRoaXMuX2xhc3RDYXNlc01hdGNoZWQgfHwgbWF0Y2hlZDtcclxuICAgICAgICB0aGlzLl9sYXN0Q2FzZUNoZWNrSW5kZXgrKztcclxuICAgICAgICBpZiAodGhpcy5fbGFzdENhc2VDaGVja0luZGV4ID09PSB0aGlzLl9jYXNlQ291bnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGVmYXVsdENhc2VzKCF0aGlzLl9sYXN0Q2FzZXNNYXRjaGVkKTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdENhc2VDaGVja0luZGV4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdENhc2VzTWF0Y2hlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2hlZDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdXNlRGVmYXVsdFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdTd2l0Y2gucHJvdG90eXBlLl91cGRhdGVEZWZhdWx0Q2FzZXMgPSBmdW5jdGlvbiAodXNlRGVmYXVsdCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kZWZhdWx0Vmlld3MgJiYgdXNlRGVmYXVsdCAhPT0gdGhpcy5fZGVmYXVsdFVzZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFVzZWQgPSB1c2VEZWZhdWx0O1xyXG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdGhpcy5fZGVmYXVsdFZpZXdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWZhdWx0VmlldyA9IHRoaXMuX2RlZmF1bHRWaWV3c1tpXTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRWaWV3LmVuZm9yY2VTdGF0ZSh1c2VEZWZhdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTmdTd2l0Y2g7XHJcbn0oKSk7XHJcbk5nU3dpdGNoLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1N3aXRjaF0nIH0sXSB9LFxyXG5dO1xyXG4vKipcclxuICogQG5vY29sbGFwc2VcclxuICovXHJcbk5nU3dpdGNoLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XHJcbk5nU3dpdGNoLnByb3BEZWNvcmF0b3JzID0ge1xyXG4gICAgJ25nU3dpdGNoJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXHJcbn07XHJcbi8qKlxyXG4gKiBcXEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcclxuICpcclxuICogXFxAd2hhdEl0RG9lcyBDcmVhdGVzIGEgdmlldyB0aGF0IHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQge1xcQGxpbmsgTmdTd2l0Y2h9IHdoZW4gdGhlXHJcbiAqICAgICAgICAgICAgIGdpdmVuIGV4cHJlc3Npb24gZXZhbHVhdGUgdG8gcmVzcGVjdGl2ZWx5IHRoZSBzYW1lL2RpZmZlcmVudCB2YWx1ZSBhcyB0aGUgc3dpdGNoXHJcbiAqICAgICAgICAgICAgIGV4cHJlc3Npb24uXHJcbiAqXHJcbiAqIFxcQGhvd1RvVXNlXHJcbiAqIGBgYFxyXG4gKiA8Y29udGFpbmVyLWVsZW1lbnQgW25nU3dpdGNoXT1cInN3aXRjaF9leHByZXNzaW9uXCI+XHJcbiAqICAgPHNvbWUtZWxlbWVudCAqbmdTd2l0Y2hDYXNlPVwibWF0Y2hfZXhwcmVzc2lvbl8xXCI+Li4uPC9zb21lLWVsZW1lbnQ+XHJcbiAqIDwvY29udGFpbmVyLWVsZW1lbnQ+XHJcbiAqIGBgYFxyXG4gKiBcXEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBJbnNlcnQgdGhlIHN1Yi10cmVlIHdoZW4gdGhlIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBlbmNsb3Npbmcgc3dpdGNoXHJcbiAqIGV4cHJlc3Npb24uXHJcbiAqXHJcbiAqIElmIG11bHRpcGxlIG1hdGNoIGV4cHJlc3Npb25zIG1hdGNoIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiB2YWx1ZSwgYWxsIG9mIHRoZW0gYXJlIGRpc3BsYXllZC5cclxuICpcclxuICogU2VlIHtcXEBsaW5rIE5nU3dpdGNofSBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlLlxyXG4gKlxyXG4gKiBcXEBzdGFibGVcclxuICovXHJcbnZhciBOZ1N3aXRjaENhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHZpZXdDb250YWluZXJcclxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVSZWZcclxuICAgICAqIEBwYXJhbSB7P30gbmdTd2l0Y2hcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTmdTd2l0Y2hDYXNlKHZpZXdDb250YWluZXIsIHRlbXBsYXRlUmVmLCBuZ1N3aXRjaCkge1xyXG4gICAgICAgIHRoaXMubmdTd2l0Y2ggPSBuZ1N3aXRjaDtcclxuICAgICAgICBuZ1N3aXRjaC5fYWRkQ2FzZSgpO1xyXG4gICAgICAgIHRoaXMuX3ZpZXcgPSBuZXcgU3dpdGNoVmlldyh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nU3dpdGNoQ2FzZS5wcm90b3R5cGUubmdEb0NoZWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3LmVuZm9yY2VTdGF0ZSh0aGlzLm5nU3dpdGNoLl9tYXRjaENhc2UodGhpcy5uZ1N3aXRjaENhc2UpKTsgfTtcclxuICAgIHJldHVybiBOZ1N3aXRjaENhc2U7XHJcbn0oKSk7XHJcbk5nU3dpdGNoQ2FzZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdTd2l0Y2hDYXNlXScgfSxdIH0sXHJcbl07XHJcbi8qKlxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuTmdTd2l0Y2hDYXNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIH0sXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYsIH0sXHJcbiAgICB7IHR5cGU6IE5nU3dpdGNoLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSxdIH0sXHJcbl07IH07XHJcbk5nU3dpdGNoQ2FzZS5wcm9wRGVjb3JhdG9ycyA9IHtcclxuICAgICduZ1N3aXRjaENhc2UnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcclxufTtcclxuLyoqXHJcbiAqIFxcQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxyXG4gKiBcXEB3aGF0SXREb2VzIENyZWF0ZXMgYSB2aWV3IHRoYXQgaXMgYWRkZWQgdG8gdGhlIHBhcmVudCB7XFxAbGluayBOZ1N3aXRjaH0gd2hlbiBubyBjYXNlIGV4cHJlc3Npb25zXHJcbiAqIG1hdGNoIHRoZVxyXG4gKiAgICAgICAgICAgICBzd2l0Y2ggZXhwcmVzc2lvbi5cclxuICpcclxuICogXFxAaG93VG9Vc2VcclxuICogYGBgXHJcbiAqIDxjb250YWluZXItZWxlbWVudCBbbmdTd2l0Y2hdPVwic3dpdGNoX2V4cHJlc3Npb25cIj5cclxuICogICA8c29tZS1lbGVtZW50ICpuZ1N3aXRjaENhc2U9XCJtYXRjaF9leHByZXNzaW9uXzFcIj4uLi48L3NvbWUtZWxlbWVudD5cclxuICogICA8c29tZS1vdGhlci1lbGVtZW50ICpuZ1N3aXRjaERlZmF1bHQ+Li4uPC9zb21lLW90aGVyLWVsZW1lbnQ+XHJcbiAqIDwvY29udGFpbmVyLWVsZW1lbnQ+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBcXEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBJbnNlcnQgdGhlIHN1Yi10cmVlIHdoZW4gbm8gY2FzZSBleHByZXNzaW9ucyBldmFsdWF0ZSB0byB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgZW5jbG9zaW5nIHN3aXRjaFxyXG4gKiBleHByZXNzaW9uLlxyXG4gKlxyXG4gKiBTZWUge1xcQGxpbmsgTmdTd2l0Y2h9IGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGUuXHJcbiAqXHJcbiAqIFxcQHN0YWJsZVxyXG4gKi9cclxudmFyIE5nU3dpdGNoRGVmYXVsdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmlld0NvbnRhaW5lclxyXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVJlZlxyXG4gICAgICogQHBhcmFtIHs/fSBuZ1N3aXRjaFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBOZ1N3aXRjaERlZmF1bHQodmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYsIG5nU3dpdGNoKSB7XHJcbiAgICAgICAgbmdTd2l0Y2guX2FkZERlZmF1bHQobmV3IFN3aXRjaFZpZXcodmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBOZ1N3aXRjaERlZmF1bHQ7XHJcbn0oKSk7XHJcbk5nU3dpdGNoRGVmYXVsdC5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdTd2l0Y2hEZWZhdWx0XScgfSxdIH0sXHJcbl07XHJcbi8qKlxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuTmdTd2l0Y2hEZWZhdWx0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIH0sXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYsIH0sXHJcbiAgICB7IHR5cGU6IE5nU3dpdGNoLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSxdIH0sXHJcbl07IH07XHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIFxcQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxyXG4gKlxyXG4gKiBcXEB3aGF0SXREb2VzIEFkZHMgLyByZW1vdmVzIERPTSBzdWItdHJlZXMgYmFzZWQgb24gYSBudW1lcmljIHZhbHVlLiBUYWlsb3JlZCBmb3IgcGx1cmFsaXphdGlvbi5cclxuICpcclxuICogXFxAaG93VG9Vc2VcclxuICogYGBgXHJcbiAqIDxzb21lLWVsZW1lbnQgW25nUGx1cmFsXT1cInZhbHVlXCI+XHJcbiAqICAgPG5nLXRlbXBsYXRlIG5nUGx1cmFsQ2FzZT1cIj0wXCI+dGhlcmUgaXMgbm90aGluZzwvbmctdGVtcGxhdGU+XHJcbiAqICAgPG5nLXRlbXBsYXRlIG5nUGx1cmFsQ2FzZT1cIj0xXCI+dGhlcmUgaXMgb25lPC9uZy10ZW1wbGF0ZT5cclxuICogICA8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwiZmV3XCI+dGhlcmUgYXJlIGEgZmV3PC9uZy10ZW1wbGF0ZT5cclxuICogPC9zb21lLWVsZW1lbnQ+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBcXEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBEaXNwbGF5cyBET00gc3ViLXRyZWVzIHRoYXQgbWF0Y2ggdGhlIHN3aXRjaCBleHByZXNzaW9uIHZhbHVlLCBvciBmYWlsaW5nIHRoYXQsIERPTSBzdWItdHJlZXNcclxuICogdGhhdCBtYXRjaCB0aGUgc3dpdGNoIGV4cHJlc3Npb24ncyBwbHVyYWxpemF0aW9uIGNhdGVnb3J5LlxyXG4gKlxyXG4gKiBUbyB1c2UgdGhpcyBkaXJlY3RpdmUgeW91IG11c3QgcHJvdmlkZSBhIGNvbnRhaW5lciBlbGVtZW50IHRoYXQgc2V0cyB0aGUgYFtuZ1BsdXJhbF1gIGF0dHJpYnV0ZVxyXG4gKiB0byBhIHN3aXRjaCBleHByZXNzaW9uLiBJbm5lciBlbGVtZW50cyB3aXRoIGEgYFtuZ1BsdXJhbENhc2VdYCB3aWxsIGRpc3BsYXkgYmFzZWQgb24gdGhlaXJcclxuICogZXhwcmVzc2lvbjpcclxuICogLSBpZiBgW25nUGx1cmFsQ2FzZV1gIGlzIHNldCB0byBhIHZhbHVlIHN0YXJ0aW5nIHdpdGggYD1gLCBpdCB3aWxsIG9ubHkgZGlzcGxheSBpZiB0aGUgdmFsdWVcclxuICogICBtYXRjaGVzIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiBleGFjdGx5LFxyXG4gKiAtIG90aGVyd2lzZSwgdGhlIHZpZXcgd2lsbCBiZSB0cmVhdGVkIGFzIGEgXCJjYXRlZ29yeSBtYXRjaFwiLCBhbmQgd2lsbCBvbmx5IGRpc3BsYXkgaWYgZXhhY3RcclxuICogICB2YWx1ZSBtYXRjaGVzIGFyZW4ndCBmb3VuZCBhbmQgdGhlIHZhbHVlIG1hcHMgdG8gaXRzIGNhdGVnb3J5IGZvciB0aGUgZGVmaW5lZCBsb2NhbGUuXHJcbiAqXHJcbiAqIFNlZSBodHRwOi8vY2xkci51bmljb2RlLm9yZy9pbmRleC9jbGRyLXNwZWMvcGx1cmFsLXJ1bGVzXHJcbiAqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxudmFyIE5nUGx1cmFsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBfbG9jYWxpemF0aW9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE5nUGx1cmFsKF9sb2NhbGl6YXRpb24pIHtcclxuICAgICAgICB0aGlzLl9sb2NhbGl6YXRpb24gPSBfbG9jYWxpemF0aW9uO1xyXG4gICAgICAgIHRoaXMuX2Nhc2VWaWV3cyA9IHt9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nUGx1cmFsLnByb3RvdHlwZSwgXCJuZ1BsdXJhbFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3dpdGNoVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmlldygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gez99IHN3aXRjaFZpZXdcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nUGx1cmFsLnByb3RvdHlwZS5hZGRDYXNlID0gZnVuY3Rpb24gKHZhbHVlLCBzd2l0Y2hWaWV3KSB7IHRoaXMuX2Nhc2VWaWV3c1t2YWx1ZV0gPSBzd2l0Y2hWaWV3OyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ1BsdXJhbC5wcm90b3R5cGUuX3VwZGF0ZVZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJWaWV3cygpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0gT2JqZWN0LmtleXModGhpcy5fY2FzZVZpZXdzKTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSBnZXRQbHVyYWxDYXRlZ29yeSh0aGlzLl9zd2l0Y2hWYWx1ZSwgY2FzZXMsIHRoaXMuX2xvY2FsaXphdGlvbik7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZhdGVWaWV3KHRoaXMuX2Nhc2VWaWV3c1trZXldKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nUGx1cmFsLnByb3RvdHlwZS5fY2xlYXJWaWV3cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVmlldylcclxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlVmlldy5kZXN0cm95KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHZpZXdcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nUGx1cmFsLnByb3RvdHlwZS5fYWN0aXZhdGVWaWV3ID0gZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICBpZiAodmlldykge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVWaWV3ID0gdmlldztcclxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlVmlldy5jcmVhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5nUGx1cmFsO1xyXG59KCkpO1xyXG5OZ1BsdXJhbC5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdQbHVyYWxdJyB9LF0gfSxcclxuXTtcclxuLyoqXHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5OZ1BsdXJhbC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgIHsgdHlwZTogTmdMb2NhbGl6YXRpb24sIH0sXHJcbl07IH07XHJcbk5nUGx1cmFsLnByb3BEZWNvcmF0b3JzID0ge1xyXG4gICAgJ25nUGx1cmFsJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXHJcbn07XHJcbi8qKlxyXG4gKiBcXEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcclxuICpcclxuICogXFxAd2hhdEl0RG9lcyBDcmVhdGVzIGEgdmlldyB0aGF0IHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQge1xcQGxpbmsgTmdQbHVyYWx9IHdoZW4gdGhlXHJcbiAqICAgICAgICAgICAgIGdpdmVuIGV4cHJlc3Npb24gbWF0Y2hlcyB0aGUgcGx1cmFsIGV4cHJlc3Npb24gYWNjb3JkaW5nIHRvIENMRFIgcnVsZXMuXHJcbiAqXHJcbiAqIFxcQGhvd1RvVXNlXHJcbiAqIGBgYFxyXG4gKiA8c29tZS1lbGVtZW50IFtuZ1BsdXJhbF09XCJ2YWx1ZVwiPlxyXG4gKiAgIDxuZy10ZW1wbGF0ZSBuZ1BsdXJhbENhc2U9XCI9MFwiPi4uLjwvbmctdGVtcGxhdGU+XHJcbiAqICAgPG5nLXRlbXBsYXRlIG5nUGx1cmFsQ2FzZT1cIm90aGVyXCI+Li4uPC9uZy10ZW1wbGF0ZT5cclxuICogPC9zb21lLWVsZW1lbnQ+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBTZWUge1xcQGxpbmsgTmdQbHVyYWx9IGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGUuXHJcbiAqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxudmFyIE5nUGx1cmFsQ2FzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVcclxuICAgICAqIEBwYXJhbSB7P30gdmlld0NvbnRhaW5lclxyXG4gICAgICogQHBhcmFtIHs/fSBuZ1BsdXJhbFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBOZ1BsdXJhbENhc2UodmFsdWUsIHRlbXBsYXRlLCB2aWV3Q29udGFpbmVyLCBuZ1BsdXJhbCkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB2YXIgaXNBTnVtYmVyID0gIWlzTmFOKE51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgIG5nUGx1cmFsLmFkZENhc2UoaXNBTnVtYmVyID8gXCI9XCIgKyB2YWx1ZSA6IHZhbHVlLCBuZXcgU3dpdGNoVmlldyh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5nUGx1cmFsQ2FzZTtcclxufSgpKTtcclxuTmdQbHVyYWxDYXNlLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1BsdXJhbENhc2VdJyB9LF0gfSxcclxuXTtcclxuLyoqXHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5OZ1BsdXJhbENhc2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5BdHRyaWJ1dGUsIGFyZ3M6IFsnbmdQbHVyYWxDYXNlJyxdIH0sXSB9LFxyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmLCB9LFxyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIH0sXHJcbiAgICB7IHR5cGU6IE5nUGx1cmFsLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSxdIH0sXHJcbl07IH07XHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIFxcQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxyXG4gKlxyXG4gKiBcXEB3aGF0SXREb2VzIFVwZGF0ZSBhbiBIVE1MIGVsZW1lbnQgc3R5bGVzLlxyXG4gKlxyXG4gKiBcXEBob3dUb1VzZVxyXG4gKiBgYGBcclxuICogPHNvbWUtZWxlbWVudCBbbmdTdHlsZV09XCJ7J2ZvbnQtc3R5bGUnOiBzdHlsZUV4cH1cIj4uLi48L3NvbWUtZWxlbWVudD5cclxuICpcclxuICogPHNvbWUtZWxlbWVudCBbbmdTdHlsZV09XCJ7J21heC13aWR0aC5weCc6IHdpZHRoRXhwfVwiPi4uLjwvc29tZS1lbGVtZW50PlxyXG4gKlxyXG4gKiA8c29tZS1lbGVtZW50IFtuZ1N0eWxlXT1cIm9iakV4cFwiPi4uLjwvc29tZS1lbGVtZW50PlxyXG4gKiBgYGBcclxuICpcclxuICogXFxAZGVzY3JpcHRpb25cclxuICpcclxuICogVGhlIHN0eWxlcyBhcmUgdXBkYXRlZCBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlIG9mIHRoZSBleHByZXNzaW9uIGV2YWx1YXRpb246XHJcbiAqIC0ga2V5cyBhcmUgc3R5bGUgbmFtZXMgd2l0aCBhbiBvcHRpb25hbCBgLjx1bml0PmAgc3VmZml4IChpZSAndG9wLnB4JywgJ2ZvbnQtc3R5bGUuZW0nKSxcclxuICogLSB2YWx1ZXMgYXJlIHRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhvc2UgcHJvcGVydGllcyAoZXhwcmVzc2VkIGluIHRoZSBnaXZlbiB1bml0KS5cclxuICpcclxuICogXFxAc3RhYmxlXHJcbiAqL1xyXG52YXIgTmdTdHlsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gX2RpZmZlcnNcclxuICAgICAqIEBwYXJhbSB7P30gX25nRWxcclxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE5nU3R5bGUoX2RpZmZlcnMsIF9uZ0VsLCBfcmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLl9kaWZmZXJzID0gX2RpZmZlcnM7XHJcbiAgICAgICAgdGhpcy5fbmdFbCA9IF9uZ0VsO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU3R5bGUucHJvdG90eXBlLCBcIm5nU3R5bGVcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLl9uZ1N0eWxlID0gdjtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaWZmZXIgJiYgdikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHYpLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5nU3R5bGUucHJvdG90eXBlLm5nRG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlmZmVyKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoYW5nZXMgPSB0aGlzLl9kaWZmZXIuZGlmZih0aGlzLl9uZ1N0eWxlKTtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2hhbmdlcyhjaGFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdTdHlsZS5wcm90b3R5cGUuX2FwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fc2V0U3R5bGUocmVjb3JkLmtleSwgbnVsbCk7IH0pO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fc2V0U3R5bGUocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xyXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaENoYW5nZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgcmV0dXJuIF90aGlzLl9zZXRTdHlsZShyZWNvcmQua2V5LCByZWNvcmQuY3VycmVudFZhbHVlKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVBbmRVbml0XHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ1N0eWxlLnByb3RvdHlwZS5fc2V0U3R5bGUgPSBmdW5jdGlvbiAobmFtZUFuZFVuaXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF9hID0gbmFtZUFuZFVuaXQuc3BsaXQoJy4nKSwgbmFtZSA9IF9hWzBdLCB1bml0ID0gX2FbMV07XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSAhPSBudWxsICYmIHVuaXQgPyBcIlwiICsgdmFsdWUgKyB1bml0IDogdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuX25nRWwubmF0aXZlRWxlbWVudCwgbmFtZSwgLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTmdTdHlsZTtcclxufSgpKTtcclxuTmdTdHlsZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdTdHlsZV0nIH0sXSB9LFxyXG5dO1xyXG4vKipcclxuICogQG5vY29sbGFwc2VcclxuICovXHJcbk5nU3R5bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuS2V5VmFsdWVEaWZmZXJzLCB9LFxyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXHJcbl07IH07XHJcbk5nU3R5bGUucHJvcERlY29yYXRvcnMgPSB7XHJcbiAgICAnbmdTdHlsZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG59O1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBcXEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcclxuICpcclxuICogXFxAd2hhdEl0RG9lcyBJbnNlcnRzIGFuIGVtYmVkZGVkIHZpZXcgZnJvbSBhIHByZXBhcmVkIGBUZW1wbGF0ZVJlZmBcclxuICpcclxuICogXFxAaG93VG9Vc2VcclxuICogYGBgXHJcbiAqIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJ0ZW1wbGF0ZVJlZkV4cDsgY29udGV4dDogY29udGV4dEV4cFwiPjwvbmctY29udGFpbmVyPlxyXG4gKiBgYGBcclxuICpcclxuICogXFxAZGVzY3JpcHRpb25cclxuICpcclxuICogWW91IGNhbiBhdHRhY2ggYSBjb250ZXh0IG9iamVjdCB0byB0aGUgYEVtYmVkZGVkVmlld1JlZmAgYnkgc2V0dGluZyBgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XWAuXHJcbiAqIGBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdYCBzaG91bGQgYmUgYW4gb2JqZWN0LCB0aGUgb2JqZWN0J3Mga2V5cyB3aWxsIGJlIGF2YWlsYWJsZSBmb3IgYmluZGluZ1xyXG4gKiBieSB0aGUgbG9jYWwgdGVtcGxhdGUgYGxldGAgZGVjbGFyYXRpb25zLlxyXG4gKlxyXG4gKiBOb3RlOiB1c2luZyB0aGUga2V5IGAkaW1wbGljaXRgIGluIHRoZSBjb250ZXh0IG9iamVjdCB3aWxsIHNldCBpdCdzIHZhbHVlIGFzIGRlZmF1bHQuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICoge1xcQGV4YW1wbGUgY29tbW9uL25nVGVtcGxhdGVPdXRsZXQvdHMvbW9kdWxlLnRzIHJlZ2lvbj0nTmdUZW1wbGF0ZU91dGxldCd9XHJcbiAqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxudmFyIE5nVGVtcGxhdGVPdXRsZXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IF92aWV3Q29udGFpbmVyUmVmXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE5nVGVtcGxhdGVPdXRsZXQoX3ZpZXdDb250YWluZXJSZWYpIHtcclxuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gX3ZpZXdDb250YWluZXJSZWY7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdUZW1wbGF0ZU91dGxldC5wcm90b3R5cGUsIFwibmdPdXRsZXRDb250ZXh0XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCB2NC4wLjAgLSBSZW5hbWVkIHRvIG5nVGVtcGxhdGVPdXRsZXRDb250ZXh0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoY29udGV4dCkgeyB0aGlzLm5nVGVtcGxhdGVPdXRsZXRDb250ZXh0ID0gY29udGV4dDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTmdUZW1wbGF0ZU91dGxldC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIGlmICh0aGlzLl92aWV3UmVmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYucmVtb3ZlKHRoaXMuX3ZpZXdDb250YWluZXJSZWYuaW5kZXhPZih0aGlzLl92aWV3UmVmKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm5nVGVtcGxhdGVPdXRsZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlld1JlZiA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMubmdUZW1wbGF0ZU91dGxldCwgdGhpcy5uZ1RlbXBsYXRlT3V0bGV0Q29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBOZ1RlbXBsYXRlT3V0bGV0O1xyXG59KCkpO1xyXG5OZ1RlbXBsYXRlT3V0bGV0LmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1RlbXBsYXRlT3V0bGV0XScgfSxdIH0sXHJcbl07XHJcbi8qKlxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuTmdUZW1wbGF0ZU91dGxldC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxyXG5dOyB9O1xyXG5OZ1RlbXBsYXRlT3V0bGV0LnByb3BEZWNvcmF0b3JzID0ge1xyXG4gICAgJ25nVGVtcGxhdGVPdXRsZXRDb250ZXh0JzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXHJcbiAgICAnbmdUZW1wbGF0ZU91dGxldCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG4gICAgJ25nT3V0bGV0Q29udGV4dCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxyXG59O1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2YgQW5ndWxhciBkaXJlY3RpdmVzIHRoYXQgYXJlIGxpa2VseSB0byBiZSB1c2VkIGluIGVhY2ggYW5kIGV2ZXJ5IEFuZ3VsYXJcclxuICogYXBwbGljYXRpb24uXHJcbiAqL1xyXG52YXIgQ09NTU9OX0RJUkVDVElWRVMgPSBbXHJcbiAgICBOZ0NsYXNzLFxyXG4gICAgTmdDb21wb25lbnRPdXRsZXQsXHJcbiAgICBOZ0Zvck9mLFxyXG4gICAgTmdJZixcclxuICAgIE5nVGVtcGxhdGVPdXRsZXQsXHJcbiAgICBOZ1N0eWxlLFxyXG4gICAgTmdTd2l0Y2gsXHJcbiAgICBOZ1N3aXRjaENhc2UsXHJcbiAgICBOZ1N3aXRjaERlZmF1bHQsXHJcbiAgICBOZ1BsdXJhbCxcclxuICAgIE5nUGx1cmFsQ2FzZSxcclxuXTtcclxuLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBkZXByZWNhdGVkIGRpcmVjdGl2ZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHBhcnQgb2YgdGhlIGNvcmUgbW9kdWxlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogQHBhcmFtIHs/fSB0eXBlXHJcbiAqIEBwYXJhbSB7P30gdmFsdWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGludmFsaWRQaXBlQXJndW1lbnRFcnJvcih0eXBlLCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIEVycm9yKFwiSW52YWxpZFBpcGVBcmd1bWVudDogJ1wiICsgdmFsdWUgKyBcIicgZm9yIHBpcGUgJ1wiICsgX2FuZ3VsYXJfY29yZS7JtXN0cmluZ2lmeSh0eXBlKSArIFwiJ1wiKTtcclxufVxyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbnZhciBPYnNlcnZhYmxlU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZVN0cmF0ZWd5KCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFzeW5jXHJcbiAgICAgKiBAcGFyYW0gez99IHVwZGF0ZUxhdGVzdFZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBPYnNlcnZhYmxlU3RyYXRlZ3kucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChhc3luYywgdXBkYXRlTGF0ZXN0VmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gYXN5bmMuc3Vic2NyaWJlKHsgbmV4dDogdXBkYXRlTGF0ZXN0VmFsdWUsIGVycm9yOiBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzdWJzY3JpcHRpb25cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE9ic2VydmFibGVTdHJhdGVneS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gc3Vic2NyaXB0aW9uXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBPYnNlcnZhYmxlU3RyYXRlZ3kucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZVN0cmF0ZWd5O1xyXG59KCkpO1xyXG52YXIgUHJvbWlzZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb21pc2VTdHJhdGVneSgpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhc3luY1xyXG4gICAgICogQHBhcmFtIHs/fSB1cGRhdGVMYXRlc3RWYWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUHJvbWlzZVN0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoYXN5bmMsIHVwZGF0ZUxhdGVzdFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFzeW5jLnRoZW4odXBkYXRlTGF0ZXN0VmFsdWUsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzdWJzY3JpcHRpb25cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFByb21pc2VTdHJhdGVneS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzdWJzY3JpcHRpb25cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFByb21pc2VTdHJhdGVneS5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikgeyB9O1xyXG4gICAgcmV0dXJuIFByb21pc2VTdHJhdGVneTtcclxufSgpKTtcclxudmFyIF9wcm9taXNlU3RyYXRlZ3kgPSBuZXcgUHJvbWlzZVN0cmF0ZWd5KCk7XHJcbnZhciBfb2JzZXJ2YWJsZVN0cmF0ZWd5ID0gbmV3IE9ic2VydmFibGVTdHJhdGVneSgpO1xyXG4vKipcclxuICogXFxAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXHJcbiAqIFxcQHdoYXRJdERvZXMgVW53cmFwcyBhIHZhbHVlIGZyb20gYW4gYXN5bmNocm9ub3VzIHByaW1pdGl2ZS5cclxuICogXFxAaG93VG9Vc2UgYG9ic2VydmFibGVfb3JfcHJvbWlzZV9leHByZXNzaW9uIHwgYXN5bmNgXHJcbiAqIFxcQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBgYXN5bmNgIHBpcGUgc3Vic2NyaWJlcyB0byBhbiBgT2JzZXJ2YWJsZWAgb3IgYFByb21pc2VgIGFuZCByZXR1cm5zIHRoZSBsYXRlc3QgdmFsdWUgaXQgaGFzXHJcbiAqIGVtaXR0ZWQuIFdoZW4gYSBuZXcgdmFsdWUgaXMgZW1pdHRlZCwgdGhlIGBhc3luY2AgcGlwZSBtYXJrcyB0aGUgY29tcG9uZW50IHRvIGJlIGNoZWNrZWQgZm9yXHJcbiAqIGNoYW5nZXMuIFdoZW4gdGhlIGNvbXBvbmVudCBnZXRzIGRlc3Ryb3llZCwgdGhlIGBhc3luY2AgcGlwZSB1bnN1YnNjcmliZXMgYXV0b21hdGljYWxseSB0byBhdm9pZFxyXG4gKiBwb3RlbnRpYWwgbWVtb3J5IGxlYWtzLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlc1xyXG4gKlxyXG4gKiBUaGlzIGV4YW1wbGUgYmluZHMgYSBgUHJvbWlzZWAgdG8gdGhlIHZpZXcuIENsaWNraW5nIHRoZSBgUmVzb2x2ZWAgYnV0dG9uIHJlc29sdmVzIHRoZVxyXG4gKiBwcm9taXNlLlxyXG4gKlxyXG4gKiB7XFxAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvYXN5bmNfcGlwZS50cyByZWdpb249J0FzeW5jUGlwZVByb21pc2UnfVxyXG4gKlxyXG4gKiBJdCdzIGFsc28gcG9zc2libGUgdG8gdXNlIGBhc3luY2Agd2l0aCBPYnNlcnZhYmxlcy4gVGhlIGV4YW1wbGUgYmVsb3cgYmluZHMgdGhlIGB0aW1lYCBPYnNlcnZhYmxlXHJcbiAqIHRvIHRoZSB2aWV3LiBUaGUgT2JzZXJ2YWJsZSBjb250aW51b3VzbHkgdXBkYXRlcyB0aGUgdmlldyB3aXRoIHRoZSBjdXJyZW50IHRpbWUuXHJcbiAqXHJcbiAqIHtcXEBleGFtcGxlIGNvbW1vbi9waXBlcy90cy9hc3luY19waXBlLnRzIHJlZ2lvbj0nQXN5bmNQaXBlT2JzZXJ2YWJsZSd9XHJcbiAqXHJcbiAqIFxcQHN0YWJsZVxyXG4gKi9cclxudmFyIEFzeW5jUGlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gX3JlZlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBc3luY1BpcGUoX3JlZikge1xyXG4gICAgICAgIHRoaXMuX3JlZiA9IF9yZWY7XHJcbiAgICAgICAgdGhpcy5fbGF0ZXN0VmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fb2JqID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zdHJhdGVneSA9ICgobnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBc3luY1BpcGUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gb2JqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBc3luY1BpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBpZiAoIXRoaXMuX29iaikge1xyXG4gICAgICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gdGhpcy5fbGF0ZXN0VmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXRlc3RWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9iaiAhPT0gdGhpcy5fb2JqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKC8qKiBAdHlwZSB7P30gKi8gKG9iaikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fbGF0ZXN0VmFsdWUgPT09IHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSB0aGlzLl9sYXRlc3RWYWx1ZTtcclxuICAgICAgICByZXR1cm4gX2FuZ3VsYXJfY29yZS5XcmFwcGVkVmFsdWUud3JhcCh0aGlzLl9sYXRlc3RWYWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG9ialxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQXN5bmNQaXBlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fb2JqID0gb2JqO1xyXG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gdGhpcy5fc2VsZWN0U3RyYXRlZ3kob2JqKTtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLl9zdHJhdGVneS5jcmVhdGVTdWJzY3JpcHRpb24ob2JqLCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLl91cGRhdGVMYXRlc3RWYWx1ZShvYmosIHZhbHVlKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG9ialxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQXN5bmNQaXBlLnByb3RvdHlwZS5fc2VsZWN0U3RyYXRlZ3kgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgaWYgKF9hbmd1bGFyX2NvcmUuybVpc1Byb21pc2Uob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3Byb21pc2VTdHJhdGVneTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF9hbmd1bGFyX2NvcmUuybVpc09ic2VydmFibGUob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX29ic2VydmFibGVTdHJhdGVneTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgaW52YWxpZFBpcGVBcmd1bWVudEVycm9yKEFzeW5jUGlwZSwgb2JqKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX2Rpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RyYXRlZ3kuZGlzcG9zZSgvKiogQHR5cGUgez99ICovICgodGhpcy5fc3Vic2NyaXB0aW9uKSkpO1xyXG4gICAgICAgIHRoaXMuX2xhdGVzdFZhbHVlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX29iaiA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFzeW5jXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBc3luY1BpcGUucHJvdG90eXBlLl91cGRhdGVMYXRlc3RWYWx1ZSA9IGZ1bmN0aW9uIChhc3luYywgdmFsdWUpIHtcclxuICAgICAgICBpZiAoYXN5bmMgPT09IHRoaXMuX29iaikge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWYubWFya0ZvckNoZWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBBc3luY1BpcGU7XHJcbn0oKSk7XHJcbkFzeW5jUGlwZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdhc3luYycsIHB1cmU6IGZhbHNlIH0sXSB9LFxyXG5dO1xyXG4vKipcclxuICogQG5vY29sbGFwc2VcclxuICovXHJcbkFzeW5jUGlwZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3RvclJlZiwgfSxcclxuXTsgfTtcclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogVHJhbnNmb3JtcyB0ZXh0IHRvIGxvd2VyY2FzZS5cclxuICpcclxuICoge1xcQGV4YW1wbGUgIGNvbW1vbi9waXBlcy90cy9sb3dlcnVwcGVyX3BpcGUudHMgcmVnaW9uPSdMb3dlclVwcGVyUGlwZScgfVxyXG4gKlxyXG4gKiBcXEBzdGFibGVcclxuICovXHJcbnZhciBMb3dlckNhc2VQaXBlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvd2VyQ2FzZVBpcGUoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIExvd2VyQ2FzZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdmFsdWUpXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IoTG93ZXJDYXNlUGlwZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTG93ZXJDYXNlUGlwZTtcclxufSgpKTtcclxuTG93ZXJDYXNlUGlwZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdsb3dlcmNhc2UnIH0sXSB9LFxyXG5dO1xyXG4vKipcclxuICogQG5vY29sbGFwc2VcclxuICovXHJcbkxvd2VyQ2FzZVBpcGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcclxuLyoqXHJcbiAqIEhlbHBlciBtZXRob2QgdG8gdHJhbnNmb3JtIGEgc2luZ2xlIHdvcmQgdG8gdGl0bGVjYXNlLlxyXG4gKlxyXG4gKiBcXEBzdGFibGVcclxuICogQHBhcmFtIHs/fSB3b3JkXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiB0aXRsZUNhc2VXb3JkKHdvcmQpIHtcclxuICAgIGlmICghd29yZClcclxuICAgICAgICByZXR1cm4gd29yZDtcclxuICAgIHJldHVybiB3b3JkWzBdLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRleHQgdG8gdGl0bGVjYXNlLlxyXG4gKlxyXG4gKiBcXEBzdGFibGVcclxuICovXHJcbnZhciBUaXRsZUNhc2VQaXBlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRpdGxlQ2FzZVBpcGUoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRpdGxlQ2FzZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdmFsdWUpXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IoVGl0bGVDYXNlUGlwZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWUuc3BsaXQoL1xcYi9nKS5tYXAoZnVuY3Rpb24gKHdvcmQpIHsgcmV0dXJuIHRpdGxlQ2FzZVdvcmQod29yZCk7IH0pLmpvaW4oJycpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUaXRsZUNhc2VQaXBlO1xyXG59KCkpO1xyXG5UaXRsZUNhc2VQaXBlLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ3RpdGxlY2FzZScgfSxdIH0sXHJcbl07XHJcbi8qKlxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuVGl0bGVDYXNlUGlwZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xyXG4vKipcclxuICogVHJhbnNmb3JtcyB0ZXh0IHRvIHVwcGVyY2FzZS5cclxuICpcclxuICogXFxAc3RhYmxlXHJcbiAqL1xyXG52YXIgVXBwZXJDYXNlUGlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVcHBlckNhc2VQaXBlKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBVcHBlckNhc2VQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAoIXZhbHVlKVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgaW52YWxpZFBpcGVBcmd1bWVudEVycm9yKFVwcGVyQ2FzZVBpcGUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvVXBwZXJDYXNlKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFVwcGVyQ2FzZVBpcGU7XHJcbn0oKSk7XHJcblVwcGVyQ2FzZVBpcGUuZGVjb3JhdG9ycyA9IFtcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAndXBwZXJjYXNlJyB9LF0gfSxcclxuXTtcclxuLyoqXHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5VcHBlckNhc2VQaXBlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XHJcbnZhciBOdW1iZXJGb3JtYXRTdHlsZSA9IHt9O1xyXG5OdW1iZXJGb3JtYXRTdHlsZS5EZWNpbWFsID0gMDtcclxuTnVtYmVyRm9ybWF0U3R5bGUuUGVyY2VudCA9IDE7XHJcbk51bWJlckZvcm1hdFN0eWxlLkN1cnJlbmN5ID0gMjtcclxuTnVtYmVyRm9ybWF0U3R5bGVbTnVtYmVyRm9ybWF0U3R5bGUuRGVjaW1hbF0gPSBcIkRlY2ltYWxcIjtcclxuTnVtYmVyRm9ybWF0U3R5bGVbTnVtYmVyRm9ybWF0U3R5bGUuUGVyY2VudF0gPSBcIlBlcmNlbnRcIjtcclxuTnVtYmVyRm9ybWF0U3R5bGVbTnVtYmVyRm9ybWF0U3R5bGUuQ3VycmVuY3ldID0gXCJDdXJyZW5jeVwiO1xyXG52YXIgTnVtYmVyRm9ybWF0dGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE51bWJlckZvcm1hdHRlcigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBudW1cclxuICAgICAqIEBwYXJhbSB7P30gbG9jYWxlXHJcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXHJcbiAgICAgKiBAcGFyYW0gez89fSBfXzNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE51bWJlckZvcm1hdHRlci5mb3JtYXQgPSBmdW5jdGlvbiAobnVtLCBsb2NhbGUsIHN0eWxlLCBfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtaW5pbXVtSW50ZWdlckRpZ2l0cyA9IF9iLm1pbmltdW1JbnRlZ2VyRGlnaXRzLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBfYi5taW5pbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IF9iLm1heGltdW1GcmFjdGlvbkRpZ2l0cywgY3VycmVuY3kgPSBfYi5jdXJyZW5jeSwgX2MgPSBfYi5jdXJyZW5jeUFzU3ltYm9sLCBjdXJyZW5jeUFzU3ltYm9sID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2M7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWluaW11bUludGVnZXJEaWdpdHM6IG1pbmltdW1JbnRlZ2VyRGlnaXRzLFxyXG4gICAgICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG1pbmltdW1GcmFjdGlvbkRpZ2l0cyxcclxuICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBtYXhpbXVtRnJhY3Rpb25EaWdpdHMsXHJcbiAgICAgICAgICAgIHN0eWxlOiBOdW1iZXJGb3JtYXRTdHlsZVtzdHlsZV0udG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHN0eWxlID09IE51bWJlckZvcm1hdFN0eWxlLkN1cnJlbmN5KSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY3VycmVuY3kgPSB0eXBlb2YgY3VycmVuY3kgPT0gJ3N0cmluZycgPyBjdXJyZW5jeSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgb3B0aW9ucy5jdXJyZW5jeURpc3BsYXkgPSBjdXJyZW5jeUFzU3ltYm9sID8gJ3N5bWJvbCcgOiAnY29kZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTnVtYmVyRm9ybWF0dGVyO1xyXG59KCkpO1xyXG52YXIgREFURV9GT1JNQVRTX1NQTElUID0gLygoPzpbXnlNTGRIaG1zYXpaRXdHakonXSspfCg/OicoPzpbXiddfCcnKSonKXwoPzpFK3x5K3xNK3xMK3xkK3xIK3xoK3xKK3xqK3xtK3xzK3xhfHp8WnxHK3x3KykpKC4qKS87XHJcbnZhciBQQVRURVJOX0FMSUFTRVMgPSB7XHJcbiAgICAvLyBLZXlzIGFyZSBxdW90ZWQgc28gdGhleSBkbyBub3QgZ2V0IHJlbmFtZWQgZHVyaW5nIGNsb3N1cmUgY29tcGlsYXRpb24uXHJcbiAgICAneU1NTWRqbXMnOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbXHJcbiAgICAgICAgZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSxcclxuICAgICAgICBuYW1lQ29uZGl0aW9uKCdtb250aCcsIDMpLFxyXG4gICAgICAgIGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKSxcclxuICAgICAgICBkaWdpdENvbmRpdGlvbignaG91cicsIDEpLFxyXG4gICAgICAgIGRpZ2l0Q29uZGl0aW9uKCdtaW51dGUnLCAxKSxcclxuICAgICAgICBkaWdpdENvbmRpdGlvbignc2Vjb25kJywgMSksXHJcbiAgICBdKSksXHJcbiAgICAneU1kam0nOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbXHJcbiAgICAgICAgZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ21vbnRoJywgMSksIGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKSxcclxuICAgICAgICBkaWdpdENvbmRpdGlvbignaG91cicsIDEpLCBkaWdpdENvbmRpdGlvbignbWludXRlJywgMSlcclxuICAgIF0pKSxcclxuICAgICd5TU1NTUVFRUVkJzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW1xyXG4gICAgICAgIGRpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgMSksIG5hbWVDb25kaXRpb24oJ21vbnRoJywgNCksIG5hbWVDb25kaXRpb24oJ3dlZWtkYXknLCA0KSxcclxuICAgICAgICBkaWdpdENvbmRpdGlvbignZGF5JywgMSlcclxuICAgIF0pKSxcclxuICAgICd5TU1NTWQnOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSwgbmFtZUNvbmRpdGlvbignbW9udGgnLCA0KSwgZGlnaXRDb25kaXRpb24oJ2RheScsIDEpXSkpLFxyXG4gICAgJ3lNTU1kJzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW2RpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgMSksIG5hbWVDb25kaXRpb24oJ21vbnRoJywgMyksIGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKV0pKSxcclxuICAgICd5TWQnOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ21vbnRoJywgMSksIGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKV0pKSxcclxuICAgICdqbXMnOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ3NlY29uZCcsIDEpLCBkaWdpdENvbmRpdGlvbignbWludXRlJywgMSldKSksXHJcbiAgICAnam0nOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ21pbnV0ZScsIDEpXSkpXHJcbn07XHJcbnZhciBEQVRFX0ZPUk1BVFMgPSB7XHJcbiAgICAvLyBLZXlzIGFyZSBxdW90ZWQgc28gdGhleSBkbyBub3QgZ2V0IHJlbmFtZWQuXHJcbiAgICAneXl5eSc6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbigneWVhcicsIDQpKSxcclxuICAgICd5eSc6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbigneWVhcicsIDIpKSxcclxuICAgICd5JzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgMSkpLFxyXG4gICAgJ01NTU0nOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignbW9udGgnLCA0KSksXHJcbiAgICAnTU1NJzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ21vbnRoJywgMykpLFxyXG4gICAgJ01NJzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdtb250aCcsIDIpKSxcclxuICAgICdNJzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdtb250aCcsIDEpKSxcclxuICAgICdMTExMJzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ21vbnRoJywgNCkpLFxyXG4gICAgJ0wnOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignbW9udGgnLCAxKSksXHJcbiAgICAnZGQnOiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ2RheScsIDIpKSxcclxuICAgICdkJzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKSksXHJcbiAgICAnSEgnOiBkaWdpdE1vZGlmaWVyKGhvdXJFeHRyYWN0b3IoZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGhvdXIxMk1vZGlmeShkaWdpdENvbmRpdGlvbignaG91cicsIDIpLCBmYWxzZSkpKSksXHJcbiAgICAnSCc6IGhvdXJFeHRyYWN0b3IoZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGhvdXIxMk1vZGlmeShkaWdpdENvbmRpdGlvbignaG91cicsIDEpLCBmYWxzZSkpKSxcclxuICAgICdoaCc6IGRpZ2l0TW9kaWZpZXIoaG91ckV4dHJhY3RvcihkYXRlUGFydEdldHRlckZhY3RvcnkoaG91cjEyTW9kaWZ5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMiksIHRydWUpKSkpLFxyXG4gICAgJ2gnOiBob3VyRXh0cmFjdG9yKGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShob3VyMTJNb2RpZnkoZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSwgdHJ1ZSkpKSxcclxuICAgICdqaic6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignaG91cicsIDIpKSxcclxuICAgICdqJzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMSkpLFxyXG4gICAgJ21tJzogZGlnaXRNb2RpZmllcihkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ21pbnV0ZScsIDIpKSksXHJcbiAgICAnbSc6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignbWludXRlJywgMSkpLFxyXG4gICAgJ3NzJzogZGlnaXRNb2RpZmllcihkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ3NlY29uZCcsIDIpKSksXHJcbiAgICAncyc6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignc2Vjb25kJywgMSkpLFxyXG4gICAgLy8gd2hpbGUgSVNPIDg2MDEgcmVxdWlyZXMgZnJhY3Rpb25zIHRvIGJlIHByZWZpeGVkIHdpdGggYC5gIG9yIGAsYFxyXG4gICAgLy8gd2UgY2FuIGJlIGp1c3Qgc2FmZWx5IHJlbHkgb24gdXNpbmcgYHNzc2Agc2luY2Ugd2UgY3VycmVudGx5IGRvbid0IHN1cHBvcnQgc2luZ2xlIG9yIHR3byBkaWdpdFxyXG4gICAgLy8gZnJhY3Rpb25zXHJcbiAgICAnc3NzJzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdzZWNvbmQnLCAzKSksXHJcbiAgICAnRUVFRSc6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCd3ZWVrZGF5JywgNCkpLFxyXG4gICAgJ0VFRSc6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCd3ZWVrZGF5JywgMykpLFxyXG4gICAgJ0VFJzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ3dlZWtkYXknLCAyKSksXHJcbiAgICAnRSc6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCd3ZWVrZGF5JywgMSkpLFxyXG4gICAgJ2EnOiBob3VyQ2xvY2tFeHRyYWN0b3IoZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGhvdXIxMk1vZGlmeShkaWdpdENvbmRpdGlvbignaG91cicsIDEpLCB0cnVlKSkpLFxyXG4gICAgJ1onOiB0aW1lWm9uZUdldHRlcignc2hvcnQnKSxcclxuICAgICd6JzogdGltZVpvbmVHZXR0ZXIoJ2xvbmcnKSxcclxuICAgICd3dyc6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeSh7fSksXHJcbiAgICAvLyBmaXJzdCBUaHVyc2RheSBvZiB0aGUgeWVhci4gbm90IHN1cHBvcnQgP1xyXG4gICAgJ3cnOiBkYXRlUGFydEdldHRlckZhY3Rvcnkoe30pLFxyXG4gICAgLy8gb2YgdGhlIHllYXIgbm90IHN1cHBvcnQgP1xyXG4gICAgJ0cnOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignZXJhJywgMSkpLFxyXG4gICAgJ0dHJzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ2VyYScsIDIpKSxcclxuICAgICdHR0cnOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignZXJhJywgMykpLFxyXG4gICAgJ0dHR0cnOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignZXJhJywgNCkpXHJcbn07XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGlubmVyXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBkaWdpdE1vZGlmaWVyKGlubmVyKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IGlubmVyKGRhdGUsIGxvY2FsZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT0gMSA/ICcwJyArIHJlc3VsdCA6IHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gaW5uZXJcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGhvdXJDbG9ja0V4dHJhY3Rvcihpbm5lcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHsgcmV0dXJuIGlubmVyKGRhdGUsIGxvY2FsZSkuc3BsaXQoJyAnKVsxXTsgfTtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBpbm5lclxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gaG91ckV4dHJhY3Rvcihpbm5lcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHsgcmV0dXJuIGlubmVyKGRhdGUsIGxvY2FsZSkuc3BsaXQoJyAnKVswXTsgfTtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBkYXRlXHJcbiAqIEBwYXJhbSB7P30gbG9jYWxlXHJcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gaW50bERhdGVGb3JtYXQoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQoZGF0ZSkucmVwbGFjZSgvW1xcdTIwMGVcXHUyMDBmXS9nLCAnJyk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gdGltZXpvbmVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHRpbWVab25lR2V0dGVyKHRpbWV6b25lKSB7XHJcbiAgICAvLyBUbyB3b3JrYXJvdW5kIGBJbnRsYCBBUEkgcmVzdHJpY3Rpb24gZm9yIHNpbmdsZSB0aW1lem9uZSBsZXQgZm9ybWF0IHdpdGggMjQgaG91cnNcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnMgPSB7IGhvdXI6ICcyLWRpZ2l0JywgaG91cjEyOiBmYWxzZSwgdGltZVpvbmVOYW1lOiB0aW1lem9uZSB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBpbnRsRGF0ZUZvcm1hdChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpO1xyXG4gICAgICAgIC8vIFRoZW4gZXh0cmFjdCBmaXJzdCAzIGxldHRlcnMgdGhhdCByZWxhdGVkIHRvIGhvdXJzXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdC5zdWJzdHJpbmcoMykgOiAnJztcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xyXG4gKiBAcGFyYW0gez99IHZhbHVlXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBob3VyMTJNb2RpZnkob3B0aW9ucywgdmFsdWUpIHtcclxuICAgIG9wdGlvbnMuaG91cjEyID0gdmFsdWU7XHJcbiAgICByZXR1cm4gb3B0aW9ucztcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBwcm9wXHJcbiAqIEBwYXJhbSB7P30gbGVuXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBkaWdpdENvbmRpdGlvbihwcm9wLCBsZW4pIHtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHt9O1xyXG4gICAgcmVzdWx0W3Byb3BdID0gbGVuID09PSAyID8gJzItZGlnaXQnIDogJ251bWVyaWMnO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBwcm9wXHJcbiAqIEBwYXJhbSB7P30gbGVuXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBuYW1lQ29uZGl0aW9uKHByb3AsIGxlbikge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0ge307XHJcbiAgICBpZiAobGVuIDwgNCkge1xyXG4gICAgICAgIHJlc3VsdFtwcm9wXSA9IGxlbiA+IDEgPyAnc2hvcnQnIDogJ25hcnJvdyc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXN1bHRbcHJvcF0gPSAnbG9uZyc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IG9wdGlvbnNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGNvbWJpbmUob3B0aW9ucykge1xyXG4gICAgcmV0dXJuICgoT2JqZWN0KSkuYXNzaWduLmFwcGx5KCgoT2JqZWN0KSksIFt7fV0uY29uY2F0KG9wdGlvbnMpKTtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSByZXRcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShyZXQpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7IHJldHVybiBpbnRsRGF0ZUZvcm1hdChkYXRlLCBsb2NhbGUsIHJldCk7IH07XHJcbn1cclxudmFyIERBVEVfRk9STUFUVEVSX0NBQ0hFID0gbmV3IE1hcCgpO1xyXG4vKipcclxuICogQHBhcmFtIHs/fSBmb3JtYXRcclxuICogQHBhcmFtIHs/fSBkYXRlXHJcbiAqIEBwYXJhbSB7P30gbG9jYWxlXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBkYXRlRm9ybWF0dGVyKGZvcm1hdCwgZGF0ZSwgbG9jYWxlKSB7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbiA9IFBBVFRFUk5fQUxJQVNFU1tmb3JtYXRdO1xyXG4gICAgaWYgKGZuKVxyXG4gICAgICAgIHJldHVybiBmbihkYXRlLCBsb2NhbGUpO1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FjaGVLZXkgPSBmb3JtYXQ7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IERBVEVfRk9STUFUVEVSX0NBQ0hFLmdldChjYWNoZUtleSk7XHJcbiAgICBpZiAoIXBhcnRzKSB7XHJcbiAgICAgICAgcGFydHMgPSBbXTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaCA9IHZvaWQgMDtcclxuICAgICAgICBEQVRFX0ZPUk1BVFNfU1BMSVQuZXhlYyhmb3JtYXQpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIF9mb3JtYXQgPSBmb3JtYXQ7XHJcbiAgICAgICAgd2hpbGUgKF9mb3JtYXQpIHtcclxuICAgICAgICAgICAgbWF0Y2ggPSBEQVRFX0ZPUk1BVFNfU1BMSVQuZXhlYyhfZm9ybWF0KTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IHBhcnRzLmNvbmNhdChtYXRjaC5zbGljZSgxKSk7XHJcbiAgICAgICAgICAgICAgICBfZm9ybWF0ID0gKChwYXJ0cy5wb3AoKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChfZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIF9mb3JtYXQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERBVEVfRk9STUFUVEVSX0NBQ0hFLnNldChjYWNoZUtleSwgcGFydHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnRzLnJlZHVjZShmdW5jdGlvbiAodGV4dCwgcGFydCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZuID0gREFURV9GT1JNQVRTW3BhcnRdO1xyXG4gICAgICAgIHJldHVybiB0ZXh0ICsgKGZuID8gZm4oZGF0ZSwgbG9jYWxlKSA6IHBhcnRUb1RpbWUocGFydCkpO1xyXG4gICAgfSwgJycpO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHBhcnRcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHBhcnRUb1RpbWUocGFydCkge1xyXG4gICAgcmV0dXJuIHBhcnQgPT09ICdcXCdcXCcnID8gJ1xcJycgOiBwYXJ0LnJlcGxhY2UoLyheJ3wnJCkvZywgJycpLnJlcGxhY2UoLycnL2csICdcXCcnKTtcclxufVxyXG52YXIgRGF0ZUZvcm1hdHRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRlRm9ybWF0dGVyKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcclxuICAgICAqIEBwYXJhbSB7P30gbG9jYWxlXHJcbiAgICAgKiBAcGFyYW0gez99IHBhdHRlcm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERhdGVGb3JtYXR0ZXIuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSwgcGF0dGVybikge1xyXG4gICAgICAgIHJldHVybiBkYXRlRm9ybWF0dGVyKHBhdHRlcm4sIGRhdGUsIGxvY2FsZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGVGb3JtYXR0ZXI7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxudmFyIF9OVU1CRVJfRk9STUFUX1JFR0VYUCA9IC9eKFxcZCspP1xcLigoXFxkKykoLShcXGQrKSk/KT8kLztcclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gcGlwZVxyXG4gKiBAcGFyYW0gez99IGxvY2FsZVxyXG4gKiBAcGFyYW0gez99IHZhbHVlXHJcbiAqIEBwYXJhbSB7P30gc3R5bGVcclxuICogQHBhcmFtIHs/PX0gZGlnaXRzXHJcbiAqIEBwYXJhbSB7Pz19IGN1cnJlbmN5XHJcbiAqIEBwYXJhbSB7Pz19IGN1cnJlbmN5QXNTeW1ib2xcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihwaXBlLCBsb2NhbGUsIHZhbHVlLCBzdHlsZSwgZGlnaXRzLCBjdXJyZW5jeSwgY3VycmVuY3lBc1N5bWJvbCkge1xyXG4gICAgaWYgKGN1cnJlbmN5ID09PSB2b2lkIDApIHsgY3VycmVuY3kgPSBudWxsOyB9XHJcbiAgICBpZiAoY3VycmVuY3lBc1N5bWJvbCA9PT0gdm9pZCAwKSB7IGN1cnJlbmN5QXNTeW1ib2wgPSBmYWxzZTsgfVxyXG4gICAgaWYgKHZhbHVlID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAvLyBDb252ZXJ0IHN0cmluZ3MgdG8gbnVtYmVyc1xyXG4gICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGlzTnVtZXJpYyh2YWx1ZSkgPyArdmFsdWUgOiB2YWx1ZTtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgdGhyb3cgaW52YWxpZFBpcGVBcmd1bWVudEVycm9yKHBpcGUsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1pbkludCA9IHVuZGVmaW5lZDtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1pbkZyYWN0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF4RnJhY3Rpb24gPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoc3R5bGUgIT09IE51bWJlckZvcm1hdFN0eWxlLkN1cnJlbmN5KSB7XHJcbiAgICAgICAgLy8gcmVseSBvbiBJbnRsIGRlZmF1bHQgZm9yIGN1cnJlbmN5XHJcbiAgICAgICAgbWluSW50ID0gMTtcclxuICAgICAgICBtaW5GcmFjdGlvbiA9IDA7XHJcbiAgICAgICAgbWF4RnJhY3Rpb24gPSAzO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpZ2l0cykge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gZGlnaXRzLm1hdGNoKF9OVU1CRVJfRk9STUFUX1JFR0VYUCk7XHJcbiAgICAgICAgaWYgKHBhcnRzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkaWdpdHMgKyBcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbmZvIGZvciBudW1iZXIgcGlwZXNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJ0c1sxXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1pbkludCA9IHBhcnNlSW50QXV0b1JhZGl4KHBhcnRzWzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcnRzWzNdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbWluRnJhY3Rpb24gPSBwYXJzZUludEF1dG9SYWRpeChwYXJ0c1szXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJ0c1s1XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1heEZyYWN0aW9uID0gcGFyc2VJbnRBdXRvUmFkaXgocGFydHNbNV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBOdW1iZXJGb3JtYXR0ZXIuZm9ybWF0KC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKSwgbG9jYWxlLCBzdHlsZSwge1xyXG4gICAgICAgIG1pbmltdW1JbnRlZ2VyRGlnaXRzOiBtaW5JbnQsXHJcbiAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBtaW5GcmFjdGlvbixcclxuICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IG1heEZyYWN0aW9uLFxyXG4gICAgICAgIGN1cnJlbmN5OiBjdXJyZW5jeSxcclxuICAgICAgICBjdXJyZW5jeUFzU3ltYm9sOiBjdXJyZW5jeUFzU3ltYm9sLFxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFxcQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxyXG4gKiBcXEB3aGF0SXREb2VzIEZvcm1hdHMgYSBudW1iZXIgYWNjb3JkaW5nIHRvIGxvY2FsZSBydWxlcy5cclxuICogXFxAaG93VG9Vc2UgYG51bWJlcl9leHByZXNzaW9uIHwgbnVtYmVyWzpkaWdpdEluZm9dYFxyXG4gKlxyXG4gKiBGb3JtYXRzIGEgbnVtYmVyIGFzIHRleHQuIEdyb3VwIHNpemluZyBhbmQgc2VwYXJhdG9yIGFuZCBvdGhlciBsb2NhbGUtc3BlY2lmaWNcclxuICogY29uZmlndXJhdGlvbnMgYXJlIGJhc2VkIG9uIHRoZSBhY3RpdmUgbG9jYWxlLlxyXG4gKlxyXG4gKiB3aGVyZSBgZXhwcmVzc2lvbmAgaXMgYSBudW1iZXI6XHJcbiAqICAtIGBkaWdpdEluZm9gIGlzIGEgYHN0cmluZ2Agd2hpY2ggaGFzIGEgZm9sbG93aW5nIGZvcm1hdDogPGJyPlxyXG4gKiAgICAgPGNvZGU+e21pbkludGVnZXJEaWdpdHN9LnttaW5GcmFjdGlvbkRpZ2l0c30te21heEZyYWN0aW9uRGlnaXRzfTwvY29kZT5cclxuICogICAtIGBtaW5JbnRlZ2VyRGlnaXRzYCBpcyB0aGUgbWluaW11bSBudW1iZXIgb2YgaW50ZWdlciBkaWdpdHMgdG8gdXNlLiBEZWZhdWx0cyB0byBgMWAuXHJcbiAqICAgLSBgbWluRnJhY3Rpb25EaWdpdHNgIGlzIHRoZSBtaW5pbXVtIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgZnJhY3Rpb24uIERlZmF1bHRzIHRvIGAwYC5cclxuICogICAtIGBtYXhGcmFjdGlvbkRpZ2l0c2AgaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciBmcmFjdGlvbi4gRGVmYXVsdHMgdG8gYDNgLlxyXG4gKlxyXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgYWNjZXB0YWJsZSByYW5nZSBmb3IgZWFjaCBvZiB0aGVzZSBudW1iZXJzIGFuZCBvdGhlclxyXG4gKiBkZXRhaWxzIHNlZSB5b3VyIG5hdGl2ZSBpbnRlcm5hdGlvbmFsaXphdGlvbiBsaWJyYXJ5LlxyXG4gKlxyXG4gKiBXQVJOSU5HOiB0aGlzIHBpcGUgdXNlcyB0aGUgSW50ZXJuYXRpb25hbGl6YXRpb24gQVBJIHdoaWNoIGlzIG5vdCB5ZXQgYXZhaWxhYmxlIGluIGFsbCBicm93c2Vyc1xyXG4gKiBhbmQgbWF5IHJlcXVpcmUgYSBwb2x5ZmlsbC4gU2VlIHtcXEBsaW5rRG9jcyBndWlkZS9icm93c2VyLXN1cHBvcnR9IGZvciBkZXRhaWxzLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiB7XFxAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvbnVtYmVyX3BpcGUudHMgcmVnaW9uPSdOdW1iZXJQaXBlJ31cclxuICpcclxuICogXFxAc3RhYmxlXHJcbiAqL1xyXG52YXIgRGVjaW1hbFBpcGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IF9sb2NhbGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRGVjaW1hbFBpcGUoX2xvY2FsZSkge1xyXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Pz19IGRpZ2l0c1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRGVjaW1hbFBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGlnaXRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcihEZWNpbWFsUGlwZSwgdGhpcy5fbG9jYWxlLCB2YWx1ZSwgTnVtYmVyRm9ybWF0U3R5bGUuRGVjaW1hbCwgZGlnaXRzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVjaW1hbFBpcGU7XHJcbn0oKSk7XHJcbkRlY2ltYWxQaXBlLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ251bWJlcicgfSxdIH0sXHJcbl07XHJcbi8qKlxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuRGVjaW1hbFBpcGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLkxPQ0FMRV9JRCxdIH0sXSB9LFxyXG5dOyB9O1xyXG4vKipcclxuICogXFxAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXHJcbiAqIFxcQHdoYXRJdERvZXMgRm9ybWF0cyBhIG51bWJlciBhcyBhIHBlcmNlbnRhZ2UgYWNjb3JkaW5nIHRvIGxvY2FsZSBydWxlcy5cclxuICogXFxAaG93VG9Vc2UgYG51bWJlcl9leHByZXNzaW9uIHwgcGVyY2VudFs6ZGlnaXRJbmZvXWBcclxuICpcclxuICogXFxAZGVzY3JpcHRpb25cclxuICpcclxuICogRm9ybWF0cyBhIG51bWJlciBhcyBwZXJjZW50YWdlLlxyXG4gKlxyXG4gKiAtIGBkaWdpdEluZm9gIFNlZSB7XFxAbGluayBEZWNpbWFsUGlwZX0gZm9yIGRldGFpbGVkIGRlc2NyaXB0aW9uLlxyXG4gKlxyXG4gKiBXQVJOSU5HOiB0aGlzIHBpcGUgdXNlcyB0aGUgSW50ZXJuYXRpb25hbGl6YXRpb24gQVBJIHdoaWNoIGlzIG5vdCB5ZXQgYXZhaWxhYmxlIGluIGFsbCBicm93c2Vyc1xyXG4gKiBhbmQgbWF5IHJlcXVpcmUgYSBwb2x5ZmlsbC4gU2VlIHtcXEBsaW5rRG9jcyBndWlkZS9icm93c2VyLXN1cHBvcnR9IGZvciBkZXRhaWxzLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiB7XFxAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvbnVtYmVyX3BpcGUudHMgcmVnaW9uPSdQZXJjZW50UGlwZSd9XHJcbiAqXHJcbiAqIFxcQHN0YWJsZVxyXG4gKi9cclxudmFyIFBlcmNlbnRQaXBlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBfbG9jYWxlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFBlcmNlbnRQaXBlKF9sb2NhbGUpIHtcclxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gez89fSBkaWdpdHNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFBlcmNlbnRQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGRpZ2l0cykge1xyXG4gICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIoUGVyY2VudFBpcGUsIHRoaXMuX2xvY2FsZSwgdmFsdWUsIE51bWJlckZvcm1hdFN0eWxlLlBlcmNlbnQsIGRpZ2l0cyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBlcmNlbnRQaXBlO1xyXG59KCkpO1xyXG5QZXJjZW50UGlwZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdwZXJjZW50JyB9LF0gfSxcclxuXTtcclxuLyoqXHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5QZXJjZW50UGlwZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuTE9DQUxFX0lELF0gfSxdIH0sXHJcbl07IH07XHJcbi8qKlxyXG4gKiBcXEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcclxuICogXFxAd2hhdEl0RG9lcyBGb3JtYXRzIGEgbnVtYmVyIGFzIGN1cnJlbmN5IHVzaW5nIGxvY2FsZSBydWxlcy5cclxuICogXFxAaG93VG9Vc2UgYG51bWJlcl9leHByZXNzaW9uIHwgY3VycmVuY3lbOmN1cnJlbmN5Q29kZVs6c3ltYm9sRGlzcGxheVs6ZGlnaXRJbmZvXV1dYFxyXG4gKiBcXEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBVc2UgYGN1cnJlbmN5YCB0byBmb3JtYXQgYSBudW1iZXIgYXMgY3VycmVuY3kuXHJcbiAqXHJcbiAqIC0gYGN1cnJlbmN5Q29kZWAgaXMgdGhlIFtJU08gNDIxN10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzQyMTcpIGN1cnJlbmN5IGNvZGUsIHN1Y2hcclxuICogICAgYXMgYFVTRGAgZm9yIHRoZSBVUyBkb2xsYXIgYW5kIGBFVVJgIGZvciB0aGUgZXVyby5cclxuICogLSBgc3ltYm9sRGlzcGxheWAgaXMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byB1c2UgdGhlIGN1cnJlbmN5IHN5bWJvbCBvciBjb2RlLlxyXG4gKiAgIC0gYHRydWVgOiB1c2Ugc3ltYm9sIChlLmcuIGAkYCkuXHJcbiAqICAgLSBgZmFsc2VgKGRlZmF1bHQpOiB1c2UgY29kZSAoZS5nLiBgVVNEYCkuXHJcbiAqIC0gYGRpZ2l0SW5mb2AgU2VlIHtcXEBsaW5rIERlY2ltYWxQaXBlfSBmb3IgZGV0YWlsZWQgZGVzY3JpcHRpb24uXHJcbiAqXHJcbiAqIFdBUk5JTkc6IHRoaXMgcGlwZSB1c2VzIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBBUEkgd2hpY2ggaXMgbm90IHlldCBhdmFpbGFibGUgaW4gYWxsIGJyb3dzZXJzXHJcbiAqIGFuZCBtYXkgcmVxdWlyZSBhIHBvbHlmaWxsLiBTZWUge1xcQGxpbmtEb2NzIGd1aWRlL2Jyb3dzZXItc3VwcG9ydH0gZm9yIGRldGFpbHMuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIHtcXEBleGFtcGxlIGNvbW1vbi9waXBlcy90cy9udW1iZXJfcGlwZS50cyByZWdpb249J0N1cnJlbmN5UGlwZSd9XHJcbiAqXHJcbiAqIFxcQHN0YWJsZVxyXG4gKi9cclxudmFyIEN1cnJlbmN5UGlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gX2xvY2FsZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDdXJyZW5jeVBpcGUoX2xvY2FsZSkge1xyXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Pz19IGN1cnJlbmN5Q29kZVxyXG4gICAgICogQHBhcmFtIHs/PX0gc3ltYm9sRGlzcGxheVxyXG4gICAgICogQHBhcmFtIHs/PX0gZGlnaXRzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBDdXJyZW5jeVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgY3VycmVuY3lDb2RlLCBzeW1ib2xEaXNwbGF5LCBkaWdpdHMpIHtcclxuICAgICAgICBpZiAoY3VycmVuY3lDb2RlID09PSB2b2lkIDApIHsgY3VycmVuY3lDb2RlID0gJ1VTRCc7IH1cclxuICAgICAgICBpZiAoc3ltYm9sRGlzcGxheSA9PT0gdm9pZCAwKSB7IHN5bWJvbERpc3BsYXkgPSBmYWxzZTsgfVxyXG4gICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIoQ3VycmVuY3lQaXBlLCB0aGlzLl9sb2NhbGUsIHZhbHVlLCBOdW1iZXJGb3JtYXRTdHlsZS5DdXJyZW5jeSwgZGlnaXRzLCBjdXJyZW5jeUNvZGUsIHN5bWJvbERpc3BsYXkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDdXJyZW5jeVBpcGU7XHJcbn0oKSk7XHJcbkN1cnJlbmN5UGlwZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdjdXJyZW5jeScgfSxdIH0sXHJcbl07XHJcbi8qKlxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuQ3VycmVuY3lQaXBlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29yZS5MT0NBTEVfSUQsXSB9LF0gfSxcclxuXTsgfTtcclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gdGV4dFxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VJbnRBdXRvUmFkaXgodGV4dCkge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gcGFyc2VJbnQodGV4dCk7XHJcbiAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nICcgKyB0ZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gdmFsdWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGlzTnVtZXJpYyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICFpc05hTih2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpKTtcclxufVxyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbnZhciBJU084NjAxX0RBVEVfUkVHRVggPSAvXihcXGR7NH0pLT8oXFxkXFxkKS0/KFxcZFxcZCkoPzpUKFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/OlxcLihcXGQrKSk/KT8pPyhafChbKy1dKShcXGRcXGQpOj8oXFxkXFxkKSk/KT8kLztcclxuLyoqXHJcbiAqIFxcQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxyXG4gKiBcXEB3aGF0SXREb2VzIEZvcm1hdHMgYSBkYXRlIGFjY29yZGluZyB0byBsb2NhbGUgcnVsZXMuXHJcbiAqIFxcQGhvd1RvVXNlIGBkYXRlX2V4cHJlc3Npb24gfCBkYXRlWzpmb3JtYXRdYFxyXG4gKiBcXEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBXaGVyZTpcclxuICogLSBgZXhwcmVzc2lvbmAgaXMgYSBkYXRlIG9iamVjdCBvciBhIG51bWJlciAobWlsbGlzZWNvbmRzIHNpbmNlIFVUQyBlcG9jaCkgb3IgYW4gSVNPIHN0cmluZ1xyXG4gKiAoaHR0cHM6Ly93d3cudzMub3JnL1RSL05PVEUtZGF0ZXRpbWUpLlxyXG4gKiAtIGBmb3JtYXRgIGluZGljYXRlcyB3aGljaCBkYXRlL3RpbWUgY29tcG9uZW50cyB0byBpbmNsdWRlLiBUaGUgZm9ybWF0IGNhbiBiZSBwcmVkZWZpbmVkIGFzXHJcbiAqICAgc2hvd24gYmVsb3cgb3IgY3VzdG9tIGFzIHNob3duIGluIHRoZSB0YWJsZS5cclxuICogICAtIGAnbWVkaXVtJ2A6IGVxdWl2YWxlbnQgdG8gYCd5TU1NZGptcydgIChlLmcuIGBTZXAgMywgMjAxMCwgMTI6MDU6MDggUE1gIGZvciBgZW4tVVNgKVxyXG4gKiAgIC0gYCdzaG9ydCdgOiBlcXVpdmFsZW50IHRvIGAneU1kam0nYCAoZS5nLiBgOS8zLzIwMTAsIDEyOjA1IFBNYCBmb3IgYGVuLVVTYClcclxuICogICAtIGAnZnVsbERhdGUnYDogZXF1aXZhbGVudCB0byBgJ3lNTU1NRUVFRWQnYCAoZS5nLiBgRnJpZGF5LCBTZXB0ZW1iZXIgMywgMjAxMGAgZm9yIGBlbi1VU2ApXHJcbiAqICAgLSBgJ2xvbmdEYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCd5TU1NTWQnYCAoZS5nLiBgU2VwdGVtYmVyIDMsIDIwMTBgIGZvciBgZW4tVVNgKVxyXG4gKiAgIC0gYCdtZWRpdW1EYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCd5TU1NZCdgIChlLmcuIGBTZXAgMywgMjAxMGAgZm9yIGBlbi1VU2ApXHJcbiAqICAgLSBgJ3Nob3J0RGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAneU1kJ2AgKGUuZy4gYDkvMy8yMDEwYCBmb3IgYGVuLVVTYClcclxuICogICAtIGAnbWVkaXVtVGltZSdgOiBlcXVpdmFsZW50IHRvIGAnam1zJ2AgKGUuZy4gYDEyOjA1OjA4IFBNYCBmb3IgYGVuLVVTYClcclxuICogICAtIGAnc2hvcnRUaW1lJ2A6IGVxdWl2YWxlbnQgdG8gYCdqbSdgIChlLmcuIGAxMjowNSBQTWAgZm9yIGBlbi1VU2ApXHJcbiAqXHJcbiAqXHJcbiAqICB8IENvbXBvbmVudCB8IFN5bWJvbCB8IE5hcnJvdyB8IFNob3J0IEZvcm0gICB8IExvbmcgRm9ybSAgICAgICAgIHwgTnVtZXJpYyAgIHwgMi1kaWdpdCAgIHxcclxuICogIHwtLS0tLS0tLS0tLXw6LS0tLS0tOnwtLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tfFxyXG4gKiAgfCBlcmEgICAgICAgfCAgIEcgICAgfCBHIChBKSAgfCBHR0cgKEFEKSAgICAgfCBHR0dHIChBbm5vIERvbWluaSl8IC0gICAgICAgICB8IC0gICAgICAgICB8XHJcbiAqICB8IHllYXIgICAgICB8ICAgeSAgICB8IC0gICAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgeSAoMjAxNSkgIHwgeXkgKDE1KSAgIHxcclxuICogIHwgbW9udGggICAgIHwgICBNICAgIHwgTCAoUykgIHwgTU1NIChTZXApICAgIHwgTU1NTSAoU2VwdGVtYmVyKSAgfCBNICg5KSAgICAgfCBNTSAoMDkpICAgfFxyXG4gKiAgfCBkYXkgICAgICAgfCAgIGQgICAgfCAtICAgICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IGQgKDMpICAgICB8IGRkICgwMykgICB8XHJcbiAqICB8IHdlZWtkYXkgICB8ICAgRSAgICB8IEUgKFMpICB8IEVFRSAoU3VuKSAgICB8IEVFRUUgKFN1bmRheSkgICAgIHwgLSAgICAgICAgIHwgLSAgICAgICAgIHxcclxuICogIHwgaG91ciAgICAgIHwgICBqICAgIHwgLSAgICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBqICgxMykgICAgfCBqaiAoMTMpICAgfFxyXG4gKiAgfCBob3VyMTIgICAgfCAgIGggICAgfCAtICAgICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IGggKDEgUE0pICB8IGhoICgwMSBQTSl8XHJcbiAqICB8IGhvdXIyNCAgICB8ICAgSCAgICB8IC0gICAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgSCAoMTMpICAgIHwgSEggKDEzKSAgIHxcclxuICogIHwgbWludXRlICAgIHwgICBtICAgIHwgLSAgICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBtICg1KSAgICAgfCBtbSAoMDUpICAgfFxyXG4gKiAgfCBzZWNvbmQgICAgfCAgIHMgICAgfCAtICAgICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IHMgKDkpICAgICB8IHNzICgwOSkgICB8XHJcbiAqICB8IHRpbWV6b25lICB8ICAgeiAgICB8IC0gICAgICB8IC0gICAgICAgICAgICB8IHogKFBhY2lmaWMgU3RhbmRhcmQgVGltZSl8IC0gIHwgLSAgICAgICAgIHxcclxuICogIHwgdGltZXpvbmUgIHwgICBaICAgIHwgLSAgICAgIHwgWiAoR01ULTg6MDApIHwgLSAgICAgICAgICAgICAgICAgfCAtICAgICAgICAgfCAtICAgICAgICAgfFxyXG4gKiAgfCB0aW1lem9uZSAgfCAgIGEgICAgfCAtICAgICAgfCBhIChQTSkgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IC0gICAgICAgICB8IC0gICAgICAgICB8XHJcbiAqXHJcbiAqIEluIGphdmFzY3JpcHQsIG9ubHkgdGhlIGNvbXBvbmVudHMgc3BlY2lmaWVkIHdpbGwgYmUgcmVzcGVjdGVkIChub3QgdGhlIG9yZGVyaW5nLFxyXG4gKiBwdW5jdHVhdGlvbnMsIC4uLikgYW5kIGRldGFpbHMgb2YgdGhlIGZvcm1hdHRpbmcgd2lsbCBiZSBkZXBlbmRlbnQgb24gdGhlIGxvY2FsZS5cclxuICpcclxuICogVGltZXpvbmUgb2YgdGhlIGZvcm1hdHRlZCB0ZXh0IHdpbGwgYmUgdGhlIGxvY2FsIHN5c3RlbSB0aW1lem9uZSBvZiB0aGUgZW5kLXVzZXIncyBtYWNoaW5lLlxyXG4gKlxyXG4gKiBXaGVuIHRoZSBleHByZXNzaW9uIGlzIGEgSVNPIHN0cmluZyB3aXRob3V0IHRpbWUgKGUuZy4gMjAxNi0wOS0xOSkgdGhlIHRpbWUgem9uZSBvZmZzZXQgaXMgbm90XHJcbiAqIGFwcGxpZWQgYW5kIHRoZSBmb3JtYXR0ZWQgdGV4dCB3aWxsIGhhdmUgdGhlIHNhbWUgZGF5LCBtb250aCBhbmQgeWVhciBvZiB0aGUgZXhwcmVzc2lvbi5cclxuICpcclxuICogV0FSTklOR1M6XHJcbiAqIC0gdGhpcyBwaXBlIGlzIG1hcmtlZCBhcyBwdXJlIGhlbmNlIGl0IHdpbGwgbm90IGJlIHJlLWV2YWx1YXRlZCB3aGVuIHRoZSBpbnB1dCBpcyBtdXRhdGVkLlxyXG4gKiAgIEluc3RlYWQgdXNlcnMgc2hvdWxkIHRyZWF0IHRoZSBkYXRlIGFzIGFuIGltbXV0YWJsZSBvYmplY3QgYW5kIGNoYW5nZSB0aGUgcmVmZXJlbmNlIHdoZW4gdGhlXHJcbiAqICAgcGlwZSBuZWVkcyB0byByZS1ydW4gKHRoaXMgaXMgdG8gYXZvaWQgcmVmb3JtYXR0aW5nIHRoZSBkYXRlIG9uIGV2ZXJ5IGNoYW5nZSBkZXRlY3Rpb24gcnVuXHJcbiAqICAgd2hpY2ggd291bGQgYmUgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbikuXHJcbiAqIC0gdGhpcyBwaXBlIHVzZXMgdGhlIEludGVybmF0aW9uYWxpemF0aW9uIEFQSS4gVGhlcmVmb3JlIGl0IGlzIG9ubHkgcmVsaWFibGUgaW4gQ2hyb21lIGFuZCBPcGVyYVxyXG4gKiAgIGJyb3dzZXJzLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZXNcclxuICpcclxuICogQXNzdW1pbmcgYGRhdGVPYmpgIGlzICh5ZWFyOiAyMDE1LCBtb250aDogNiwgZGF5OiAxNSwgaG91cjogMjEsIG1pbnV0ZTogNDMsIHNlY29uZDogMTEpXHJcbiAqIGluIHRoZSBfbG9jYWxfIHRpbWUgYW5kIGxvY2FsZSBpcyAnZW4tVVMnOlxyXG4gKlxyXG4gKiBgYGBcclxuICogICAgIHt7IGRhdGVPYmogfCBkYXRlIH19ICAgICAgICAgICAgICAgLy8gb3V0cHV0IGlzICdKdW4gMTUsIDIwMTUnXHJcbiAqICAgICB7eyBkYXRlT2JqIHwgZGF0ZTonbWVkaXVtJyB9fSAgICAgIC8vIG91dHB1dCBpcyAnSnVuIDE1LCAyMDE1LCA5OjQzOjExIFBNJ1xyXG4gKiAgICAge3sgZGF0ZU9iaiB8IGRhdGU6J3Nob3J0VGltZScgfX0gICAvLyBvdXRwdXQgaXMgJzk6NDMgUE0nXHJcbiAqICAgICB7eyBkYXRlT2JqIHwgZGF0ZTonbW1zcycgfX0gICAgICAgIC8vIG91dHB1dCBpcyAnNDM6MTEnXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiB7XFxAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvZGF0ZV9waXBlLnRzIHJlZ2lvbj0nRGF0ZVBpcGUnfVxyXG4gKlxyXG4gKiBcXEBzdGFibGVcclxuICovXHJcbnZhciBEYXRlUGlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gX2xvY2FsZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBEYXRlUGlwZShfbG9jYWxlKSB7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gX2xvY2FsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHs/PX0gcGF0dGVyblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRGF0ZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgcGF0dGVybikge1xyXG4gICAgICAgIGlmIChwYXR0ZXJuID09PSB2b2lkIDApIHsgcGF0dGVybiA9ICdtZWRpdW1EYXRlJzsgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRhdGU7XHJcbiAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpIHx8IHZhbHVlICE9PSB2YWx1ZSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNOdW1lcmljKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUocGFyc2VGbG9hdCh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC9eKFxcZHs0fS1cXGR7MSwyfS1cXGR7MSwyfSkkLy50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgKiBGb3IgSVNPIFN0cmluZ3Mgd2l0aG91dCB0aW1lIHRoZSBkYXksIG1vbnRoIGFuZCB5ZWFyIG11c3QgYmUgZXh0cmFjdGVkIGZyb20gdGhlIElTTyBTdHJpbmdcclxuICAgICAgICAgICAgKiBiZWZvcmUgRGF0ZSBjcmVhdGlvbiB0byBhdm9pZCB0aW1lIG9mZnNldCBhbmQgZXJyb3JzIGluIHRoZSBuZXcgRGF0ZS5cclxuICAgICAgICAgICAgKiBJZiB3ZSBvbmx5IHJlcGxhY2UgJy0nIHdpdGggJywnIGluIHRoZSBJU08gU3RyaW5nIChcIjIwMTUsMDEsMDFcIiksIGFuZCB0cnkgdG8gY3JlYXRlIGEgbmV3XHJcbiAgICAgICAgICAgICogZGF0ZSwgc29tZSBicm93c2VycyAoZS5nLiBJRSA5KSB3aWxsIHRocm93IGFuIGludmFsaWQgRGF0ZSBlcnJvclxyXG4gICAgICAgICAgICAqIElmIHdlIGxlYXZlIHRoZSAnLScgKFwiMjAxNS0wMS0wMVwiKSBhbmQgdHJ5IHRvIGNyZWF0ZSBhIG5ldyBEYXRlKFwiMjAxNS0wMS0wMVwiKSB0aGUgdGltZW9mZnNldFxyXG4gICAgICAgICAgICAqIGlzIGFwcGxpZWRcclxuICAgICAgICAgICAgKiBOb3RlOiBJU08gbW9udGhzIGFyZSAwIGZvciBKYW51YXJ5LCAxIGZvciBGZWJydWFyeSwgLi4uXHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBfYSA9IHZhbHVlLnNwbGl0KCctJykubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApOyB9KSwgeSA9IF9hWzBdLCBtID0gX2FbMV0sIGQgPSBfYVsyXTtcclxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHksIG0gLSAxLCBkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNEYXRlKGRhdGUpKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoID0gdm9pZCAwO1xyXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpICYmIChtYXRjaCA9IHZhbHVlLm1hdGNoKElTTzg2MDFfREFURV9SRUdFWCkpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlID0gaXNvU3RyaW5nVG9EYXRlKG1hdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGludmFsaWRQaXBlQXJndW1lbnRFcnJvcihEYXRlUGlwZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBEYXRlRm9ybWF0dGVyLmZvcm1hdChkYXRlLCB0aGlzLl9sb2NhbGUsIERhdGVQaXBlLl9BTElBU0VTW3BhdHRlcm5dIHx8IHBhdHRlcm4pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXRlUGlwZTtcclxufSgpKTtcclxuLyoqXHJcbiAqIFxcQGludGVybmFsXHJcbiAqL1xyXG5EYXRlUGlwZS5fQUxJQVNFUyA9IHtcclxuICAgICdtZWRpdW0nOiAneU1NTWRqbXMnLFxyXG4gICAgJ3Nob3J0JzogJ3lNZGptJyxcclxuICAgICdmdWxsRGF0ZSc6ICd5TU1NTUVFRUVkJyxcclxuICAgICdsb25nRGF0ZSc6ICd5TU1NTWQnLFxyXG4gICAgJ21lZGl1bURhdGUnOiAneU1NTWQnLFxyXG4gICAgJ3Nob3J0RGF0ZSc6ICd5TWQnLFxyXG4gICAgJ21lZGl1bVRpbWUnOiAnam1zJyxcclxuICAgICdzaG9ydFRpbWUnOiAnam0nXHJcbn07XHJcbkRhdGVQaXBlLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ2RhdGUnLCBwdXJlOiB0cnVlIH0sXSB9LFxyXG5dO1xyXG4vKipcclxuICogQG5vY29sbGFwc2VcclxuICovXHJcbkRhdGVQaXBlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29yZS5MT0NBTEVfSUQsXSB9LF0gfSxcclxuXTsgfTtcclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gb2JqXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0JsYW5rKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiA9PSBudWxsIHx8IG9iaiA9PT0gJyc7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gb2JqXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4ob2JqLnZhbHVlT2YoKSk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gbWF0Y2hcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGlzb1N0cmluZ1RvRGF0ZShtYXRjaCkge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGF0ZSA9IG5ldyBEYXRlKDApO1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHpIb3VyID0gMDtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHR6TWluID0gMDtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRhdGVTZXR0ZXIgPSBtYXRjaFs4XSA/IGRhdGUuc2V0VVRDRnVsbFllYXIgOiBkYXRlLnNldEZ1bGxZZWFyO1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZVNldHRlciA9IG1hdGNoWzhdID8gZGF0ZS5zZXRVVENIb3VycyA6IGRhdGUuc2V0SG91cnM7XHJcbiAgICBpZiAobWF0Y2hbOV0pIHtcclxuICAgICAgICB0ekhvdXIgPSB0b0ludChtYXRjaFs5XSArIG1hdGNoWzEwXSk7XHJcbiAgICAgICAgdHpNaW4gPSB0b0ludChtYXRjaFs5XSArIG1hdGNoWzExXSk7XHJcbiAgICB9XHJcbiAgICBkYXRlU2V0dGVyLmNhbGwoZGF0ZSwgdG9JbnQobWF0Y2hbMV0pLCB0b0ludChtYXRjaFsyXSkgLSAxLCB0b0ludChtYXRjaFszXSkpO1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaCA9IHRvSW50KG1hdGNoWzRdIHx8ICcwJykgLSB0ekhvdXI7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtID0gdG9JbnQobWF0Y2hbNV0gfHwgJzAnKSAtIHR6TWluO1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcyA9IHRvSW50KG1hdGNoWzZdIHx8ICcwJyk7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtcyA9IE1hdGgucm91bmQocGFyc2VGbG9hdCgnMC4nICsgKG1hdGNoWzddIHx8IDApKSAqIDEwMDApO1xyXG4gICAgdGltZVNldHRlci5jYWxsKGRhdGUsIGgsIG0sIHMsIG1zKTtcclxuICAgIHJldHVybiBkYXRlO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHN0clxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gdG9JbnQoc3RyKSB7XHJcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxMCk7XHJcbn1cclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG52YXIgX0lOVEVSUE9MQVRJT05fUkVHRVhQID0gLyMvZztcclxuLyoqXHJcbiAqIFxcQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxyXG4gKiBcXEB3aGF0SXREb2VzIE1hcHMgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IHBsdXJhbGl6ZXMgdGhlIHZhbHVlIGFjY29yZGluZyB0byBsb2NhbGUgcnVsZXMuXHJcbiAqIFxcQGhvd1RvVXNlIGBleHByZXNzaW9uIHwgaTE4blBsdXJhbDptYXBwaW5nYFxyXG4gKiBcXEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiAgV2hlcmU6XHJcbiAqICAtIGBleHByZXNzaW9uYCBpcyBhIG51bWJlci5cclxuICogIC0gYG1hcHBpbmdgIGlzIGFuIG9iamVjdCB0aGF0IG1pbWljcyB0aGUgSUNVIGZvcm1hdCwgc2VlXHJcbiAqICAgIGh0dHA6Ly91c2VyZ3VpZGUuaWN1LXByb2plY3Qub3JnL2Zvcm1hdHBhcnNlL21lc3NhZ2VzXHJcbiAqXHJcbiAqICAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIHtcXEBleGFtcGxlIGNvbW1vbi9waXBlcy90cy9pMThuX3BpcGUudHMgcmVnaW9uPSdJMThuUGx1cmFsUGlwZUNvbXBvbmVudCd9XHJcbiAqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxudmFyIEkxOG5QbHVyYWxQaXBlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBfbG9jYWxpemF0aW9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEkxOG5QbHVyYWxQaXBlKF9sb2NhbGl6YXRpb24pIHtcclxuICAgICAgICB0aGlzLl9sb2NhbGl6YXRpb24gPSBfbG9jYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gez99IHBsdXJhbE1hcFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgSTE4blBsdXJhbFBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgcGx1cmFsTWFwKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICBpZiAodHlwZW9mIHBsdXJhbE1hcCAhPT0gJ29iamVjdCcgfHwgcGx1cmFsTWFwID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IGludmFsaWRQaXBlQXJndW1lbnRFcnJvcihJMThuUGx1cmFsUGlwZSwgcGx1cmFsTWFwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gZ2V0UGx1cmFsQ2F0ZWdvcnkodmFsdWUsIE9iamVjdC5rZXlzKHBsdXJhbE1hcCksIHRoaXMuX2xvY2FsaXphdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHBsdXJhbE1hcFtrZXldLnJlcGxhY2UoX0lOVEVSUE9MQVRJT05fUkVHRVhQLCB2YWx1ZS50b1N0cmluZygpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSTE4blBsdXJhbFBpcGU7XHJcbn0oKSk7XHJcbkkxOG5QbHVyYWxQaXBlLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ2kxOG5QbHVyYWwnLCBwdXJlOiB0cnVlIH0sXSB9LFxyXG5dO1xyXG4vKipcclxuICogQG5vY29sbGFwc2VcclxuICovXHJcbkkxOG5QbHVyYWxQaXBlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgeyB0eXBlOiBOZ0xvY2FsaXphdGlvbiwgfSxcclxuXTsgfTtcclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogXFxAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXHJcbiAqIFxcQHdoYXRJdERvZXMgR2VuZXJpYyBzZWxlY3RvciB0aGF0IGRpc3BsYXlzIHRoZSBzdHJpbmcgdGhhdCBtYXRjaGVzIHRoZSBjdXJyZW50IHZhbHVlLlxyXG4gKiBcXEBob3dUb1VzZSBgZXhwcmVzc2lvbiB8IGkxOG5TZWxlY3Q6bWFwcGluZ2BcclxuICogXFxAZGVzY3JpcHRpb25cclxuICpcclxuICogIFdoZXJlIGBtYXBwaW5nYCBpcyBhbiBvYmplY3QgdGhhdCBpbmRpY2F0ZXMgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkXHJcbiAqICBmb3IgZGlmZmVyZW50IHZhbHVlcyBvZiB0aGUgcHJvdmlkZWQgYGV4cHJlc3Npb25gLlxyXG4gKiAgSWYgbm9uZSBvZiB0aGUga2V5cyBvZiB0aGUgbWFwcGluZyBtYXRjaCB0aGUgdmFsdWUgb2YgdGhlIGBleHByZXNzaW9uYCwgdGhlbiB0aGUgY29udGVudFxyXG4gKiAgb2YgdGhlIGBvdGhlcmAga2V5IGlzIHJldHVybmVkIHdoZW4gcHJlc2VudCwgb3RoZXJ3aXNlIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cclxuICpcclxuICogICMjIEV4YW1wbGVcclxuICpcclxuICoge1xcQGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2kxOG5fcGlwZS50cyByZWdpb249J0kxOG5TZWxlY3RQaXBlQ29tcG9uZW50J31cclxuICpcclxuICogIFxcQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxudmFyIEkxOG5TZWxlY3RQaXBlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEkxOG5TZWxlY3RQaXBlKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gez99IG1hcHBpbmdcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEkxOG5TZWxlY3RQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIG1hcHBpbmcpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWFwcGluZyAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IoSTE4blNlbGVjdFBpcGUsIG1hcHBpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWFwcGluZy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hcHBpbmdbdmFsdWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWFwcGluZy5oYXNPd25Qcm9wZXJ0eSgnb3RoZXInKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwcGluZ1snb3RoZXInXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJMThuU2VsZWN0UGlwZTtcclxufSgpKTtcclxuSTE4blNlbGVjdFBpcGUuZGVjb3JhdG9ycyA9IFtcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnaTE4blNlbGVjdCcsIHB1cmU6IHRydWUgfSxdIH0sXHJcbl07XHJcbi8qKlxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuSTE4blNlbGVjdFBpcGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogXFxAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXHJcbiAqIFxcQHdoYXRJdERvZXMgQ29udmVydHMgdmFsdWUgaW50byBKU09OIHN0cmluZy5cclxuICogXFxAaG93VG9Vc2UgYGV4cHJlc3Npb24gfCBqc29uYFxyXG4gKiBcXEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBDb252ZXJ0cyB2YWx1ZSBpbnRvIHN0cmluZyB1c2luZyBgSlNPTi5zdHJpbmdpZnlgLiBVc2VmdWwgZm9yIGRlYnVnZ2luZy5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICoge1xcQGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2pzb25fcGlwZS50cyByZWdpb249J0pzb25QaXBlJ31cclxuICpcclxuICogXFxAc3RhYmxlXHJcbiAqL1xyXG52YXIgSnNvblBpcGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSnNvblBpcGUoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEpzb25QaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAyKTsgfTtcclxuICAgIHJldHVybiBKc29uUGlwZTtcclxufSgpKTtcclxuSnNvblBpcGUuZGVjb3JhdG9ycyA9IFtcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnanNvbicsIHB1cmU6IGZhbHNlIH0sXSB9LFxyXG5dO1xyXG4vKipcclxuICogQG5vY29sbGFwc2VcclxuICovXHJcbkpzb25QaXBlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIFxcQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxyXG4gKiBcXEB3aGF0SXREb2VzIENyZWF0ZXMgYSBuZXcgTGlzdCBvciBTdHJpbmcgY29udGFpbmluZyBhIHN1YnNldCAoc2xpY2UpIG9mIHRoZSBlbGVtZW50cy5cclxuICogXFxAaG93VG9Vc2UgYGFycmF5X29yX3N0cmluZ19leHByZXNzaW9uIHwgc2xpY2U6c3RhcnRbOmVuZF1gXHJcbiAqIFxcQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIFdoZXJlIHRoZSBpbnB1dCBleHByZXNzaW9uIGlzIGEgYExpc3RgIG9yIGBTdHJpbmdgLCBhbmQ6XHJcbiAqIC0gYHN0YXJ0YDogVGhlIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBzdWJzZXQgdG8gcmV0dXJuLlxyXG4gKiAgIC0gKiphIHBvc2l0aXZlIGludGVnZXIqKjogcmV0dXJuIHRoZSBpdGVtIGF0IGBzdGFydGAgaW5kZXggYW5kIGFsbCBpdGVtcyBhZnRlclxyXG4gKiAgICAgaW4gdGhlIGxpc3Qgb3Igc3RyaW5nIGV4cHJlc3Npb24uXHJcbiAqICAgLSAqKmEgbmVnYXRpdmUgaW50ZWdlcioqOiByZXR1cm4gdGhlIGl0ZW0gYXQgYHN0YXJ0YCBpbmRleCBmcm9tIHRoZSBlbmQgYW5kIGFsbCBpdGVtcyBhZnRlclxyXG4gKiAgICAgaW4gdGhlIGxpc3Qgb3Igc3RyaW5nIGV4cHJlc3Npb24uXHJcbiAqICAgLSAqKmlmIHBvc2l0aXZlIGFuZCBncmVhdGVyIHRoYW4gdGhlIHNpemUgb2YgdGhlIGV4cHJlc3Npb24qKjogcmV0dXJuIGFuIGVtcHR5IGxpc3Qgb3Igc3RyaW5nLlxyXG4gKiAgIC0gKippZiBuZWdhdGl2ZSBhbmQgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBleHByZXNzaW9uKio6IHJldHVybiBlbnRpcmUgbGlzdCBvciBzdHJpbmcuXHJcbiAqIC0gYGVuZGA6IFRoZSBlbmRpbmcgaW5kZXggb2YgdGhlIHN1YnNldCB0byByZXR1cm4uXHJcbiAqICAgLSAqKm9taXR0ZWQqKjogcmV0dXJuIGFsbCBpdGVtcyB1bnRpbCB0aGUgZW5kLlxyXG4gKiAgIC0gKippZiBwb3NpdGl2ZSoqOiByZXR1cm4gYWxsIGl0ZW1zIGJlZm9yZSBgZW5kYCBpbmRleCBvZiB0aGUgbGlzdCBvciBzdHJpbmcuXHJcbiAqICAgLSAqKmlmIG5lZ2F0aXZlKio6IHJldHVybiBhbGwgaXRlbXMgYmVmb3JlIGBlbmRgIGluZGV4IGZyb20gdGhlIGVuZCBvZiB0aGUgbGlzdCBvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEFsbCBiZWhhdmlvciBpcyBiYXNlZCBvbiB0aGUgZXhwZWN0ZWQgYmVoYXZpb3Igb2YgdGhlIEphdmFTY3JpcHQgQVBJIGBBcnJheS5wcm90b3R5cGUuc2xpY2UoKWBcclxuICogYW5kIGBTdHJpbmcucHJvdG90eXBlLnNsaWNlKClgLlxyXG4gKlxyXG4gKiBXaGVuIG9wZXJhdGluZyBvbiBhIFtMaXN0XSwgdGhlIHJldHVybmVkIGxpc3QgaXMgYWx3YXlzIGEgY29weSBldmVuIHdoZW4gYWxsXHJcbiAqIHRoZSBlbGVtZW50cyBhcmUgYmVpbmcgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIFdoZW4gb3BlcmF0aW5nIG9uIGEgYmxhbmsgdmFsdWUsIHRoZSBwaXBlIHJldHVybnMgdGhlIGJsYW5rIHZhbHVlLlxyXG4gKlxyXG4gKiAjIyBMaXN0IEV4YW1wbGVcclxuICpcclxuICogVGhpcyBgbmdGb3JgIGV4YW1wbGU6XHJcbiAqXHJcbiAqIHtcXEBleGFtcGxlIGNvbW1vbi9waXBlcy90cy9zbGljZV9waXBlLnRzIHJlZ2lvbj0nU2xpY2VQaXBlX2xpc3QnfVxyXG4gKlxyXG4gKiBwcm9kdWNlcyB0aGUgZm9sbG93aW5nOlxyXG4gKlxyXG4gKiAgICAgPGxpPmI8L2xpPlxyXG4gKiAgICAgPGxpPmM8L2xpPlxyXG4gKlxyXG4gKiAjIyBTdHJpbmcgRXhhbXBsZXNcclxuICpcclxuICoge1xcQGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL3NsaWNlX3BpcGUudHMgcmVnaW9uPSdTbGljZVBpcGVfc3RyaW5nJ31cclxuICpcclxuICogXFxAc3RhYmxlXHJcbiAqL1xyXG52YXIgU2xpY2VQaXBlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNsaWNlUGlwZSgpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxyXG4gICAgICogQHBhcmFtIHs/PX0gZW5kXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBTbGljZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IoU2xpY2VQaXBlLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZS5zbGljZShzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gb2JqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBTbGljZVBpcGUucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShvYmopOyB9O1xyXG4gICAgcmV0dXJuIFNsaWNlUGlwZTtcclxufSgpKTtcclxuU2xpY2VQaXBlLmRlY29yYXRvcnMgPSBbXHJcbiAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ3NsaWNlJywgcHVyZTogZmFsc2UgfSxdIH0sXHJcbl07XHJcbi8qKlxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuU2xpY2VQaXBlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIEBtb2R1bGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgc2V0IG9mIGNvbW1vbiBQaXBlcy5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2YgQW5ndWxhciBwaXBlcyB0aGF0IGFyZSBsaWtlbHkgdG8gYmUgdXNlZCBpbiBlYWNoIGFuZCBldmVyeSBhcHBsaWNhdGlvbi5cclxuICovXHJcbnZhciBDT01NT05fUElQRVMgPSBbXHJcbiAgICBBc3luY1BpcGUsXHJcbiAgICBVcHBlckNhc2VQaXBlLFxyXG4gICAgTG93ZXJDYXNlUGlwZSxcclxuICAgIEpzb25QaXBlLFxyXG4gICAgU2xpY2VQaXBlLFxyXG4gICAgRGVjaW1hbFBpcGUsXHJcbiAgICBQZXJjZW50UGlwZSxcclxuICAgIFRpdGxlQ2FzZVBpcGUsXHJcbiAgICBDdXJyZW5jeVBpcGUsXHJcbiAgICBEYXRlUGlwZSxcclxuICAgIEkxOG5QbHVyYWxQaXBlLFxyXG4gICAgSTE4blNlbGVjdFBpcGUsXHJcbl07XHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBtb2R1bGUgdGhhdCBpbmNsdWRlcyBhbGwgdGhlIGJhc2ljIEFuZ3VsYXIgZGlyZWN0aXZlcyBsaWtlIHtcXEBsaW5rIE5nSWZ9LCB7XFxAbGluayBOZ0Zvck9mfSwgLi4uXHJcbiAqXHJcbiAqIFxcQHN0YWJsZVxyXG4gKi9cclxudmFyIENvbW1vbk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21tb25Nb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ29tbW9uTW9kdWxlO1xyXG59KCkpO1xyXG5Db21tb25Nb2R1bGUuZGVjb3JhdG9ycyA9IFtcclxuICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcclxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0NPTU1PTl9ESVJFQ1RJVkVTLCBDT01NT05fUElQRVNdLFxyXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0NPTU1PTl9ESVJFQ1RJVkVTLCBDT01NT05fUElQRVNdLFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOZ0xvY2FsaXphdGlvbiwgdXNlQ2xhc3M6IE5nTG9jYWxlTG9jYWxpemF0aW9uIH0sXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB9LF0gfSxcclxuXTtcclxuLyoqXHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5Db21tb25Nb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogQG1vZHVsZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBwdWJsaWMgQVBJcyBvZiB0aGUgY29tbW9uIHBhY2thZ2UuXHJcbiAqL1xyXG4vKipcclxuICogXFxAc3RhYmxlXHJcbiAqL1xyXG52YXIgVkVSU0lPTiA9IG5ldyBfYW5ndWxhcl9jb3JlLlZlcnNpb24oJzQuMS4zJyk7XHJcblxyXG52YXIgQW5ndWxhckZvbnRBd2Vzb21lTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFuZ3VsYXJGb250QXdlc29tZU1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBBbmd1bGFyRm9udEF3ZXNvbWVNb2R1bGU7XHJcbn0oKSk7XHJcbkFuZ3VsYXJGb250QXdlc29tZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXHJcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtBbmd1bGFyRm9udEF3ZXNvbWVDb21wb25lbnRdLFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbQW5ndWxhckZvbnRBd2Vzb21lU2VydmljZV0sXHJcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbQW5ndWxhckZvbnRBd2Vzb21lQ29tcG9uZW50XVxyXG4gICAgICAgICAgICB9LF0gfSxcclxuXTtcclxuLyoqXHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5Bbmd1bGFyRm9udEF3ZXNvbWVNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cclxuICovXHJcblxyXG5leHBvcnRzLkFuZ3VsYXJGb250QXdlc29tZUNvbXBvbmVudCA9IEFuZ3VsYXJGb250QXdlc29tZUNvbXBvbmVudDtcclxuZXhwb3J0cy5Bbmd1bGFyRm9udEF3ZXNvbWVTZXJ2aWNlID0gQW5ndWxhckZvbnRBd2Vzb21lU2VydmljZTtcclxuZXhwb3J0cy5Bbmd1bGFyRm9udEF3ZXNvbWVNb2R1bGUgPSBBbmd1bGFyRm9udEF3ZXNvbWVNb2R1bGU7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cclxufSkpKTtcclxuXHJcbiJdfQ==